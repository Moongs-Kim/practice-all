[git github 명령어]

깃허브는 모든 업로드와 다운로드를 커밋 단위로 주고 받는다
깃허브는 다른 사람의 작업을 덮어씌우거나 충돌할 걱정 없이 편하게 협업할 수 있게 한다.

git push : 로컬에 있는 커밋 내역 중에서 아직 원격 저장소에 없는 커밋을 업로드

git remote add origin 주소
    -git remote add : 원격 저장소를 추가
    -origin : 원격 저장소 이름, 이름이므로 꼭 origin이 아니여도됨

git branch -M main : 프로젝트의 기본 브랜치 이름을 main으로 바꿔 주는 것

git push -u origin main : 현재 로컬의 (main)브랜치가 원격(origin) 저장소의 어떤 브랜치와 연동될지 지정
    -> 현재 내 로컬의 main 브랜치에서 푸시할 때 원격 저장소의 어느 브랜치(main)에 푸시할지를 기본으로 설정
       설정 후 git push만 입력해도 origin/main 브랜치로 업로드
    -> 위 명령에서 -u는 --set-upstream과 동일하다

git remote : 해당 프로젝트와 연결된 원격 저장소의 목록을 보여줌
git remote -v : 원격 저장소의 목록과 함께 저장소 주소도 확인 가능
git remote remove 원격저장소 명 : 원격 저장소와의 연결 끊기. 원격 저장소를 삭제하는건 아님

git pull : 깃허브 원격 저장소의 커밋을 내 로컬 컴퓨터로 가져온다

<pull할것이 있는데 push 할때>
이때는 git push 실행시 오류가 발생
깃허브의 최신 내역을 pull 하지 않았기 때문
자신의 원격 저장소에서 무언가를 푸시하려면 내 작업 내역이 원격 저장소의 최신 내역과 동일하게 맞춰져 있어야 한다.

--이때 풀하는 방법--
1. merge 방식 = --no-rebase
2. rebase 방식
위 두 가지 방식중 하나를 기본값으로 설정할 수 있음, 설정 업으면 --no-rebase가 디폴트

git pull --no-rebase
내 로컬과 원격 저장소의 커밋을 통합한 커밋을 만들어 동기화
로컬 컴퓨터와 원격 저장소의 어긋난 타임라인을 한군데로 모아 주는 방식

git pull --rebase -> 이후 git push
원격 저장소의 타임라인을 유지 후 로컬 컴퓨터의 커밋을 원격 저장소의 커밋에 재배치
즉 원격에서의 변화가 먼저 발생한 것으로 하고, 내 작업은 그 이후 적용된 것으로 함

<충돌 해결>
git pull --no-rebase -> 충돌 -> 충돌 해결 -> git add, git commit

git pull --rebase -> 충돌 -> 충돌 해결 -> git add, git rebase --continue

* 원격 저장소의 작업을 pull 할때 리베이스는 협업시 사용해도 괜찮음

<로컬의 작업 내역을 강제로 푸시>
git push --force : 로컬 컴퓨터의 작업 내역을 기준으로 강제로 맞춰야 할때 사용

* 서로 합의가 된 상태에서 사용해야 한다.

<원격 저장소 브랜치 다루기>
로컬에서 새로운 브랜치를 만든 후 git push를 사용하면 푸시가 되지 않는다.
왜냐하면 새로운 브랜치를 어디에 푸시해야 할지 모르니 원격 저장소에 새 브랜치를 만들어야한다.

git push -u origin 새 브랜치 명 = git push --set-upstream origin 새 브랜치 명

gir branch --all = git branch -a : 로컬과 원격의 브랜치를 모두 확인
git fetch : 원격 저장소의 변경 사항 확인, 원격의 변화가 로컬에 업데이트가 안되어 있을때

git switch -t origin/원격 브랜치 명 : 로컬에 원격 브랜치와 같은 이름의 브랜치를 복사해서 연결

git push 원격 저장소 이름 --delete 원격 저장소 브랜치 이름 : 원격의 브랜치 삭제

<깃허브에서 프로젝트 다운로드>
git clone 원결저장소 주소 : 해당 프로젝트의 파일 및 .git 폴더 까지 가져온다

