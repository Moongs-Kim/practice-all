[git 더 깊게 이해하기]

<깃의 특징>
- 스냅샷 방식을 사용한다
  새로운 버전이 만들어질 때 해당 버전의 파일이 최종 상태 그대로 저장되는 방식
  스냅샷 방식은 현 시점에 파일이 저장되어 있어 최종 결과물을 훨씬 빨리 확인 가능하다

  SVN은 델타 방식을 사용 - 스냅샷 방식과의 차이는
  델타 방식은 파일이 수정되면 버전마다 수정된 부분만 저장이 된다.
  따라서 마지막 버전에서 파일을 확인할때 처음 버전부터 수정사항을 다 더해 최종 상태를 보여준다
  따라서 커밋의 갯수가 많아지면 최종 버전에서 결과물을 확인하는데 시간이 오래 걸린다

  반면 스냅샷 방식은 최종 버전에 모든 내용이 다 반영이 되어 있어 확인하는데 시간이 덜 걸린다.
  강의 설명에 따르면 용량에 대한 최적화를 하는것으로 알고 있다.

- 분산 버전 관리 시스템
  깃은 중앙집중식 버전 관리가 아닌 분산 버전 관리 시스템이다.

  CVS, SVN 은 중앙집중식 버전 관리이다. 따라서 원격 서버에 모든 내역을 저장한다.
  중앙 서버에서 현 버전의 파일을 다운로드 해야 작업을 할 수 있다.
  이런 방식은 중앙 서버 또는 인터넷 연결 문제가 생기면 로컬에서 작업하는 데 제한이 생긴다.

  반면 깃은 원격 저장소에서 전체 커밋과 브랜치를 로컬로 받아와 로컬에서 자유롭게 작업할 수 있다.
  구성원 모두가 자신의 컴퓨터에 깃의 작업 내역들을 가지고 있기 때문에 편하게 작업할 수 있다.
  작업 후 원하는 때에 프로젝트를 푸시와 풀로 동기화 하며 협업할 수 있다.


<깃의 세 가지 공간>
1. working directory (작업 디렉토리)
2. staging area (스테이지 영역)
3. repository (저장소)

- working directory (작업 디렉토리)
  새로 파일 추가, 기존 파일 변경, 삭제 등 수정 사항 발생시 적용됨
  이 안에서 tracked, untracked 두 가지 상태로 나눌 수 있다.
  - tracked : 깃의 관리 대상에 정식으로 등록된 것
  - untracked : .gitignore 파일에 추가되어 있거나, 새로 만들어져 아직 관리되어 본 적이 없는 파일(git add 명령을 적용하지 않은 파일)

- stage area (스테이지 영역)
  git add 명령 후 적용됨
  스테이지 영역은 저장소에 들어가기 전 준비 단계라 생각하기

- repository (저장소)
  git commit 명령 후 적용됨
  커밋이 저장되어 어떤 버전 안에 들어 있는 공간

   (정리)
EX) 1. 파일을 만든다
    2. 작업 디렉터리에 들어감 + untracked
    3. git add 하면 스테이지 영역에 들어감
    4. git commit 하면 저장소에 들어감
    5. 파일을 수정하면 다시 작업 디렉터리로 돌아감

<git rm, git mv>
git rm 파일 이름 : 파일 삭제 후 동시에 삭제된 변경 사항이 '스테이지 영역'에 반영됨
git mv (원본 파일 명) (변경 파일 명) : 파일 명 변경 후 변경 사항이 '스테이지 영역'에 반영됨

<restore 명령>
git restore 파일 명 : 작업 디렉터리에 있는 해당 파일을 수정하기 전으로 되돌림(이전 커밋 상태로 되돌림)
git restore . : 작업 디렉터리에 있는 모든 파일을 수정하기 전으로 되돌림(이전 커밋 상태로 되돌림)

git restore --staged 파일 명 : 스테이지 영역에 있는 해당 파일을 작업 디렉터리로 되돌림(add 하기 전 상태)
git restore --staged . : 스테이지 영역에 있는 모든 파일을 작업 디렉터리로 되돌림(add 하기 전 상태)

<reset 명령>
git reset --hard 해시값
작업 내역 자체를 지운다. 어떤 변경 사항을 작업 디렉터리에서도 없애는 가장 급진적인 방법

git reset --mixed 해시값
변경 사항을 작업 디렉터리에는 남겨 두지만, 파일 자체는 변경하지 않는다.
즉 변경 사항을 스테이지 영역에서만 제거하는 명령
이 명령은 기본값이라 --mixed를 안하고 git reset만 해도 적용된다.

git reset --soft 해시값
변경 사항을 저장소에서만 제거한다.
즉 스테이지 영역에 남겨 둔다.(add가 된 상태)

<체크아웃과 패치>
HEAD의 개념 : 현재 작업 중인 브랜치의 가장 최신 커밋을 나타냄(브랜치의 가장 마지막 커밋)

--HEAD의 변화 상황--
1. 새로운 커밋이 작업 중인 브랜치에 추가될 때
2. 새로운 브랜치를 생성할 때
3. 다른 브랜치로 이동할 때

--체크아웃--
HEAD를 이동해서 이전 커밋으로 돌아가는 등의 작업을 수행할 수 있다. 또는 이동 후 새 브랜치 생성해서 분기
작업 내역을 그대로 두고 파일의 상태만 과거 시점으로 이동할 때 사용(reset과 revert 와는 다르다)

git checkout HEAD^

HEAD^^^ : ^(캐럿)의 갯수만큼 커밋을 뒤로 이동
HEAD~~ : ~(물결)의 갯수만큼 커밋을 뒤로 이동
HEAD~3 : ~ + 숫자 만큼 커밋을 뒤로 이동

git checkout - : 뒤로 이동한 단계를 다시 한 단계 앞으로 이동

git checkout 해시값 : 해시값으로 이동

checkout 사용시 이전에 없던 임의의 브랜치가 생성됨
즉 checkout 으로 과거로 돌아간다는 것은 해당 시점에 아직 이름이 지어지지 않은 임시 브랜치를 생성한 뒤
그쪽으로 이동하는 것

checkout 사용 후 다시 다른 브랜치로 이동하려면 'switch 브랜치 명' 사용 하면됨

--HEAD 사용해서 리셋--
git reset (옵션) HEAD~
git reset (옵션) HEAD^
git reset (옵션) HEAD~2

--패치--
패치와 풀의 차이
pull : 원격 저장소의 최신 커밋을 로컬 컴퓨터로 가져와 머지하거나 리베이스 한다.
fetch : 원격 저장소의 최신 커밋을 로컬로 가져오기만 한다(머지, 리베이스 진행x)

패치로 변경 사항을 미리 확인할 수 있다
- 원격의 변화를 로컬로 가져와 합치기 전 살펴보기 위해 사용

패치를 하면 로컬에 가상의 브랜치가 하나 추가되고 변경 사항을 받아 온다.
그 후 'git checkout origin/브랜치 명' 을 사용하면 임의 브랜치로 이동하고
원격의 변경 사항을 확인할 수 있다.
이상이 없다고 판단하면 git pull을 사용하면 된다.
즉 원격 저장소에 있는 내용을 패치하고, 체크아웃으로 이동해 전체 폴더의 상태를 확인할 수 있다.

패치를 사용하기 전에 원격에 브랜치가 추가되어 있으면 로컬에서는 새로운 브랜치를 확인할 수 없다
이때 'git fetch' 를 사용하고 'git branch -a' 를 사용하면 원격의 새 브랜치를 확인할 수 있다.
물론 확인만 하려면 'git checkout origin/새 브랜치 명' 사용하면 된다.
확인 후 이상이 없다면
'git switch -t origin/새 브랜치 명' 을 사용해 로컬에 원격 브랜치를 연결해 사용할 수 있다.



