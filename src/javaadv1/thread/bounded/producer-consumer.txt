[생산자 소비자 문제]

생산자 소비자 문제는 멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에
데이터를 생산하고 소비하는 상황을 다룬다.

멀티스레드의 핵심을 제대로 이해하려면 반드시 생산자 소비자 문제를 이해하고, 올바른 해결 방안도 함께
알아두어야 한다.
생산자 소비자 문제를 제대로 이해하면 멀티스레드를 제대로 이해했다고 볼 수 있다. 그 만큼 중요한 내용이다.

== 기본 개념 ==
- 생산저(Producer): 데이터를 생산하는 역할을 한다. 예를 들어, 파일에서 데이터를 읽어오거나 네트워크에서
                   데이터를 받아오는 스레드가 생산자 역할을 할 수 있다.
- 소비자(Consumer): 생성된 데이터를 사용하는 역할을 한다. 예를 들어, 데이터를 처리하거나 저장하는 스레드가
                   소비자 역할을 할 수 있다.
- 버퍼(Buffer): 생산자가 생성한 데이터를 일시적으로 저장하는 공간이다. 이 버퍼는 한정된 크기를 가지며,
               생산자와 소비자가 이 버퍼를 통해 데이터를 주고받는다.

== 문제 상황 ==
- 생산자가 너무 빠를 때: 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다.
                      버퍼가 가득 찬 경우 생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.
- 소비자가 너무 빠를 때: 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.
                      버퍼가 비어있을 때 소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.

이 문제는 다음 두 용어로 불린다. 둘다 같은 뜻이다.
- 생산자 소비자 문제(producer-consumer problem)
    생산자 소비자 문제는, 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고, 소비하면서 발생하는 문제이다.
- 한정된 버퍼 문제(bounded-buffer problem)
    이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다. 따라서 한정된 버퍼 문제라고도 한다.

<Object -wait, notify>
자바는 처음부터 멀티스레드를 고려하며 탄생한 언어다.

== wait(), notify() ==
1) Object.wait()
    - 현재 스레드가 가진 락을 반납하고 대기(WAITING)한다.
    - 현재 스레드를 대기(WAITING)상태로 전환한다. 이 메서드는 현재 스레드가 synchronized
      블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다. 호출한 스레드는 락을 반납하고
      다른 스레드가 해당 락을 획득할 수 있도록 한다. 이렇게 대기 상태로 전환된 스레드는 다른 스레드가
      notify() 또는 notifyAll()을 호출할 때까지 대기 상태를 유지한다.

2) Object.notify()
    - 대기 중인 스레드 중 하나를 깨운다.
    - 이 메서드는 synchronized 블록이나 메서드에서 호출되어야 한다. 깨운 스레드는 락을 다시
      획득할 기회를 얻게 된다. 만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다.

3) Object.notifyAll()
    - 대기 중인 모든 스레드를 깨운다.
    - 이 메서드 역시 synchronized 블록이나 메서드에서 호출되어야 하며, 모든 대기 중인 스레드가
      락을 획득할 수 있는 기회를 얻게 된다. 이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.

wait(), notify() 메서드를 적절히 사용하면, 멀티스레드 환경에서 발생할 수 있는 문제를 효율적으로 해결할 수 있다.
이 기능을 활용하면 스레드가 락을 가지고 임계 영역안에서 무한 대기하는 문제를 해결 할 수 있다.

wait()로 대기 상태에 빠진 스레드는 notify()를 사용해야 깨울 수 있다. 생산자는 생산을 완료하면
notify()로 대기하는 스레드를 깨워서 생산된 데이터를 가져가게 하고, 소비자는 소비를 완료하면 notify()로
대기하는 스레드를 깨워서 데이터를 생산하라고 하면 된다.
핵심은 wait()를 호출해서 대기 상태에 빠질 때 '락을 반납하고 대기 상태에 빠진다는 것이다.'
대기 상태에 빠지면 어차피 아무일도 하지 않으므로 락도 필요하지 않다.

== 스레드 대기 집합(wait set) ==
- synchronized 임계 영역 안에서 Object.wait()를 호출하면 스레드는 대기(WAITING) 상태에 들어간다.
  이렇게 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합(wait set)이라 한다. 참고로 모든 객체는
  각자의 대기 집합을 가지고 있다.
- 모든 객체는 락(모니터 락)과 대기 집합을 가지고 있다. 둘은 한 쌍으로 사용된다. 따라서 락을 획득한 객체의
  대기 집합을 사용해야 한다.
- 스레드 대기 집합에서 관리되는 스레드는 이후에 다른 스레드가 notify()를 통해 스레드 대기 집합에 신호를주면
  깨어날 수 있다.
- 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.
- 임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다. 즉, WAITING -> BLOCKED 상태가 된다.
  당연한 이야기지만 임계 영역 안에서 2개의 스레드가 실행되면 큰 문제가 발생한다. 임계 영역 안에서는
  락을 가지고 있는 하나의 스레드만 실행 되어야 한다.
- 참고로 이때 임계 영역의 코드를 처음으로 돌아가서 실행하는 것은 아니다. 대기 집합에 들어오게 된 wait(0를
  호출한 부분 부터 실행된다. 락을 획득하면 wait() 이후의 코드를 실행한다.
- notify()를 받은 스레드 대기 집합은 스레드 중에 하나를 깨운다.
- 어떤 스레드가 깨워질지는 JVM 스펙에 명시되어 있지 않다. 따라서 JVM 버전, 환경 등에 따라서 달라지낟.
* 정리
wait(), notify() 덕분에 스레드가 락을 놓고 대기하고, 또 대기하는 스레드를 필요한 시점에 깨울 수 있다.

<Object - wait,notify 한계>
생산자 소비자 문제에서
★같은 종류의 스레드를 깨울 때 비효율이 발생한다.
이 내용을 통해서 알 수 있는 사실은 생산자가 같은 생산자를 깨우거나, 소비자가 같은 소비자를 깨울 때
비효율이 발생할 수 있다는 점이다. 생산자가 소비자를 깨우고, 반대로 소비자가 생산자를 깨운다면 이런
비효율은 발생하지 않는다.

== 스레드 기아(thread starvation) ==
notify()의 또 다른 문제점으로는 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는
스레드 기아 문제가 있다.

대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황을 스레드 기아(starvation)
상태라 한다.

이런 문제를 해결하는 방법 중에 notify() 대신에 notifyAll()을 사용하는 방법이 있다.

== notifyAll() ==
notifyAll()을 사용하면 스레드 대기 집합에 있는 모든 스레드를 한번에 다 깨울 수 있다.

- 대기 집합에 있는 모든 스레드가 깨어난다.
- 모든 스레드는 다 임계 영역 안에 있다. 따라서 락을 먼저 획득해야 한다.
- 락을 획득하지 못하면 BLOCKED 상태가 된다.
- 하지만 notifyAll()을 사용해서 스레드 기아 문제는 막을 수 있지만, 비효율을 막지는 못한다.

* 위와 같은 비효율 문제는 스레드가 대기하는 대기 집합이 하나인데
  원하는 스레드를 선택해서 깨울 수 없기 때문이다.

== 해결 방안 ==
핵심은 생산자 스레드는 데이터를 생성하고, 대기중인 소비자 스레드에게 알려준다.
반대로 소비자 스레드는 데이터를 소비하고, 대기중인 생산자 스레드에게 알려준다.
결국 생산자 스레드가 대기하는 집합과, 소비자 스레드가 대기하는 대기 집합을 둘로 나누면 된다.
이렇게 생산자용, 소비자용 대기 집합을 서로 나누어 분리하면 비효율 문제를 깔끔하게 해결할 수 있다.
대기 집합을 분리하는 방법은 Lock, ReentrantLock을 사용하면 된다.

※참고
자바는 1.0부터 존재한 synchronized와 BLOCKED 상태를 통한 임계 영역 관리의 단점을 해결하기 위해
자바 1.5부터 Lock 인터페이스와 ReentrantLock 구현체를 제공한다.

== Condition ==
Condition condition = lock.newCondition()
Condition은 ReentrantLock을 사용하는 스레드가 대기하는 스레드 대기 공간이다.
lock.newCondition() 메서드를 호출하면 스레드 대기 공간이 만들어진다. Lock(ReentrantLock)의
스레드 대기 공간은 이렇게 만들 수 있다.

참고로 Object.wait()에서 사용한 스레드 대기 공간은 모든 객체 인스턴스가 내부에 기본으로 가지고 있다.
반면 Lock(ReentrantLock)을 사용하는 경우 이렇게 스레드 대기 공간을 직접 만들어서 사용해야 한다.

== condition.await() ==
Object.wait()와 유사한 기능이다. 지정한 condition에 현재 스레드를 대기(WAITING) 상태로 보관한다.
이때 ReentrantLock 에서 획득한 락을 반납하고 대기 상태로 condition에 보관된다.

== condition.signal() ==
Object.notify()와 유사한 기능이다. 지정한 condition 에서 대기중인 스레드를 하나 깨운다.
깨어난 스레드는 condition 에서 빠져나온다.

lock은 synchronized 에서 사용하는 객체 내부에 있는 모니터 락이 아니라, ReentrantLock 락을
뜻한다.
ReentrantLock은 내부에 락과, 락 획득을 대기하는 스레드를 관리하는 대기 큐가 있다.

Condition condition = lock.newCondition()
ReentrantLock을 사용하면 condition이 스레드 대기 공간이다.

<생산자 소비자 대기 공간 분리>
★핵심은 생산자는 소비자를 깨우고, 소비자는 생산자를 깨운다
소비자가 소비자를 깨운다거나, 생산자가 생산자를 깨우지 않기 때문에, 비효율적으로 실행되는 부분이
제거되고 아주 깔끔하게 작업이 실행된다.

== Object.notify() vs Condition.signal() ==
- Object.notify()
    - 대기 중인 스레드 중 임의의 하나를 선택해서 깨운다. 스레드가 깨어나는 순서는 정의되어 있지 않으며,
      JVM 구현에 따라 다르다. 보통은 먼저 들어온 스레드가 먼저 수행되지만 구현에 따라 다를 수 있다.
    - synchronized 블록 내에서 모니터 락을 가지고 있는 스레드가 호출해야 한다.

- Condition.signal()
    - 대기 중인 스레드 중 하나를 깨우며, 일반적으로는 FIFO 순서로 깨운다. 이 부분은 자바 버전과 구현에
      따라 달라질 수 있지만, 보통 Condition의 구현은 Queue 구조를 사용하기 때문에 FIFO 순서로 깨운다.
    - ReentrantLock을 가지고 있는 스레드가 호출해야 한다.

== 락 대기 집합 ==
스레드가 모니터 락을 기다리는 상태와 Object.wait()을 통한 대기 상태는 다르다.
즉, 두 대기 공간은 다르다는 것이다.

락을 기다리는 스레드도 어딘가에서 관리가 되어야 한다. 그래야 락이 반환되었을 때 락을 기다리는 스레드들 중
하나를 선택해서 락을 제공할 수 있다.

synchronized의 락 대기 집합
- 락 대기 집합은 락을 기다리는 BLOCKED 상태의 스레드들을 관리한다.
- 락 대기 집합은 자바 내부에 구현되어 있기 때문에 모니터 락과 같이 개발자가 확인하기는 어렵다.
- 락이 반납되면 락 대기 집합에서 관리되는 스레드 중 하나가 락을 획득한다.

개념상 락 대기 집합이 1차 대기소이고, 스레드 대기 집합이 2차 대기소이다.
2차 대기소에 있는 스레드는 2차 대기소를 빠져나온다고 끝이 아니다. 1차 대기소까지 빠져나오야 임계 영역에서
로직을 수행할 수 있다. 비유를 하자면 임계 영역을 안전하게 지키기 위한 2중 감옥인 것이다.
스레드는 2중 감옥을 모두 탈출해야 임계 영역을 수행할 수 있다.

* 정리
자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본 요소를 가진다.
- 모니터 락
- 락 대기 집합(모니터 락 대기 집합)
- 스레드 대기 잡합

여기서 락 대기 집합이 1차 대기소이고, 스레드 대기 집합이 2차 대기소라 생각하면 된다.
2차 대기소에 들어간 스레드는 2차, 1차 대기소를 모두 빠져나와야 임계 영역을 수행할 수 있다.

이 3가지 요소는 서로 맞물려 돌아간다.
- synchronized를 사용한 임계 영역에 들어가려면 모니터 락이 필요하다.
- 모니터 락이 없으면 락 대기 집합에 들어가서 BLOCKED 상태로 락을 기다린다.
- 모니터 락을 반납하면 락 대기 집합에 있는 스레드 중 하나가 락을 획득하고 BLOCKED -> RUNNABLE 상태가 된다.
- wait()를 호출해서 스레드 대기 집합에 들어가기 위해서는 모니터 락이 필요하다.
- 스레드 대기 집합에 들어가면 모니터 락을 반납한다.
- 스레드가 notify()를 호출하면 스레드 대기 집합에 있는 스레드 중 하나가 스레드 대기 집합을 빠져나온다.
  그리고 모니터 락 획득을 시도한다.
    - 모니터 락을 획득하면 임계 영역을 수행한다.
    - 모니터 락을 획득하지 못하면 락 대기 집합에 들어가서 BLOCKED 상태로 락을 기다린다.

== synchronized vs ReentrantLock 대기 ==
synchronized와 마찬가지로 Lock(ReentrantLock)도 2가지 단계의 대기 상태가 존재한다.

1) 대기1: ReentrantLock 락 획득 대기
    - ReentrantLock의 대기 큐에서 관리
    - WAITING 상태로 락 획득 대기
    - lock.lock()을 호출 했을 때 락이 없으면 대기
    - 다른 스레드가 lock.unlock()을 호출 했을 때 대기가 풀리며 락 획득 시도, 락을 획득하면
      대기 큐를 빠져나감
2) 대기2: await() 대기
    - condition.await()를 호출 했을 때, condition 객체의 스레드 대기 공간에서 관리
    - WAITING 상태로 대기
    - 다른 스레드가 condition.signal()을 호출 했을 때 condition 객체의 스레드 대기 공간에서
      빠져나감

 2단계 대기소
참고로 깨어난 스레드는 바로 실행되는 것이 아니다. synchronized와 마찬가지로 ReentrantLock도 대기소가
2단계로 되어 있다. 2단계 대기소인 condition 객체의 스레드 대기 공간을 빠져나온다고 바로 실행되는 것이
아니다.
임계 영역 안에서는 항상 락이 있는 하나의 스레드만 실행될 수 있다. 여기서는 ReentrantLock의 락을
획득해야 RUNNABLE 상태가 되면서 그 다음 코드를 실행할 수 있다. 락을 획득하지 못하면 WAITING 상태로
락을 획득할 때 까지 ReentrantLock의 대기 큐에서 대기한다.

<BlockingQueue>
BoundedQueue를 스레드 관점에서 보면 큐가 특정 조건이 만족될 때까지 스레드의 작업을 차단(blocking)한다.
- 데이터 추가 차단: 큐가 가득 차면 데이터 추가 작업을 시도하는 스레드는 공간이 생길 때까지 차단된다.
- 데이터 획득 차단: 큐가 비어 있으면 획득 작업을 시도하는 스레드는 큐에 데이터가 들어올 때까지 차단된다.

그래서 스레드 관점에서 이 큐에 이름을 지어보면 BlockingQueue 라는 이름이 적절하다.
자바는 생산자 소비자 문제, 또는 한정된 버퍼라 불리는 문제를 해결하기 위해
java.util.concurrent.BlockingQueue 라는 인터페이스와 구현체들을 제공한다.
이는 생산자 소비자 문제를 해결하기 위한 특별한 멀티스레드 자료 구조를 제공한다.
이름 그대로 스레드를 차단(Blocking)할 수 있는 큐다.

BlockingQueue는 인터페이스이다

== BlockingQueue의 메서드 ==
- 데이터 추가 메서드: add(), offer(), put(), offer(타임아웃)
- 데이터 획득 메서드: take(), poll(타임아웃), remove(..)
- Queue를 상속 받는다. 큐를 상속 받았기 때문에 추가로 큐의 기능들도 사용할 수 있다.

== BlockingQueue 인터페이스의 대표적인 구현체 ==
- ArrayBlockingQueue: 배열 기반으로 구현되어 있고, 버퍼의 크기가 고정되어 있다.
- LinkedBlockingQueue: 링크 기반으로 구현되어 있고, 버퍼의 크기를 고정할 수도, 또는 무한하게
                       사용할 수도 있다.

※참고: Deque용 동시성 자료 구조인 BlockingDeque도 있다.

== 큐가 가득 찼을 때 생각할 수 있는 4가지 선택지 ==
- 예외를 던진다. 예외를 받아서 처리한다.
- 대기하지 않는다. 즉시 false를 반환한다.
- 대기한다.
- 특정 시간 만큼만 대기한다.

* 정리
java.util.concurrent 패키지가 제공하는 Lock, ReentrantLock, Condition, BlockingQueue 등은
견고하게 잘 만들어진 라이브러리이다.

java.util.concurrent 패키지가 제공하는 동시성 라이브러리는 매우 견고하고, 높은 성능을 낼 수 있도록
최적화 되어 있다. 그리고 다양한 동시성 시나리오를 대응할 수 있고, 무엇보다 개발자가 쉽고 편리하게 복잡한
동시성 문제를 다룰 수 있게 해준다.





