[동시성 컬렉션]

<동시성 컬렉션이 필요한 이유>
컬렉션 프레임워크가 제공하는 대부분의 연산은 원자적인 연산이 아니다.

★컬렉션 프레임워크 대부분은 스레드 세이프 하지 않다.
단일 스레드가 컬렉션에 접근하는 경우라면 아무런 문제가 없지만, 멀티스레드 상황에서
여러 스레드가 동시에 컬렉션에 접근하는 경우라면 일반적인 컬렉션들은 사용하면 안된다.

모든 컬렉션에 synchronized를 사용한 동기화용 컬렉션을 만들면 멀티스레드 상황에서 스레드 안전 하지만
모든 컬렉션을 다 복사해서 동기화 용으로 새로 구현해야 하는것은 매우 비효율적이다.
이럴 경우 이후 구현이 변경되면 같은 모양의 코드를 2곳에서 변경해야 한다.


== ★프록시 도입 ==
기존 컬렉션을 그대로 사용하면서, 멀티스레드 상황에 동기화가 필요할 때만 synchronized 기능을
살짝 추가하고 싶다면?

이럴때 사용하는 것이 바로 프록시 이다.

★프록시(Proxy)
우리말로 대리자, 대신 처리해주는 자라는 뜻이다.
프록시를 쉽게 풀어서 설명하자면 친구에게 대신 음식을 주문해달라고 부탁하는 상황을 생각해 볼 수 있다.
- 나(클라이언트) -> 음식점(서버)
- 나(클라이언트) -> 친구(프록시) -> 음식점(서버)

- 객체 세상에도 이런 프록시를 만들 수 있다. 여기서는 프록시가 대신 동기화(synchronized) 기능을
  처리해주는 것이다.
- 프록시가 동기화를 적용하고 원본을 호출하기 때문에 원본 코드도 이미 동기화가 적용된 상태로 호출된다.
- 핵심은 원본 코드를 전혀 손대지 않고 프록시를 통해 동기화 기능을 적용했다는 점이다.
  또한 이후 다른 코드를 만들더라도 프록시 객체를 그대로 활용할 수 있다.
  즉, 프록시 하나로 동기화 기능을 적용시킬 수 있다.

== ★프록시 패턴 ==
프록시 패턴(Proxy Pattern)은 객체지향 디자인 패턴 중 하나로, 어떤 객체에 대한 접근을 제어하기 위해
그 객체의 대리인 또는 인터페이스 역할을 하는 객체를 제공하는 패턴이다. 프록시 객체는 실제 객체에
대한 참조를 유지하면서, 그 객체에 접근하거나 행동을 수행하기 전에 추가적인 처리를 할 수 있도록 한다.

- 프록시 패턴의 주요 목적
1) 접근 제어: 실제 객체에 대한 접근을 제한하거나 통제할 수 있다.
2) 성능 향상: 실제 객체의 생성을 지연시키거나 캐싱하여 성능을 최적화할 수 있다.
3) 부가 기능 제공: 실제 객체에 추가적인 기능(로깅, 인증, 동기화 등)을 투명하게 제공할 수 있다.

※참고
실무에서 프록시 패턴은 자주 사용된다. 스프링의 AOP 기능은 이런 프록시 패턴을 극한으로 적용하는 예이다.

<자바 동시성 컬렉션>
자바가 제공하는 java.util 패키지에 있는 컬렉션 프레임워크들은 대부분 스레드 안전(Thread Safe)하지 않다.

동기화의 필요성을 정확히 판단하고 꼭 필요한 경우에만 동기화를 적용하는 것이 필요하다.

자바는 컬렉션을 위한 프록시 기능을 제공한다.

== 자바 synchronized 프록시 ==
Collections는 다음과 같이 다양한 synchronized 동기화 메서드를 지원한다.
이 메서드를 사용하면 List, Collection, Map, Set 등 다양한 동기화 프록시를 만들어낼 수 있다.

Collections가 제공하는 동기화 프록시 기능 덕분에 스레드 안전하지 않은 수 많은 컬렉션들을
매우 편리하게 스레드 안전한 컬렉션으로 변경해서 사용할 수 있다.

== synchronized 프록시 방식의 단점 ==
1) 동기화 오버헤드가 발생한다. synchronized 키워드가 멀티스레드 환경에서 안전한 접근을 보장하지만,
   각 메서드 호출 시마다 동기화 비용이 추가된다. 이로 인해 성능 저하가 발생할 수 있다.
2) 전체 컬렉션에 대해 동기화가 이루어지기 때문에, 잠금 범위가 넓어질 수 있다. 이는 잠금 경함(lock contention)을
   증가시키고, 병렬 처리의 효율성을 저하시키는 요인이 된다. 모든 메서드에 대해 동기화를 적용하다 보면,
   특정 스레드가 컬렉션을 사용하고 있을 때 다른 스레드들이 대기해야 하는 상황이 빈번해질 수 있다.
3) 정교환 동기화가 불가능하다. synchronized 프록시를 사용하면 컬렉션 전체에 대한 동기화가 이루어지지만,
   특정 부분이나 메서드에 대해 선택적으로 동기화를 적용하는 것은 어렵다. 이는 과도한 동기화로 이어질 수 있다.

쉽게 말해 이 방식은 단순 무식하게 모든 메서드에 synchronized를 걸어버리는 것이다. 따라서 동기화에 대한
최적화가 이루어지지 않는다. 자바는 이런 단점을 보완하기 위해 java.util.concurrent 패키지에
동시성 컬렉션(concurrent collection)을 제공한다.

== 자바 동시성 컬렉션 ==
java.util.concurrent 패키지에는 고성능 멀티스레드 환경을 지원하는 다양한 동시성 컬렉션 클래스들을
제공한다. 더 정교한 잠금 메커니즘을 사용하여 동시 접근을 효율적으로 처리하며, 필요한 경우 일부 메서드에
대해서만 동기화를 적용하는 등 유연한 동기화 전략을 제공한다.

여기서 다양한 성능 최적화 기법들이 적용되어 있는데 synchronized, Lock(ReentrantLock), CAS,
분할 잠금 기술(segment lock)등 다양한 방법을 섞어서 매우 정교한 동기화를 구현하면서 동시에 성능도 최적화 했다.
각각의 최적화는 매우 어렵게 구현되어 있기 때문에, 자세한 구현을 이해하는 것 보다는, 멀티스레드 환경에
필요한 동시성 컬렉션을 잘 선택해서 사용할 수 있으면 충분하다.

== 동시성 컬렉션의 종류 ==
List
    - CopyOnWriteArrayList -> ArrayList의 대안
Set
    - CopyOnWriteArraySet -> HashSet의 대안
    - ConcurrentSkipListSet -> TreeSet의 대안(정렬된 순서 유지, Comparator 사용 가능)
Map
    - ConcurrentHashMap -> HashMap의 대안
    - ConcurrentSkipListMap -> TreeMap의 대안(정렬된 순서 유지, Comparator 사용 가능)
Queue
    - ConcurrentLinkedQueue: 동시성 큐, 비 차단(non-blocking) 큐이다.
Deque
    - ConcurrentLinkedDeque: 동시성 데크, 비 차단(non-blocking) 큐이다.

※참고
LinkedHashSet, LinkedHashMap 처럼 입력 순서를 유지하는 동시에 멀티스레드 환경에서 사용할 수 있는
Set, Map 구현체는 제공하지 않는다. 필요하다면 Collections.synchronizedXxx()를 사용해야 한다.

== 블로킹 큐도 알아보기 ==
BlockingQueue
- ArrayBlockingQueue
    - 크기가 고정된 블로킹 큐
    - 공정(fair) 모드를 사용할 수 있다. 공정(fair) 모드를 사용하면 성능이 저하될 수 있다.
- LinkedBlockingQueue
    - 크기가 무한하거나 고정된 블로킹 큐
- PriorityBlockingQueue
    - 우선순위가 높은 요소를 먼저 처리하는 블로킹 큐
- SynchronousQueue
    - 데이터를 저장하지 않는 블로킹 큐로, 생산자가 데이터를 추가하면 소비자가 그 데이터를 받을 때까지
      대기한다. 생산자-소비자 간의 직접적인 핸드오프(hand-off) 메커니즘을 제공한다.
      쉽게 말해 중간에 큐 없이 생산자, 소비자가 직접 거래한다.
- DelayQueue
    - 지연된 요소를 처리하는 블로킹 큐로, 각 요소는 지정된 지연 시간이 지난 후에야 소비될 수 있다.
      일정 시간이 지난 후 작업을 처리해야 하는 스케줄링 작업에 사용된다.

* 정리
자바가 제공하는 동시성 컬렉션은 멀티스레드 상황에 최적의 성능을 낼 수 있도록 다양한 최적화
기법이 적용되어 있다. 따라서 Collections.synchronizedXxx를 사용하는 것 보다 더 좋은
성능을 제공한다.

당연한 이야기지만 동시성은 결국 성능과 트레이드 오프가 있다. 따라서 단일 스레드가 컬렉션을 사용하는
경우에는 동시성 컬렉션이 아닌 일반 컬렉션을 사용해야 한다.

멀티스레드 환경에서는 동시성 컬렉션을 적절히 활용해서 버그를 예방하고 성능을 최적화하는 것이 중요하다.
동시성 컬렉션을 사용하면 코드의 안정성과 효율성을 높일 수 있으며, 예상치 못한 동시성 문제도 방지할 수 있다.



