[스레드2]

<스레드 기본 정보>
Thread 클래스는 스레드를 생성하고 관리하는 기능을 제공한다.

1. 스레드 생성
스레드를 생성할 때는 실행할 Runnable 인터페이스 구현체와, 스레드의 이름을 전달할 수 있다.

ex) Thread myThread = new Thread(new HelloRunnable(), "myThread");

- Runnable 인터페이스: 실행할 작업을 포함하는 인터페이스이다.
- 스레드 이름: "myThread" 처럼 생성자에 이름을 전달해 스레드 이름을 정할 수 있다.
              이 이름은 디버깅이나 로깅 목적으로 유용하다.
              이름을 생략하면 Thread-0, Thread-1과 같은 임의의 이름이 생성된다.

2. 스레드 객체 정보
ex) log("myThread = " + myThread);

- 스레드 객체를 문자열로 변환하여 출력한다. Thread 클래스의 toString() 메서드는
  스레드 ID, 스레드 이름, 우선순위, 스레드 그룹을 포함하는 문자열을 반환한다.
  Thread[#21,myThread,5,main]

3) 스레드 ID
ex) log("myThread.threadId() = " + myThread.threadId());
- threadId(): 스레드의 고유 식별자를 반환하는 메서드이다. 이 ID는 JVM 내에서 각 스레드에 대해 유일하다.
              ID는 스레드가 생성될 때 할당되며, 직접 지정할 수 없다.

4) 스레드 이름
ex) log("myThread.getName() = " + myThread.getName());
- getName(): 스레드의 이름을 반환하는 메서드이다. 생성자에서 이름을 지정할 수 있다.
             스레드 이름은 중복될 수 있지만, 스레드 ID는 중복되지 않는다.

5) 스레드 우선쉰위
ex) log("myThread.getPriority() = " + myThread.getPriority());
- getPriority(): 스레드의 우선순위를 반환하는 메서드이다. 우선순위는 1(가장 낮음) 에서 10(가장 높음)
                 까지의 값으로 설정할 수 있으며, 기본값은 5이다.
                 setPriority() 메서드를 사용해서 우선순위를 변경할 수 있다.
- 우선순위는 스레드 스케줄러가 어떤 스레드를 우선 실행할지 결정하는 데 사용된다. 하지만 실제 실행 순서는
  JVM 구현과 운영체제에 따라 달라질 수 있다.

6) 스레드 그룹
ex) log("myThread.getThreadGroup() = " + myThread.getThreadGroup());

- getThreadGroup(): 스레드가 속한 스레드 그룹을 반환하는 메서드이다. 스레드 그룹은 스레드를 그룹화하여
                    관리할 수 있는 기능을 제공한다. 기본적으로 모든 스레드는 부모 스레드와 동일한 스레드
                    그룹에 속하게 된다.
- 스레드 그룹은 여러 스레드를 하나의 그룹으로 묶어서 특정 작업(예: 일괄 종료, 우선순위 설정 등)을 수행할 수 있다.
- 부모 스레드(Parent Thread): 새로운 스레드를 생성하는 스레드를 의미한다. 스레드는 기본적으로 다른 스레드에 의해 생성된다.
                             이러한 생성 관계에서 새로 생성된 스레드는 생성한 스레드를 부모로 간주한다.

※참고: 스레드 그룹 기능은 직접적으로 잘 사용하지는 않기 때문에, 이런 것이 있구나 정도만 알고 넘어가자

7) 스레드 상태★
ex) log("myThread.getState() = " + myThread.getState());

- getState(): 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 Thread.State 열거형에 정의된
              상수 중 하나이다. 주요 상태는 다음과 같다.

              - NEW: 스레드가 아직 시작되지 않은 상태이다.
              - RUNNABLE: 스레드가 실행 중이거나 실행될 준비가 된 상태이다.
              - BLOCKED: 스레드가 동기화 락을 기다리는 상태이다.
              - WAITING: 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.
              - TIMED_WAITING: 일정 시간 동안 기다리는 상태이다.
              - TERMINATED: 스레드가 실행을 마친 상태이다.

<스레드의 생명 주기1>
스레드는 생성하고 시작하고, 종료되는 생명주기를 가진다.

== 스레드의 상태 ==
1) NEW: 스레드가 생성되었으나 아직 시작되지 않은 상태.
2) RUNNABLE: 스래드가 실행 중이거나 실행될 준비가 된 상태.
3) 일시 중지 상태들 (Suspended States)
    - BLOCKED(차단 상태): 스레드가 동기화 락을 기다리는 상태.
    - WAITING(대기 상태): 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태.
    - TIMED_WAITING(시간 제한 대기 상태): 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태.
4) TERMINATED: 스레드의 실행이 완료된 상태.

※참고
자바에서 스레드의 일시 중지 상태들 (Suspended States)이라는 상태는 없다.
스레드가 기다리는 상태들을 묶어서 쉽게 설명하기 위해 사용한 용어이다.

자바 스레드의 생명 주기는 여러 상태(State)로 나뉘어지며, 각 상태는 스레드가 실행되고 종료되기까지의
과정을 나타낸다.

== 스레드의 상태 Detail ==
1) New (새로운 상태)
    - 스레드가 생성되고 아직 시작되지 않은 상태이다.
    - 이 상태에서는 Thread 객체가 생성되지만, start() 메서드가 호출되지 않은 상태이다.
    - 예: Thread thread = new Thread(runnable);
2) Runnable (실행 가능 상태)
    - 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU 에서 실행될 수 있다.
    - start() 메서드가 호출되면 스레드는 이 상태로 들어간다.
    - 예: thread.start();
    - 이 이 상태는 스레드가 실행될 준비가 되어 있음을 나타내며, 실제로 CPU 에서 실행될 수 있는 상태이다.
      그러나 Runnable 상태에 있는 모든 스레드가 동시에 실행되는 것은 아니다. 운영체제의 스케줄러가 각
      스레드에 CPU 시간을 할당하여 실행하기 때문에, Runnable 상태에 있는 스레드는 스케줄러의 실행 대기열에
      포함되어 있다가 차례로 CPU 에서 실행된다.
    - 참고로 운영체제 스케줄러의 실행 대기열에 있든, CPU 에서 실제 실행되고 있든 모두 Runnable 상태이다.
      자바에서 둘을 구분해서 확인할 수는 없다. 보통 실행 상태라고 부른다.
3) Blocked (차단 상태)
    - 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태이다.
    - 예를 들어 synchronized 블록에 진입하기 위해 락을 얻어야 하는 경우 이 상태에 들어간다.
    - 예: synchronized (lock) {...} 코드 블록에 진입하려고 할 때, 다른 스레드가 이미 lock의 락을
          가지고 있는 경우
4) Waiting (대기 상태)
    - 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.
    - wait(), join() 메서드가 호출될 때 이 상태가 된다.
    - 스레드는 다른 스레드가 notify() 또는 notifyAll() 메서드를 호출하거나, join()이 완료될 때까지 기다린다.
    - 예: object.wait();
5) Timed Waiting (시간 제한 대기 상태)
    - 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.
    - sleep(long millis), wait(long timeout), join(long millis) 메서드가 호출될 때 이 상태가 된다.
    - 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어난다.
    - 예: Thread.sleep(1000);
6) Terminated (종료 상태)
    - 스레드의 실행이 완료된 상태이다.
    - 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다.
    - 스레드는 한 번 종료되면 다시 시작할 수 없다.

== 자바 스레드의 전이 과정 ==
1. New -> Runnable: start() 메서드를 호출하면 스레드가 Runnable 상태로 전이된다.
2. Runnable -> Blocked/Waiting/Timed Waiting: 스레드가 락을 얻지 못하거나, wait() 또는 sleep()
                                              메서드를 호출할 때 해당 상태로 전이된다.
3. Blocked/Waiting/Timed Waiting -> Runnable: 스레드가 락을 얻거나, 기다림이 완료되면 다시 Runnable
                                              상태로 돌아간다.
4. Runnable -> Terminated: 스레드의 run() 메서드가 완료되면 스레드는 Terminated 상태가 된다.

<체크 예외 재정의>
Runnable 인터페이스의 run() 메서드를 구현할 때
InterruptedException 체크 예외를 밖으로 던질 수 없다.

== 이유 ==
Runnable 인터페이스 정의
public interface Runnable {
    void run();
}

자바에서 메서드를 재정의 할 때, 재정의 메서드가 지켜야할 예외와 관련된 규칙★
1) 체크 예외
    - 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없다.
    - 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
2) 언체크(런타임) 예외
    - 예외 처리를 강제하지 않으므로 상관없이 던질 수 있다.

★위와 같은 제약을 두는 이유
부모 클래스의 메서드를 호출하는 클라이언트 코드는 부모 메서드가 던지는 특정 예외만을 처리하도록 작성된다.
자식 클래스가 더 넓은 범위의 예외를 던지면 해당 코드는 모든 예외를 제대로 처리하지 못할 수 있다.
이는 예외 처리의 일관성을 해치고, 예상하지 못한 런타임 오류를 초래할 수 있다.

★Runnable 인터페이스의 run() 메서드는 아무런 체크 예외를 던지지 않는다. 따라서 Runnable 인터페이스의
run() 메서드를 재정의 하는 곳에서는 체크 예외를 밖으로 던질 수 없다.

- main()은 체크 예외를 밖으로 던질 수 있다.
- run()은 체크 예외를 밖으로 던질 수 없다.

이해를 위한 예시 코드 (실제 작동하는 코드는 아님)
class Parent {
    void method() throws InterruptedException {
        // ...
    }
}
class Child extends Parent {
    @Override
    void method() throws Exception {
        // ...
    }
}
public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        try {
            p.method();
        } catch (InterruptedException e) {
        // InterruptedException 처리
        }
    }
}

- 자바 컴파일러는 Parent p의 method()를 호출한 것으로 인지한다.
- Parent p 는 InterruptedException를 반환하는데, 그 자식이 전혀 다른 예외(Exception)를 반환한다면
  클라이언트는 해당 예외를 잡을 수 없다.
  이것은 확실하게 모든 예외를 체크하는 체크 예외의 규약에 맞지 않는다.
  따라서 자바에서 체크 예외의 메서드 재정의는 다음과 같은 규칙을 가진다.

== 체크 예외 재정의 규칙 ==
- 자식 클래스에 재정의된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만을 던질 수 있다.
- 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의된 메서드도 체크 예외를 던질 수 없다.

== 안전한 예외 처리 ==
체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크 예외를 try-catch 블록 내에서
처리하게 된다. 이는 예외 발생 시 예외가 적절히 처리되지 않아서 프로그램이 비정상 종료되는 상황을 방지할 수 있다.
특히 멀티스레딩 환경에서는 예외 처리를 강제함으로써 스레드의 안정성과 일관성을 유지할 수 있다.
하지만 체크 예외를 강제하는 이런 부분들은 자바 초창기 기조이고, 최근에는 체크 예외보다는 언체크(런타임) 예외를 선호한다.

<join>
join() 메서드를 통해 WAITING(대기 상태)가 무엇이고 왜 필요한지 알아본다.

== Waiting (대기 상태) ==
- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.
- join()을 호출하는 스레드는 대상 스레드가 TERMINATED 상태가 될 때 까지 대기한다.
  대상 스레드가 TERMINATED 상태가 되면 호출 스레드는 다시 RUNNABLE 상태가 되면서 다음 코드를 수행한다.

특정 스레드가 완료될 때 까지 기다려야 하는 상황이라면 join()을 사용하면 된다.
하지만 join()의 단점은 다른 스레드가 완료될 때 까지 무기한 기다리는 단점이 있다.
만약 다른 스레드의 작업을 일정 시간 동안만 기다리고 싶다면 어떻게 해야 할까?

※참고 - this의 비밀★
어떤 메서드를 호출하는 것은, 정확히는 특정 스레드가 어떤 메서드를 호출하는 것이다.
스레드는 메서드의 호출을 관리하기 위해 메서드 단위로 스택 프레임을 만들고 해당 스택 프레임을
스택위에 쌓아 올린다.
이때 인스턴스의 메서드를 호출하면, 어떤 인스턴스의 메서드를 호출했는지 기억하기 위해, 해당 인스턴스의
참조값을 스택 프레임 내부에 저장해둔다. 이것이 바로 우리가 자주 사용하던 this 이다.

특정 메서드 안에서 this를 호출하면 바로 스택 프레임 안에 있는 this 값을 불러서 사용하게 된다.
이렇게 this가 있기 때문에 각각의 스레드는 자신의 인스턴스를 구분해서 사용할 수 있다.
예를 들어 필드에 접글할 때 this를 생략하면 자동으로 this를 참고해서 필드에 접근한다.

정리하면 this는 호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조이며, 이것이 스택 프레임 내부에
저장되어 있다.

- 내 생각: 스택 프레임 내부에 해당 인스턴스의 참조값을 가지고 있고 this 라는 키워드가 있으면
          this에 스택 프레임 내부 참조값을 사용한다 생각하자

== join - 특정 시간 만큼만 대기 ==
join은 두 가지 메서드가 있다.
- join(): 호출 스레드는 대상 스레드가 완료될 때 까지 무한정 대기한다.
- join(ms): 호출 스레드는 특정 시간 만큼만 대기한다. 호출 스레드는 지정한 시간이 지나면 다시
            RUNNABLE 상태가 되면서 다음 코드를 수행한다.

보통 무기한 대기하면 WAITING 상태가 되고, 특정 시간 만큼만 대기하는 경우 TIMED_WAITING 상태가 된다.

* 정리
다른 스레드가 끝날 때 까지 무한정 기다려야 한다면 join()을 사용하고, 다른 스레드의 작업을 무한정
기다릴 수 없다면 join(ms)를 사용하면 된다.
물론 기다리다 중간에 나오는 상황인데, 결과가 없다면 추가적인 오류 처리가 필요할 수 있다.


<인터럽트>
특정 스레드의 작업을 중간에 중단하려면 어떻게 해야할까?

인터럽트를 사용하면, WAITING, TIMED_WAITING 같은 대기 상태의 스레드를 직접 깨워서
작동하는 RUNNABLE 상태로 만들 수 있다.

- 특정 스레드의 인스턴스에 interrupt() 메서드를 호출하면, 해당 스레드에 인터럽트가 발생한다.
- 인터럽트가 발생하면 스레드에 InterruptedException이 발생한다.
    - 이때 인터럽트를 받은 스레드는 대기 상태에서 깨어나 RUNNABLE 상태가 되고, 코드를 정상 수행한다.
    - 이때 InterruptedException을 catch로 잡아서 정상 흐름으로 변경하면 된다.
- interrupt()를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다.
  오직 sleep() 처럼 InterruptedException을 던지는 메서드를 호출하거나 또는 호출하며 대기 중일 때
  예외가 발생한다.
- 참고로 스레드가 RUNNABLE 상태여야 catch의 예외 코드도 실행될 수 있다.

ex)
- main 스레드가 work 스레드에 interrupt()를 건다.
- work 스레드는 인터럽트 상태(true)가 된다.
- 스레드가 인터럽트 상태일 때는, sleep() 처럼 InterruptedException이 발생하는 메서드를 호출하거나
  또는 이미 호출하고 대기 중이라면 InterruptedException이 발생한다.
- 이때 2가지 일이 발생한다.
    - work 스레드는 TIMED_WAITING 상태에서 RUNNABLE 상태로 변경되고,
      InterruptedException 예외를 처리하면서 반복문을 탈출한다.
    - work 스레드는 인터럽트 상태가 되었고, 인터럽트 상태이기 때문에 인터럽트 예외가 발생한다.
    - 인터럽트 상태에서 인터럽트 예외가 발생하면 work 스레드는 다시 작동하는 상태가 된다.
      따라서 work 스레드의 인터럽트 상태는 종료된다. work 스레드의 인터럽트 상태는 false로 변경된다.
- 인터럽트가 적용되고, 인터럽트 예외가 발생하면, 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도
  정상으로 돌아온다.
- 인터럽트를 사용하면 대기중인 스레드를 바로 깨워서 실행 가능한 상태로 바꿀 수 있다.
  덕분에 반응성이 좋아진다.

- isInterrupted() 메서드는 인터럽트의 상태를 변경하지 않는다. 단순히 인터럽트의 상태를 확인만 한다.
- 스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
- 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.
- 자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(false)으로 돌리는 것은
  이런 이유 때문이다.

- 스레드의 인터럽트 상태를 단순히 확인만 하는 용도라면 isInterrupted()를 사용하면 된다.
- 하지만 직접 체크해서 사용할 때는 Thread.interrupted()를 사용해야 한다.
    - 이 메서드는
      스레드가 인터럽트 상태라면 true를 반환하고, 해당 스레드의 인터럽트 상태를 false로 변경한다.
      스레드가 인터럽트 상태가 아니라면 false를 반환하고, 해당 스레드의 인터럽트 상태를 변경하지 않는다.

Thread.interrupted()를 호출했을 때 스레드가 인터럽트 상태(true)라면, true를 반환하고, 해당 스레드의
인터럽트 상태를 false로 변경한다.

★자바는 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(false)으로 돌린다.
스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다.
인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다.

※예외
너무 긴급한 상황이어서 자원 정리도 하지 않고, 최대한 빨리 스레드를 종료해야 한다면
해당 스레드를 다시 인터럽트 상태로 변경하는 것도 방법이다.

<yield - 양보하기>
어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정한다. 그런데 특정 스레드가 크게 바쁘지
않은 상황이어서 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다. 이렇게 양보하면 스케줄링 큐에
대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있다.

자바의 스레드가 RUNNABLE 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.
- 실행 상태(Running): 스레드가 CPU 에서 실제로 실행 중이다.
- 실행 대기 상태(Ready): 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중이다.

운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 그리고 실행 대기 상태의 스레드들을
잠깐만 실행 상태로 변경해서 실행한다. 이 과정을 계속 반복한다.
참고로 자바에서는 두 상태를 구분할 수는 없다.

== yield()의 작동 ==
- Thread.yield() 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가
  실행될 수 있도록 한다.
- yield() 메서드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다.
  즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.

자바에서 Thread.yield() 메서드를 호출하면 현재 실행 중인 스레드가 CPU를 양보하도록 힌트를 준다.
이는 스레드가 자신에게 할당된 실행 시간을 포기하고 다른 스레드에게 실행 기회를 주도록 한다.
참고로 yield()는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않는다.
그리고 반드시 다른 스레드가 실행되는 것도 아니다.

yield()는 RUNNABLE 상태를 유지하기 때문에, 쉽게 말해 양보할 사람이 없다면 본인 스레드가 계속 실행될 수 있다.

참고로 최근에는 10코어 이상의 CPU도 많기 때문에 스레드 10개 정도만 만들어서 실행하면, 양보가 크게
의미가 없다. 양보해도 CPU 코어가 남기 때문에 양보하지 않고 계속 수행될 수 있다. CPU 코어 수 이상의
스레드를 만들어야 양보하는 상황을 확인할 수 있다.















