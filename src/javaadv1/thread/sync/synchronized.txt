[동기화 - synchronized]

멀티스레드를 사용할 때 가장 주의해야 할 점은, 같은 자원(리소스)에 여러 스레드가 동기세 접근할 때
발생하는 동시성 문제이다. 참고로 여러 스레드가 접근하는 자원을 공유 자원이라 한다.
대표적인 공유 자원은 인스턴스의 필드(멤버 변수)이다.
멀티스레드를 사용할 때는 이런 공유 자원에 대한 접근을 적절할게 동기환(synchronization)해서
동시성 문제가 발생하지 않게 방지하는 것이 중요하다.

== 임계 영역(critical section) ==
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한
  코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.
  ex) 공유 변수나 공유 객체를 수정

이런 임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 안전하게 보호해야 한다.
안전하게 보호하는 방법에 여러가지 방법이 있지만
자바는 synchronized 키워드를 통해 아주 간단하게 임계 영역을 보호할 수 있다.

<synchronized 메서드>
자바의 synchronized 키워드를 사용하면 한 번에 하나의 스레드만 실행할 수 있는 코드 구간을 만들 수 있다.

== synchronized ==
- ★모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.
    - 모티터 락(monitor lock)이라고도 부른다.
    - 객체 내부에 있고 우리가 확인하기는 어렵다.
- 스레드가 synchronized 키워드가 있는 메서드에 진입 하려면 반드시 해당 인스턴스의 락이 있어야 한다.
- 락이 없으면 스레드는 락을 획들할 때 까지 BLOCKED 상태로 대기한다.
    - RUNNABLE -> BLOCKED 상태로 변하고, 락을 획들할 때 까지 무한정 대기한다.
      BLOCKED 상태가 되면 락을 다시 획득하기 전까지는 계속 대기하고, CPU 실행 스케줄링에 들어가지 않는다.
- 락 획들을 대기하는 스레드는 인스턴스에 락이 반납되면 자동으로 락을 획득한다.
    - 이때 락을 획득한 스레드는 BLOCKED -> RUNNABLE 상태가 되고, 다시 코드를 실행한다.

자바의 synchronized 키워드를 사용하면 한 번에 하나의 스레드만 실행하는 안전한 임계 영역 구간을
편리하게 만들 수 있다.

※참고: 락을 획득하는 순서는 보장되지 않는다.★
어떤 순서로 락을 획득하는지는 자바 표준에 정의되어 있지 않다. 따라서 순서를 보장하지 않고,
환경에 따라서 순서가 달라질 수 있다.

※참고
volatile를 사용하지 않으도 synchronized 안에서 접근하는 변수의 메모리 가시성 문제는 해결된다.

<synchronized 코드 블럭>
synchronized의 가장 큰 장점이자 단점은 한 번에 하나의 스레드만 실행할 수 있다는 점이다.
여러 스레드가 동시에 실행하지 못하기 때문에, 전체로 보면 성능이 떨어질 수 있다. 따라서 synchronized를
통해 여러 스레드를 동시에 실행할 수 없는 코드 구간은 꼭 필요한 곳으로 한정해서 설정해야 한다.

메서드 앞에 적용한 synchronized의 적용 범위는 메서드 전체이다.
메서드 내에서 함께 실행해도 문제가 없는 부분도 한 번에 하나의 스레드만 실행할 수 있다.

자바는 이런 문제를 해결하기 위해 synchronized를 메서드 단위가 아니라, 특정 코드 블럭에 최적화 해서
적용할 수 있는 기능을 제공한다.

- 메서드 선언부의 synchronized를 사용하지 말고 synchronized (this) {} 사용
- synchronized (this) {}: 안전한 임계 영역을 코드 블럭으로 지정한다.
- 이렇게 하면 꼭 필요한 코드만 안전한 임계 영역으로 만들 수 있다.
- synchronized (this): 여기서 괄호 () 안에 들어가는 값은 락을 획득할 인스턴스의 참조이다.

synchronized 블럭 기능을 사용하면 필요한 부분에 임계 영역을 지정할 수 있다.
그로인해 스레드가 동시에 수행되는 부분을 더 늘려 전체적으로 성능을 향상 시킬 수 있다.

핵심은 하나의 스레드만 실행할 수 있는 안전한 임계 영역은 가능한 최소한의 범위에 적용해야 한다는 점이다.
그래야 동시에 여러 스레드가 실행할 수 있는 부분을 늘려서, 전체적인 처리 성능을 더 높일 수 있다.

== synchronized 동기화 정리 ==
자바에서 동기호(synchronized)는 여러 스레드가 동시에 접근할 수 있는 자원(예:객체, 메서드)에 대해
일관성 있고 안전한 접근을 보장하기 위한 메커니즘이다. 동기화는 주로 멀티스레드 환경에서 발생할 수 있는
문제, 예르르 들어 데이터 손상이나 예기치 않는 결과를 방지하기 위해 사용된다.

- 메서드 동기화: 메서드를 synchronized로 선언해서, 메서드에 접근하는 스레드가 하나뿐이도록 보장한다.
    public synchronized void synchronizedMethod() {}

- 블록 동기화: 코드 블록을 synchronized로 감싸서, 동기화를 구현할 수 있다.
public void method() {
    synchronized(this) {
        // 동기화된 코드
    }
}

이런 동기화를 사용하면 다음 문제들을 해결할 수 있다.
- 경함 조건(Race condition): 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제.
- 데이터 일관성: 여러 스레드가 동시에 읽고 쓰는 데이터의 일관성을 유지.

★동기화는 멀티스레드 환경에서 필수적인 기능이지만, 과도하게 사용할 경우 성능 저하를 초래할 수 있으므로
꼭 필요한 곳에 적절히 사용해야 한다.

※지역 변수의 공유★
- 스택 영역은 각각의 스레드가 가지는 별도의 메모리 공간이다. 이 메모리 공간은 다른 스레드와 공유하지 않는다.
- 지역 변수는 스레드의 개별 저장 공간인 스택 영역에 생성된다.
- 따라서 '지역 변수는 절대로! 다른 스레드와 공유되지 않는다.'
- 이런 이유로 지역 변수는 동기화에 대한 걱정을 하지 않아도 된다.
    - 여기에 synchronized를 사용하면 아무 이득도 얻을 수 없다. 성능만 느려진다.
- 지역 변수를 제외한, 인스턴스의 멤버 변수(필드), 클래스 변수 등은 공유될 수 있다.

※final 필드★
- 여러 스레드가 공유 자원에 접근하는 것 자체는 사실 문제가 되지 않는다.
- 진짜 문제는 공유 자원을 사용하는 중간에 다른 스레드가 공유 자원의 값을 변경해버리기 때문에 발생한다.
- 결국 '변경'이 문제가 되는 것이다.
- ★여러 스레드가 접근 가능한 공유 자원이라도 그 값을 아무도 변경할 수 없다면 문제 되지 않는다.
  이 경우 모든 스레드가 항상 같은 값을 읽기 때문이다.
- 필드에 final이 붙으면 어떤 스레드도 값을 변경할 수 없다. 따라서 멀티스레드 상황에 문제 없는
  안전하 공유 자원이 된다.

* 정리
자바는 처음부터 멀티스레드를 고려하고 나온 언어이다. 그래서 자바 1.0부터 synchronized 같은 동기화
방법을 프로그래밍 언어의 문법에 포함해서 제공한다.

== synchronized 장점 ==
- 프로그래밍 언어에 문법으로 제공
- 아주 편리한 사용
- 자동 잠금 해제: synchronized 메서드나 블록이 완료되면 자동으로 락을 대기중인 다른 스레드의 잠금이
                해제된다. 개발자가 직접 특정 스레드를 깨우도록 관리해야 한다면, 매우 어렵고 번거로울
                것이다.

synchronized는 매우 편리하지만, 제공하는 기능이 너무 단순하다는 단점이 있다. 시간이 점점 지나면서
멀티스레드가 더 중요해지고 점점 더 복잡한 동시성 개발 방법들이 필요해졌다.

== synchronized 단점 ==
- 무한 대기: BLOCKED 상태의 스레드는 락이 풀릴 때 까지 무한 대기한다.
    - 특정 시간까지만 대기하는 타임아웃X
    - 중간에 인터럽트X
- 공정성: 락이 돌아왔을 때 BLOCKED 상태의 여러 스레드 중에 어떤 스레드가 락을 획들할 지 알 수 없다.
         최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.

synchronized의 가장 치명적인 단점은 락을 얻기 위해 BLOCKED 상태가 되면 락을 얻을 때까지 무한 대기
한다는 점이다.

결국 더 유연하고, 더 세밀한 제어가 가능한 방법들이 필요하게 되었다. 이런 문제를 해결하기 위해
자바 1.5부터 java.util.concurrent 라는 동시성 문제 해결을 위한 패키지가 추가된다.

참고로 단순하고 편리하게 사용하에는 synchronized가 좋으므로, 목적에 부합하다면 synchronized를
사용하면 된다.


