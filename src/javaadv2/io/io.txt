[I/O]

<스트림 시작1>
자바가 가진 데이터를 외부 파일에 저장하려면
자바 프로세스가 가지고 있는 데이터를 밖으로 보내려면 출력 스트림을 사용하면 되고,
반대로 외부 데이터를 자바 프로세스 안으로 가져오려면 입력 스트림을 사용하면 된다.
각 스트림은 단방향으로 흐른다.

1) new FileOutputStream(경로)
    - 파일에 데이터를 출력하는 스트림이다.
    - 파일이 없으면 파일을 자동으로 만들고, 데이터를 해당 파일에 저장한다.
    - 폴더를 만들지는 않기 때문에 폴더는 미리 만들어두어야 한다.

- write(): byte 단위로 값을 출력한다.

2) new FileInputStream(경로)
    - 파일에서 데이터를 읽어오는 스트림이다.

- read()
    - 파일에서 데이터를 byte 단위로 하나씩 읽어온다.
    - 파일의 끝에 도달해서 더는 읽을 내용이 없다면 -1을 반환한다.
      파일의 끝 (EOF, End of File)

- close()
  파일에 접근하는 것은 자바 입장에서 외부 자원을 사용하는 것이다. 자바에서 내부 객체는 자동으로
  GC가 되지만 외부 자원은 사용 후 반드시 닫아주어야 한다.

※참고 - read()가 int를 반환하는 이유
1) 부호 없는 바이트 표현
    - 자바에서 byte는 부호 있는 8비트 값(-128 ~ 127)이다.
    - int로 반환함으로써 0 ~ 255까지의 모든 가능한 바이트 값을 부호 없이 표현할 수 있다.
2) EOF(End of File) 표시
    - byte를 표현하려면 256 종류의 값을 모두 사용해야 한다.
    - 자바의 byte는 -128 ~ 127 까지 256종류의 값만 가질 수 있어, EOF 를 위한 특별한 값을
      할당하기 어렵다.
    - int는 0 ~ 255까지 모든 가능한 바이트 값을 표현하고, 여기에 추가로 -1을 반환하여 스트림의 끝(EOF)을
      나타낼 수 있다.
- 참고로 write()의 경우도 비슷한 이유로 int 타입을 입력 받는다.

<스트림 시작2>
현대의 컴퓨터느느 대부분 byte 단위로 데이터를 주고 받는다. bit 단위는 너무 작기 때문에
byte 단위를 기본으로 사용한다.
이렇게 데이터를 주고 받는 것을 Input/Output(I/O)라 한다.

== InputStream, OutputStream ==
둘다 추상 클래스 이다.

추상 클래스이기 때문에 스트림을 파일을 사용하든, 소켓을 통해 네트워크를 사용하든 모두 일관된
방식으로 데이터를 주고 받을 수 있다. 그리고 수 많은 기본 구현 클래스들도 제공한다.
물론 각각의 구현 클래스들은 자신에게 맞는 추가 기능도 함께 제공한다.

== ByteArrayOutputStream, ByteArrayInputStream ==
메모리에 스트림을 쓰고 읽을 수 있다. 이 클래스들은 InputStream, OutputStream을 상속받았기
때문에 부모의 기능을 모두 사용할 수 있다.
참고로 메로리에 어떤 데이터를 저장하고 읽을 때는 컬렉션이나 배열을 사용하면 되기 때문에, 이 기능은
잘 사용하지 않는다. 주로 스트림을 간단하게 테스트 하거나 스트림의 데이터를 확인하는 용도로 사용한다.

== PrintStream ==
System.out이 PrintStream 이다. 이 스트림은 OutputStream을 상속받는다.
이 스트림은 자바가 시작될 때 자동으로 만들어진다. 따라서 직접 생성하지 않는다.
- write(): OutputStream 부모 클래스가 제공하는 기능이다.
- println(): PrintStream이 자체적으로 제공하는 추가 기능이다.

* 정리
InputStream과 OutputStream이 다양한 스트림들을 추상화하고 기본 기능에 대한 표준을 잡아둔 덕분에
개발자는 편리하게 입출력 작업을 수행할 수 있다. 이러한 추상화의 장점은 다음과 같다.

- 일관성: 모든 종류의 입출력 작업에 대해 동일한 인터페이스(부모의 메서드)를 사용할 수 있어, 코드의
         일관성이 유지된다.
- 유연성: 실제 데이터 소스나 목적지가 무엇인지에 관계없이 동일한 방식으로 코드를 작성할 수 있다.
         예를 들어, 파일, 네트워크, 메모리 등 다양한 소스에 대해 동일한 메서드를 사용할 수 있다.
- 확장성: 새로운 유형의 입출력 스트림을 쉽게 추가할 수 있다.
- 재사용성: 다양한 스트림 클래스들을 조합하여 복잡한 입출력 작업을 수행할 수 있다.
- 에러 처리: 표준화된 예외 처리 메커니즘을 통해 일관된 방식으로 오류를 처리할 수 있다.

※참고로 InputStream, OutputStream은 추상 클래스이다. 자바 1.0부터 제공되고, 일부 작동하는
코드도 들어있기 때문에 인터페이스가 아니라 추상 클래스로 제공된다.

<버퍼>
- write(), read()를 호출할 때마다 OS의 시스템 콜을 통해 파일을 읽거나 쓰는 명령어를 전달한다.
  이러한 시스템 콜은 상대적으로 무거운 작업이다.
- HDD, SSD 같은 장치들도 하나의 데이터를 읽고 쓸 때마다 필요한 시간이 있다. HDD의 경우 더욱 느린데,
  물리적으로 디스크의 회전이 필요하다.

비유를 하자면 창고에서 마트까지 상품을 전달해야 하는데, 화물차에 한 번에 하나의 물건만 가지고
이동하는 것이다.
이런 문제를 해결하려면 화물차에 더 많은 상품을 담아서 보내면 된다.

※참고
자바에서 운영 체제를 통해 디스크에 1byte씩 전달하면, 운영 체제나 하드웨어 레벨에서 여러가지 최적화가
발생한다. 따라서 실제로 디스크에 1byte씩 계속 쓰는 것은 아니다. 하지만 자바에서 1바이트씩 write()나 read()
를 호출할 때마다 운영 체제로의 시스템 콜이 발생하고, 이 시스템 콜 자체가 상당한 오버헤드를 유발한다.
운영 체제와 하드웨어가 어느 정도 최적화를 제공하더라도, 자주 발생하는 시스템 콜로 인한 성능 저하는
피랗 수 없다. 결국 자바에서 read(), write() 호출 횟수를 줄여서 시스템 콜 횟수도 줄여야 한다.

== 버퍼 ==
데이터를 모아서 전달하거나 모아서 전달받는 용도로 사용하는 것을 버퍼라 한다.

== 버퍼의 크기에 따른 쓰기 성능 ==
버퍼의 크기가 커진다고 해서 속도가 계속 줄어들지는 않는다.
왜냐하면 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 보통 4KB 또는 8KB 이기 때문이다.
결국 버퍼에 많은 데이터를 담아서 보내도 디스크나 파일 시스템에서 해당 단위로 나누어 저장하기 때문에
효율에는 한계가 있다.
따라서 버퍼의 크기는 보통 4KB 또는 8KB 정도로 잡는 것이 효율적이다.

== BufferedOutputStream, BufferedInputStream ==
BufferedOutputStream, BufferedInputStream은 버퍼 기능을 내부에서 대신 처리해준다.
따라서 단순한 코드를 유지하면서 버퍼를 사용하는 이점도 함께 누릴 수 있다.

1) BufferedOutputStream
    - 내부에서 단순히 버퍼 기능만 제공한다. 따라서 반드시 대상 OutputStream이 있어야 한다.
    - 사용할 버퍼의 크기도 함께 전달할 수 있다.

BufferedOutputStream은 OutputStream을 상속받는다. 따라서 개발자 입장에서 보면 OutputStream과
같은 기능을 그대로 사용할 수 있다.

- write(): 내부 버퍼에 데이터를 사이즈 마큼 채우고 버퍼가 다 채워지면 버퍼의 내용을 전달하고
           버퍼를 비운다. 이후 write()가 호출되면 다시 버퍼를 채우는 방식으로 반복한다.
- flush(): 버퍼가 다 차지 않아도 버퍼에 남아있는 데이터를 전달하려면 flush()라는 메서드를 호출하면 된다.
- close(): 버퍼에 데이터가 남아있는 상태로 close()를 호출하면 먼저 내부에서 flush()를 호출한다.
           따라서 버퍼에 남아있는 데이터를 모두 전달하고 비운다.
           즉, close()를 호출해도 남은 데이터를 안전하게 저장할 수 있다.
           버퍼가 비워지고 나면 BufferedOutputStream의 자원을 정리한다.
           그리고 나서 다음 연결된 스트림의 close()를 호출한다.
           핵심은 close()를 호출하면 close()가 연쇄적으로 호출된다는 점이다.
           따라서 마지막에 연결한 BufferedOutputStream만 닫아주면 된다.

※주의 - 반드시 마지막에 연결한 스트림을 닫아야 한다.
- 만약 BufferedOutputStream을 닫지않고, FileOutputStream만 직접 닫으면?
- 이 경우 BufferedOutputStream의 flush()도 호출되지 않고, 자원도 정리되지 않는다.
  따라서 남은 byte가 버퍼에 남아있게 되고, 파일에 저장되지 않는 심각한 문제가 발생한다.
- 따라서 스트림을 연결해서 사용하는 경우에는 마지막에 연결한 스트림을 반드시 닫아주어야 한다.
  마지막에 연결한 스트림만 닫아주면 연쇄적으로 close()가 호출된다.

== 기본 스트림, 보조 스트림 ==
- FileOutputStream과 같이 단독으로 사용할 수 있는 스트림을 기본 스트림이라 한다.
- BufferedOutputStream과 같이 단독으로 사용할 수 없고, 보조 기능을 제공하는 스트림을
  보조 스트림이라 한다.

BufferedOutputStream은 FileOutputStream에 버퍼라는 보조 기능을 제공한다.
BufferedOutputStream의 생성자를 보면 반드시 FileOutputStream 같은 대상 OutputStream이 있어야 한다.
BufferedOutputStream은 버퍼라는 보조 기능을 제공한다. 그렇다면 누구에게 보조 기능을 제공할지
대상을 반드시 전달해야 한다.

* 정리
- BufferedOutputStream은 버퍼 기능을 제공하는 보조 스트림이다.
- BufferedOutputStream도 OutputStream의 자식이기 때문에 OutputStream의 기능을 그대로
  사용할 수 있다.
  물론 대부분의 기능은 재정의 된다. write()의 경우 먼저 버퍼에 쌓도록 재정의 된다.
- 버퍼의 크기만큼 데이터를 모아서 전달하기 때문에 빠른 속도로 데이터를 처리할 수 있다.

2) BufferedInputStream
BufferedInputStream은 InputStream을 상속받는다. 따라서 개발자 입장에서 보면 InputStream과
같은 기능을 그대로 사용할 수 있다.

BufferedInputStream은 버퍼의 크기만큼 데이터를 미리 읽어서 버퍼에 보관해둔다.
따라서 read()를 통해 1byte씩 데이터를 조회해도, 성능이 최적화 된다.

== 버퍼를 직접 다루는 것 보다 BufferedXxx의 성능이 떨어지는 이유 ==
- BufferedXxx 클래스는 모두 동기화 처리가 되어 있다.

특징
BufferedXxx 클래스는 자바 초창기에 만들어진 클래스인데, 처음부터 멀티 스레드를 고려해서 만든
클래스이다. 따라서 멀티 스레드에 안전하지만 락을 걸고 푸는 동기화 코드로 인해 성능이 약간 저하될 수 있다.
하지만 싱글 스레드 상황에서는 동기화 락이 필요하지 않기 때문에 직접 버퍼를 다룰 때와 비교해서
성능이 떨어진다.

일반적인 상황이라면 이 정도 성능은 크게 문제가 되지는 않기 때문에 싱글 스레드여도 BufferedXxx를
사용하면 충분하다.
물론 매우 큰 데이터를 다루어야 하고, 성능 최적화가 중요하다면 직접 버퍼를 다루는 방법을 고려하자.
아쉽게도 동기화 락이 없는 BufferedXxx 클래스는 없다. 꼭 필요한 상황이라면 BufferedXxx를 참고해서
동기화 락 코드를 제거한 클래스를 직접 만들어 사용하면된다.

== 한 번에 읽기, 쓰기 ==
파일의 크기가 크지 않다면 간단하게 한 번에 쓰고 읽는 것도 좋은 방법이다.
이 방법은 성능은 가장 빠르지만, 결과적으로 메모리를 한 번에 많이 사용하기 때문에 파일의 크기가
작아야 한다.

- 파일의 크기가 크지 않아서, 메모리 사용에 큰 영향을 주지 않는다면 쉽고 빠르게 한 번에 처리하자.
- 성능이 중요하고 큰 파일을 나누어 처리해야 한다면, 버퍼를 직접 다루자
- 성능이 크게 중요하지 않고, 버퍼 기능이 필요하면 BufferedXxx를 사용하자.
  BufferedXxx는 동기화 코드가 들어있어서 스레드 안전하지만, 약간의 성능 저하가 있다.

<문자 다루기>
스트림의 모든 데이터는 byte 단위를 사용한다. 따라서 byte가 아닌 문자를 스트림에 직접 전달할 수는 없다.
예를 들어서 String 문자를 스트림을 통해 파일에 저장하려면 String을 byte로 변환한 다음에
저장해야 한다.

- byte[] writeBytes = writeString.getBytes(UTF_8)
    - String을 byte로 변환할 때는 String.getBytes(Charset)을 사용하면 된다.
    - 이때 문자를 byte 숫자로 변경해야 하기 때문에 반드시 문자 집합(인코딩 셋)을 지정해야 한다.

- String readString = new String(readBytes, UTF_8)
    - 반대의 경우도 비슷하다. String 객체를 생성할 때, 읽어들인 byte[]과 디코딩할 문자 집합을
      전달하면 된다.
    - 그러면 byte[]를 String 문자로 다시 복원할 수 있다.

핵심은 스트림은 byte만 사용할 수 있으므로, String과 같은 문자는 직접 전달할 수 없다는 점이다.
직접 변환 과정
- String + 문자 집합 -> byte[]
- byte[] + 문자 집합 -> String

<스트림을 문자로>
- OutputStreamWriter: 스트림에 byte 대신에 문자를 저장할 수 있게 지원한다.
- InputStreamReader: 스트림에 byte 대신에 문자를 읽을 수 있게 지원한다.

1) OutputStreamWriter
- OutputStreamWriter는 문자를 입력 받고, 받은 문자를 인코딩해서 byte[]로 변환한다.
- OutputStreamWriter는 변환한 byte[]을 전달할 OutputStream과 인코딩 문자 집합에 대한
  정보가 필요하다. 따라서 두 정보를 생성자를 통해 전달해야 한다.
  (new OutputStreamWriter(fos, UTF_8))
- osw.write(writeString)를 보면 String 문자를 직접 전달하는 것을 확인할 수 있다.
- OutputStreamWriter가 문자 인코딩을 통해 byte[]로 변환하고, 변환 결과를 OutputStream에
  전달한다.

2) InputStreamReader
- 데이터를 읽을 때는 int ch = read()를 제공하는데, 여기서는 문자 하나인 char 형으로 데이터를
  받게 된다. 그런데 실제 반환 타입은 int 형이므로 char 형으로 캐스팅해서 사용하면 된다.
- 자바의 char 형은 파일의 끝인 -1을 표현할 수 없으므로 대신 int를 반환한다.
- InputStream 에서 byte[]을 읽은 것고 InputStreamReader는 이렇게 읽은 byte[]을 문자인
  char로 변경해서 반환한다. 물론 byte를 문자로 변경할 때도 문자 집합이 필요하다.
  (new InputStreamReader(fis, UTF_8))

OutputStreamWriter, InputStreamReader 덕분에 매우 편리하게 문자를 byte[]로 변경하고,
byte[]를 문자로 변경하는 것도 가능하다. 덕분에 개발자는 쉽게 String 문자를 파일에 저장할 수 있다.

<Reader, Writer>
자바는 byte를 다루는 I/O 클래스와 문자를 다루는 I/O 클래스를 둘로 나누어두었다.

- byte를 다루는 클래스는 OutputStream, InputStream의 자식이다.
    - 부모 클래스의 기본 기능도 byte 단위를 다룬다.
    - 클래스 이름 마지막에 보통 OutputStream, InputStream이 붙어있다.

- 문자를 다루는 클래스는 Writer, Reader의 자식이다.
    - 부모 클래스의 기본 기능은 String, char 같은 문자를 다룬다.
    - 클래스 이름 마지막에 보통 Writer, Reader가 붙어있다.

OutputStreamWriter는 문자를 다루는 Writer 클래스의 자식이다. 그래서 write(String)이
가능한 것이다. OutputStreamWriter는 문자를 받아서 byte로 변경한 다음에 byte를 다루는
OutputStream 으로 데이터를 전달한다.

★꼭 기억해아할 중요한 사실
모든 데이터는 byte 단위(숫자)로 저장된다. 따라서 Writer가 아무리 문자를 다룬다고 해도
문자를 바로 저장할 수는 없다. 이 클래스에 문자를 전달하면 결과적으로 내부에서는 지정된 문자
집합을 사용해서 문자를 byte로 인코딩해서 저장한다.

1) new FileWriter(파일명, 문자셋)
- FileWriter에 파일명과, 문자 집합(인코딩 셋)을 전달한다.
- FileWriter는 내부에서 스스로 FileOutputStream을 하나 생성해서 사용한다.
- 모든 데이터는 byte 단위로 저장된다.

- write(String)
    - 이 메서드를 사용하면 문자를 파일에 직접 쓸 수 있다. (실제 그런것은 아님)
    - FileWriter는 내부에서 인코딩 셋을 사용해 문자를 byte로 변경하고, FileOutputStream을
      사용해서 파일에 저장한다.
    - 개발자가 느끼기에는 문자를 직접 파일에 쓰는 것 처럼 느껴지지만, 실제로는 내부에서 문자를
      byte로 변환한다.

2) new FileReader(파일명, 문자셋)
- FileWriter와 같은 방식으로 작동한다.
- 내부에서 FileInputStream를 생성해서 사용한다.

ch = fr.read()
    - 데이터를 읽을 때도 내부에서는 FileInputStream을 사용해서 데이터를 byte 단위로 읽어들인다.
      그리고 문자 집합을 사용해서 byte[]을 char로 디코딩한다.

== FileWriter와 OutputStreamWriter ==
FileWriter와 OutputStreamWriter의 차이점이 있다면 OutputStreamWriter은 FileOutputStream을
생성해 전달하고, FileWriter는 생성자 내부에서 대신 FileOutputStream을 생성해준다.
FileWriter는 OutputStreamWriter을 상속한다. 그리고 다른 추가 기능도 없다.
딱 하나, 생성자에서 개발자 대신 FileOutputStream을 생성해주는 일만 대신 처리해준다.
따라서 FileWriter는 OutputStreamWriter를 조금 편리하게 사용하도록 도와줄 뿐이다.
물론 FileReader도 마찬가지다.

* 정리★
Writer, Reader 클래스를 사용하면 바이트 변환 없이 문자를 직접 다룰 수 있어서 편리하다.
하지만 실제로는 내부에서 byte로 변환해서 저장한다는 점을 꼭 기억하자. 모든 데이터는 바이트 단위로
다룬다! 문자를 직접 저장할 수는 없다!
그리고 반드시 기억하자, 문자를 byte로 변경하려면 항상 문자 집합(인코딩 셋)이 필요하다!

※참고: 문자 집합을 생략하면 시스템 기본 문자 집합이 사용된다.

<버퍼 Reader, Writer>
BufferedOutputStream, BufferedInputStream과 같이 Reader, Writer 에도 버퍼 보조 기능을
제공하는 BufferedReader, BufferedWriter 클래스가 있다.

참고로 문자를 다룰 때는 한 줄(라인) 단위로 다룰 때가 많다.
BufferedReader는 한 줄 단위로 문자를 읽는 기능도 추가로 제공한다.

br.readLine()
- 한 줄 단위로 문자를 읽고 String을 반환한다.
- 파일의 끝(EOF)에 도달하면 null을 반환한다.
    - 반환 타입이 String 이기 때문에 EOF 를 -1로 표현할 수 없다. 대신에 null을 반환한다.

<기타 스트림>
지금까지 스트림 외에 수 많은 스트림이 있다.
몇가지 유용한 부가 기능을 제공하는 PrintStream, DataOutputStream 보조 스트림을 알아본다.

== PrintStream ==
PrintStream은 자주 사용해왔던 System.out 에서 사용되는 스트림이다.
PrintStream과 FileOutputStream을 조합하면 마치 콘솔에 출력하듯이 파일에 출력할 수 있다.
파일 말고 다른 스트림을 사용하면 콘솔에 출력하는 것처럼(println 같은) 다른 스트림에
문자를 출력할 수 있다.

== DataOutputStream ==
DataOutputStream을 사용하면 자바의 String, int, double, boolean 같은 데이터 형을
편리하게 다룰 수 있다.
이 스트림과 FileOutputStream을 조합하면 파일에 자바 데이터 형을 편리하게 저장할 수 있다.

이 스트림을 사용할 때 주의할 점은 꼭 저장한 순서대로 읽어야 한다는 것이다.
그렇지 않으면 잘못된 데이터가 조회될 수 있다.

* 정리
- 기본(기반, 메인) 스트림
    - File, 메모리, 콘솔등에 직접 접근하는 스트림
    - 단독으로 사용할 수 있음
    예: FileInputStream, FileOutputStream, FileReader, FileWriter,
        ByteArrayInputStream, ByteArrayOutputStream

- 보조 스트림
    - 기본 스트림을 도와주는 스트림
    - 단독으로 사용할 수 없음, 반드시 대상 스트림이 있어야함
    예: BufferedInputStream, BufferedOutputStream,
        InputStreamReader, OutputStreamWriter,
        DataInputStream, PrintStream

<ObjectStream>
== 객체 직렬화 ==
자바 객체 직렬화(Serialization)는 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환하여 파일에
저장하거나 네트워크를 통해 전송할 수 있도록 하는 기능이다. 이 과정에서 객체의 상태를 유지하여 나중에
역직렬화(Deserialization)를 통해 원래의 객체로 복원할 수 있다.

객체 직렬화를 사용하려면 직렬화하려는 클래스는 반드시 Serializable 인터페이스를 구현해야 한다.

Serializable 인터페이스에는 아무런 기능이 없다. 단지 직렬화 가능한 클래스라는 것을 표시하기 위한
인터페이스일 뿐이다.

※참고: 메서드 없이 단지 표시가 목적인 인터페이스를 마커 인터페이스라 한다.

객체 직렬화를 사용하면 객체를 바이트로 변환할 수 있어, 모든 종류의 스트림에 전달할 수 있다.
이는 파일에 저장하는 것은 물론, 네트워크를 통해 객체를 전송하는 것도 가능하게 한다. 이러한 특성 때문에
초기에는 분산 시스템에서 활용되었다.
그러나 객체 직렬화는 1990년대 등장한 기술로, 초창기에는 인기가 있었지만 시간이 지나면서 여러 단점이
드러났다. 또한 대안 기술이 등장하면서 점점 사용이 줄어들게 되었다.
현재는 객체 직렬화를 거의 사용하지 않는다.

참고로 객체 직렬화 관련해서 다음과 같이 더 학습할 내용들이 있다. 하지만 현대에는 객체 직렬화를
잘 사용하지 않으므로 이런 것이 있다는 것 정도만 알아두고 넘어가자
- serialVersionUID: 객체 직렬화 버전을 관리한다.
- transient 키워드: transient가 붙어있는 필드는 직렬화 하지 않고 무시한다.

== 객체 직렬화 한계 ==
1) 버전 관리의 어려움
    - 클래스 구조가 변경되면 이전에 직렬화된 객체와의 호환성 문제가 발생한다.
    - serialVersionUID 관리가 복잡하다.
2) 플랫폼 종속성
    - 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과의 상호 운용성이 떨어진다.
3) 성능 이슈
    - 직렬화/역직렬화 과정이 상대적으로 느리고 리소스를 많이 사용한다.
4) 유연성 부족
    - 직렬화된 형식을 커스터마이즈하기 어렵다.
5) 크기 효율성
    - 직렬화된 데이터의 크기가 상대적으로 크다.

== 객체 직렬화의 대안 ==
1) XML
플랫폼 종속성 문제를 해결하기 위해 2000년대 초반에 XML 이라는 기술이 인기를 끌었다.
하지만 XML은 매우 유연하고 강력했지만, 복잡성과 무거움이라는 문제가 있었다. 태그를 포함한
XML 문서의 크기가 커서 네트워크 전송 비용도 증가했다.

2) JSON
JSON은 가볍고 간결하며, 자바스크립트와의 자연스러운 호환성 덕분에 웹 개발자들 사이에서 빠르게 확산되었다.
2000년대 후반, 웹 API와 RESTful 서비스가 대중화되면서 JSON은 표준 데이터 교환 포맷으로 자리 잡았다.

XML은 데이터 구조의 복잡성과 엄격한 스키마 정의가 필요한 초기 웹 서비스와 엔터프라이즈 환경에서 중요한
역할을 했지만, 시간이 지나면서 JSON과 같은 가볍고 효율적인 데이터 형식이 더 많이 채택되었다.
JSON은 웹과 모바일 애플리케이션의 발전과 함께 급속히 인기를 얻었으며, 현재는 대부분의 데이터 교환에서
기본적인 포맷으로 사용되고 있다. XML은 특정 영역에서 여전히 사용되지만, JSON이 현대 소프트웨어 개발의
주류로 자리 잡았다.

★지금은 웹 환경에서 데이터를 교환할 때 JSON이 사실상 표준 기술이다.

3) Protobuf, Avro - 더 작은 용량, 더 빠른 성능
- JSON은 거의 모든 곳에서 호환이 가능하고, 사람이 읽고 쓰기 쉬운 텍스트 기반 포맷이어서 디버깅과
  개발이 쉽다.
- 만약 매우 작은 용량으로 더 빠른 속도가 필요하다면 Protobuf, Avro 같은 대안 기술이 있다.
- 이런 기술은 호환성은 떨어지지만 byte 기반에, 용량과 성능 최적화가 되어 있으므로 매우 빠르다.
- 다만 byte 기반이므로 JSON 처럼 사람이 직접 읽기는 어렵다.

* 정리
- 자바 객체 직렬화는 대부분 사용하지 않는다.
- JSON이 사실상 표준이다. JSON을 먼저 고려하자
- 성능 최적화가 매우 중요하다면 Protobuf, Avro 같은 기술을 고려하자.(대부분 JSON만 사용해도 충분하다)





