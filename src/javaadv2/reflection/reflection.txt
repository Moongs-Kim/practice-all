[리플렉션]

<클래스와 메타데이터>
클래스가 제공하는 다양한 정보를 동적으로 분석하고 사용하는 기능을 리플렉션(Reflection)이라 한다.
리플렉션을 통해 프로그램 실행 중에 클래스, 메서드, 필드 등에 대한 정보를 얻거나, 새로운 객체를 생성하고
메서드를 호출하며, 필드의 값을 읽고 쓸 수 있다.

- 리플렉션을 통해 얻을 수 있는 정보
1) 클래스의 메타데이터: 클래스 이름, 접근 제어자, 부모 클래스, 구현된 인터페이스 등
2) 필드 정보: 필드의 이름, 타입, 접근 제어자를 확인하고, 해당 필드의 값을 읽거나 수정할 수 있다.
3) 메서드 정보: 메서드 이름, 반환 타입, 매개변수 정보를 확인하고,
              실행 중에 동적으로 메서드를 호출할 수 있다.
4) 생성자 정보: 생성자의 매개변수 타입과 개수를 확인하고, 동적으로 객체를 생성할 수 있다.

※참고 - 리플렉션 용어
'리플렉션(Reflection)' 이라는 용어는 영어 단어 'reflect' 에서 유래된 것으로, '반사하다' 또는 '되돌아보다'
라는 의미를 가지고 있다. 리플렉션은 프로그램이 실행 중에 자신의 구조를 들여다보고, 그 구조를 변경하거나 조작할
수 있는 기능을 의미한다.
쉽게 말해, 리플렉션을 통해 클래스, 메서드, 필드 등의 메타데이터를 런타임에 동적으로 조사하고 사용할 수 있다.
이는 마치 거울에 비친 자신을 보는 것과 같이, 프로그램이 자기 자신의 내부를 반사(reflect)하여 들여다본다는 의미이다.

<Class 클래스>
클래스의 메타데이터는 Class 라는 클래스로 표현한다.

== Class 라는 클래스를 획득하는 3가지 방법 ==
1. 클래스에서 찾기
   Class<BasicData> basicDataClass1 = BasicData.class;

   클래스명에 .class를 사용하면 획득할 수 있다.

2. 인스턴스에서 찾기
   BasicData basicInstance = new BasicData();
   Class<? extends BasicData> basicDataClass2 = basicInstance.getClass();

   인스턴스에서 .getClass() 메서드를 호출하면 획득할 수 있다.
   반환 타입을 보면 Class<? extends BasicData>로 표현되는데, 실제 인스턴스가 BasicData 타입일
   수도 있지만, 그 자식 타입일 수도 있기 때문이다.

3. 문자로 찾기
   String className = "javaadv2.reflection.data.BasicData";
   Class<?> basicDataClass3 = Class.forName(className);

   단순히 문자로 클래스의 메타데이터를 조회할 수 있다.
   예를 들어 콘솔에서 사용자 입력으로 원하는 클래스를 동적으로 찾을 수 있다는 뜻이다.

== Class 클래스 메타정보로 할 수 있는 것 ==
클래스 이름, 패키지, 부모 클래스, 구현한 인터페이스, 수정자 정보등 다양한 정보를 획득할 수 있다.

참고로 수정자는 접근 제어자와 비 접근 제어자(기타 수정자)로 나눌 수 있다.
- 접근 제어자: public, protected, default (package-private), private
- 비 접근 제어자: static, final, abstract, synchronized, volatile 등

getModifiers()를 통해 수정자가 조합된 숫자를 얻고, Modifier를 사용해서 실제 수정자 정보를 확인할 수 있다.

<메서드 탐색과 동적 호출>
클래스 메타데이터를 통해 클래스가 제공하는 메서드의 정보 확인 가능

Class.getMethods() 또는  Class.getDeclaredMethods() 를 호출하면 Method 라는 메서드의
메타데이터를 얻을 수 있다. 이 클래스는 메서드의 모든 정보를 가지고 있다.

== getMethods() vs getDeclaredMethods() ==
- getMethods(): 해당 클래스와 상위 클래스에서 상속된 모든 public 메서드를 반환
- getDeclaredMethods(): 해당 클래스에서 선언된 모든 메서드를 반환하며, 접근 제어자에 관계없이 반환.
                        상속된 메서드는 포함하지 않음

== 동적 메서드 호출 ==
Method 객체를 사용해서 메서드를 직접 호출할 수도 있다.

1. 일반적인 메서드 호출 - 정적
인스턴스의 참조를 통해 메서드를 호출하는 방식이 일반적인 메서드 호출 방식이다.
이 방식은 코드를 변경하지 않는 이상 다른 메서드로 변경하는 것이 불가능하다.
호출하는 메서드가 이미 코드로 작성되어서(정적) 변경할 수 없는 상태이다.

2. 동적 메서드 호출(리플렉션 사용)
리플렉션을 사용하면 동적으로 메서드를 호출할 수 있다.
String methodName = "hello";
Method method1 = helloClass.getMethod(methodName, String.class)

- 클래스 메타데이터가 제공하는 getMethod()에 메서드 이름, 사용하는 매개변수의 타입을 전달하면 원하는
  메서드를 찾을 수 있다.
- 여기서 hello 라는 이름에 String 매개변수가 있는 hello(String) 메서드를 찾는다.

Object returnValue = method1.invoke(helloInstance, "hi");
- Method.invoke() 메서드에 실행할 인스턴스와 인자를 전달하면, 해당 인스턴스에 있는 메서드를 실행할 수 있다.
- 여기서 BasicData helloInstance = new BasicData() 인스턴스에 있는 hello(String) 메서드를 호출한다.

★여기서 메서드를 찾을 때 helloClass.getMethod(methodName, String.class) 에서 methodName 부분이
string 변수로 되어 있다. 따라서 사용자 콘솔 입력을 통해서 얼마든지 호출할 값을 변경할 수 있다.
즉, 호출할 메서드 대상은 정적으로 딱 코드에 정해진 것이 아니라, 언제든지 동적으로 변경할 수 있다.
그래서 동적 메서드 호출이라 한다.

<필드 탐색과 값 변경>
리플렉션을 활용해서 필드를 탐색하고 또 필드의 값을 변경할 수 있다.

== fields() vs declaredFields() ==
메서드에와 같다
- fields(): 해당 클래스와 상위 클래스에서 상속된 모든 public 필드를 반환
- declaredFields(): 해당 클래스에서 선언된 모든 필드를 반환, 접근 제어자에 관계없이 반환.
                    상속된 필드는 포함하지 않음

== 필드 값 변경 ==
Field nameField = aClass.getDeclaredField("name")
- name 이라는 필드를 조회한다.
- 그런데 name 필드는 private 접근 제어자를 사용한다. 따라서 직접 접근해서 값을 변경하는 것이
  불가능하다.

nameField.setAccessible(true)
- 리플렉션은 private 필드에 접근할 수 있는 특별한 기능을 제공한다.
- 참고로 setAccessible(true) 기능은 Method도 제공한다. 따라서 private 메서드를 호출할 수도 있다.

 nameField.set(user, "userB")
 - user 인스턴스에 있는 private name 필드의 값을 userB로 변경한다.

리플렉션을 활용하면 기존 코드로 해결하기 어려운 공통 문제를 손쉽게 처리할 수도 있다.

<생성자 탐색과 객체 생성>
리플렉션을 활용하면 생성자를 탐색하고, 또 탐색한 생성자를 사용해서 객체를 생성할 수 있다.

getDeclaredConstructor(String.class)
- 여기서는 매개변수로 String을 사용하는 생성자를 조회한다.

constructor.setAccessible(true)
- private 생성자를 접근 가능하게 만든다.

 Object instance = constructor.newInstance("hello")
 - 찾은 생성자를 사용해서 객체를 생성한다. 여기서는 "hello"라는 인자를 넘겨준다.






