[람다]

<람다가 필요한 이유>
★프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 핵심은
변하는 부분과 변하지 않는 부분을 분리하는 것이다.

- 변하는 부분과 변하지 않는 부분을 분리
  변하지 않는 부분은 그대로 유지,
  변하는 부분을 외부에서 전달 받아 해결(ex.매개변수)

★변하는 부분을 외부에서 전달 받으면, 메서드(함수)의 재사용성을 높일 수 있다.
핵심은 변하는 부분을 메서드 내부에서 가지고 있는 것이 아니라,
외부에서 전달 받는다는 점이다.

1) 값 매개변수화(Value Parameterization)
- 문자값, 숫자값처럼 구체적인 값을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해
  외부에서 전달 받도록 해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법
- 값 매개변수화, 값 파라미터화 등으로 부른다.

==  코드 조각 메서드에 전달 ==
코드 조각은 보통 메서드(함수)에 정의한다. 따라서 코드 조각을 전달하기 위해서는 메서드가 필요하다.
하지만 메서드만 전달할 수 있는 방법은 지금까지 학습한 내용으로는 할 수 있는 방법이 없다.
대신 인스턴스를 전달하고, 인스턴스에 있는 메서드를 호출하면 된다.

※코드 조각을 메서드에 전달할 때는 인스턴스를 전달하고, 해당 인스턴스에 있는 메서드를 호출하면 된다.

2) 동작 매개변수화(Behavior Parameterization)
- 코드 조각(코드의 동작 방법, 로직, Behavior)을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를
  통해서 외부에서 전달 받도록 해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법을 동작 매개변수화라 한다.
- 동작 매개변수화, 동작 파라미터화, 행동 매개변수화(파라미터화), 행위 파라미터화 등으로 부른다.

* 정리
- 값 매개변수화: 값(숫자, 문자열 등)을 바꿔가며 세머드(함수)의 동작을 달리함
- 동작 매개변수화: 어떤 동작(로직)을 수행할지를 메서드(함수)에 전달(인스턴스 참조, 람다 등)

<함수 vs 메서드>
함수(Function)와 메서드(Method)는 둘 다 어떤 작업(로직)을 수행하는 코드의 묶음이다.

1) 객체(클래스)와의 관계
* 함수(Function)
    - 독립적으로 존재하며, 클래스(객체)와 직접적인 연관이 없다.
    - 객체지향 언어가 아닌 C 등의 절차적 언어에서는 모든 로직이 함수 단위로 구성된다.
    - 객체지향 언어라 하더라도, 예를 들어 Python 이나 JavaScript 처럼 클래스 밖에서도 정의할 수 있는
      함수 개념을 지원하는 경우, 이를 그냥 함수라고 부른다.
* 메서드(Method)
    - 클래스(또는 객체)에 속해 있는 함수이다.
    - 객체의 상태(필드, 프로퍼티 등)에 직접 접근하거나, 객체가 제공해야 할 기능을 구현할 수 있다.
    - Java, C++, C#, Python 등 대부분의 객체지향 언어에서 클래스 내부에 정의된 함수는 보통 메서드라고 부른다.

2) 호출 방식과 스코프
* 함수(Function)
    - 호출 시에 객체 인스턴스가 필요 없다.
    - 보통 '이름(매개변수)' 형태로 호출된다.
    - 지역 변수, 전역 변수 등과 함께 동작하며, 클래스나 객체 특유의 속성(인스턴스 변수 등)은 다루지 못한다.

* 메서드(Method)
    - 보통 '객체(인스턴스).메서드이름(매개변수)' 형태로 호출한다.
    - 호출될 때, 해당 객체의 필드(속성)나 다른 메서드에 접근 가능하며, 이를 이용해 로직을 수행한다.
    - 인스턴스 메서드, 클래스(정적) 메서드, 추상 메서드 등 다양한 형태가 있을 수 있다.

* 정리
- 메서드는 기본적으로 클래스(객체) 내부의 함수를 가리키며, 객체의 상태와 밀접한 관련이 있다.
- 함수는 클래스(객체)와 상관없이, 독립적으로 호출 가능한 로직의 단위이다.
- 메서드는 객체지향에서 클래스 안에 정의하는 특별한 함수라고 생각하면 된다.

함수와 메서드는 수행하는 역할 자체는 같지만, 소속(클래스 or 독립)과 호출 방식에서 차이가 난다고 이해하면 된다.

<람다 시작>
- 람다는 () -> {} 와 같이 표현한다. () 부분이 메서드의 매개변수라 생각하면 되고,
  {} 부분이 코드 조각이 들어가는 본문이다.
- 람다를 사용할 때는 이름, 반환 타입은 생략하고, 매개변수와 본문만 간단하게 적으면 된다.
  (매개변수) -> { 본문 }
- 쉽게 말해 익명 클래스를 만들기 위한 모든 부분을 생략하고, 꼭 필요한 매개변수와 본문만 작성하면 된다.
- 익명 클래스를 사용하는 것 보다 람다를 사용할 때 코드가 훨씬 간결하다.

<람다 정의>
- 자바 8부터 도입된 람다는 자바에서 함수형 프로그래밍을 지원하기 위한 핵심 기능이다.
- 람다는 익명 함수이다. 따라서 이름 없이 함수를 표현한다.

== 메서드나 함수 표현 ==
반환타입 메서드명(매개변수) { 본문 }
public int add(int x) { return x + 1; }

== 람다 ==
(매개변수) -> { 본문 }
(int x) -> {return x + 1;}
람다는 익명함수라 이름이 없다.

- 자바는 독립적인 함수를 지원하지 않으며, 메서드는 반드시 클래스나 인터페이스에 속한다.

※용어 - 람다 vs 람다식(Lambda Expression)
- 람다: 익명 함수를 지칭하는 일반적인 용어다. 쉽게 말해 개념이다.
- 람다식: (매개변수) -> { 본문 } 형태로 람다를 구현하는 구체적인 문법 표현을 지칭한다.

즉, 람다는 개념을, 람다식은 자바에서 그 개념을 구현하는 구체적인 문법을 의한다.
람다가 넓은 의미이고, 또 실무에서 두 용어를 구분해서 사용하지는 않는다.

== 람다의 특징 ==
1) 람다는 표현이 간결하다
   익명 클래스를 사용하면 new 키워드, 생성할 클래스명, 메서드명, 반환 타입 등을 모두 나열해야 한다.
   람다를 사용하면 이런 부분을 모두 생략하고, 매개변수와 본문만 적으면 된다.
2) 람다는 변수처럼 다룰 수 있다.
   변수에 람다를 담고 람다를 실행할 수 있다.

== 람다도 익명 클래스처럼 클래스가 만들어지고, 인스턴스가 생성된다. ==
- 익명 클래스의 경우 $로 구분하고 뒤에 숫자가 붙는다.
- 람다의 경우 $$로 구분하고 뒤에 복잡한 문자가 붙는다.

* 정리
- 람다를 사용하면 익명 클래스 사용의 보일러플레이트 코드를 크게 줄이고, 간결한 코드로 생상성과
  가독성을 높일 수 있다.
- 대부분의 익명 클래스는 람다로 대체할 수 있다.
  람다가 익명 클래스를 완전히 대체할 수 있는 것은 아니다.
- 람다를 사용할 때 new 키워드를 사용하지 않지만, 람다도 익명 클래스처럼 인스턴스가 생성된다.

<함수형 인터페이스>
- 함수형 인터페이스는 정확히 하나의 추상 메서드를 가지는 인터페이스를 말한다.
- 람다는 추상 메서드가 하나인 함수형 인터페이스에만 할당할 수 있다.
- 단일 추상 메서드를 줄여서 SAM(Single Abstract Method)이라 한다.
- 참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만
  할당할 수 있다.

== 함수형 인터페이스에만 람다를 할당할 수 있는 이유 ==
- 람다는 하나의 함수이다. 따라서 람다를 인터페이스에 담으려면 하나의 메서드(함수) 선언만 존재해야 한다.
- 여러 메서드가 선언된 인터페이스에 람다를 할당할때 어느 메서드에 할당해야 하는지 모르는 문제가 발생한다.
- 자바는 이러한 문제를 해결하기 위해, 단 하나의 추상 메서드(SAM: Single Abstract Method)만을 포함하는
  함수형 인터페이스에만 람다를 할당할 수 있도록 제한했다.

== @FunctionalInterface ==
- @FunctionalInterface 애노테이션을 사용하면 단 하나의 추상 메서드가 아니면 컴파일 단계에서
  오류가 발생한다. 따라서 함수형 인터페이스임을 보장할 수 있다.
  @Override와 비슷한 역할을 한다고 생각하면 된다.

- @FunctionalInterface 사용해 함수형 인터페이스임을 선언해두면, 이후에 누군가 실수로 추상 메서드를
  추가할 때 컴파일 오류가 발생한다.

따라서 람다를 사용할 함수형 인터페이스라면 @FunctionalInterface를 필수로 추가하자

<람다와 시그니처>
람다를 함수형 인터페이스에 할당할 때는 메서드의 형태를 정의하는 요소인 메서드 시그니처가 일치해야 한다.

== 메서드 시그니처의 주요 구성 요소 ==
1) 메서드 이름
2) 매개변수의 수와 타입(순서 포함)
3) 반환 타입

- 람다는 익명 함수이므로 시그니처에서 이름을 제외하고, 매개변수, 반환 타입이 함수형 인터페이스에 선언한
  메서드와 맞아야 한다.
- 참고로 람다의 매개변수 이름은 함수형 인터페이스에 있는 메서드 매개변수의 이름과 상관없이 자유롭게 작성해도 된다.
  타입과 순서만 맞으면 된다.

<람다와 생략>
람다는 간결한 코드 작성을 위해 다양한 문법 생략을 지원한다.

1) 람다 - 단일 표현식(single expression)인 경우
   - 단일 표현식인 경우 중괄호와 리턴 생략 가능,
   - 표현식의 결과가 자동으로 반환값이 됨
   - 중괄호를 사용하는 경우에는 반드시 return 문을 포함해야 한다.
   - return 문을 명시적으로 포함하는 경우 중괄호를 사용해야 한다.
   - 반환 타입이 void인 경우 return 생략 가능


2) 단일 표현식이 아닌 경우
   단일 표현식이 아닐 경우 중괄호를 생략할 수 없다.
   이 경우 반환 값이 있으면 return 문도 포함해야 한다.

예: 생략 전
   (int a, int b) -> {return a + b;};
   - a + b 와 같이 간단한 단일 표현식은 중괄호({})와 return을 함께 생략할 수 있다.

   생략 후
   (int a, int b) -> a + b;
   - 생략한 코드는 생략 전 코드와 같은 코드이다. return 문이 보이지 않지만 결과를 반환한다.

※표현식(expression)이란?
- 하나의 값으로 평가되는 코드 조각을 의미한다.
- 표현식은 산술 논리 표현식, 메서드 호출, 객체 생성등이 있다.
  ex) x + y, price * quantity, calculateTotal(), age >= 18
- 표현식이 아닌것은 제어문, 메서드 선언 같은 것이 있다.
  ex) if (condition) {}

== 타입 추론 ==
- 함수형 인터페이스의 메서드 시그니처를 보면 매개변수의 타입이 정의되어 있다.
- 이 정보를 사용하면 람다의 (int a, int b) -> {} 에서 타입 정보를 생략할 수 있다.

- 자바 컴파일러는 람다가 사용되는 함수형 인터페이스의 메서드 타입을 기반으로 람다의 매개변수와 반환값의
  타입을 추론한다. 따라서 람다는 타입을 생략할 수 있다.
- 반환 타입은 문법적으로 명시할 수 없다. 대신에 컴파일러가 자동으로 추론한다.

== 매개변수의 괄호 생략 ==
- 매개변수가 정확히 하나이면서, 타입을 생략하고, 이름만 있는 경우 소괄호()를 생략할 수 있다.
- 매개변수가 없는 경우에는 ()가 필수이다.
- 매개변수가 둘 이상이면 ()가 필수이다.

* 정리
- 매개변수 타입: 생략 가능하지만 필요하다면 명시적으로 작성할 수 있다.
- 반환 타입: 문법적으로 명시할 수 없고, 식의 결과를 보고 컴파일러가 항상 추론한다.
- 람다는 보통 간략하게 사용하는 것을 권장한다.
  단일 표현식이면 중괄호와 리턴을 생략하자.
  타입 추론을 통해 매개변수의 타입을 생략하자.(컴파일러가 추론할 수 있다면, 생략하자)

<람다의 전달>
람다는 함수형 인터페이스를 통해 변수에 대입하거나, 메서드에 전달하거나 반환할 수 있다.

1) 람다를 변수에 대입
MyFunction add = (a, b) -> a + b;
- 이 대입식에서 변수 add의 타입은 MyFunction 함수형 인터페이스이다. 따라서 MyFunction 형식에 맞는
  람다를 대입할 수 있다.(메서드 시그니처가 일치한다)

- 클래스나 인터페이스로 선언한 변수에 값을 대입하는 것은 인스턴스의 참조값을 대입하는 것이다.
- 람다도 마찬가지다. 함수형 인터페이스로 선언한 변수에 람다를 대입하는 것은 람다 인스턴스의 참조값을
  대입하는 것이다.
- 참고로 함수형 인터페이스도 인터페이스이다.

- 람다도 인터페이스(함수형 인터페이스)를 사용하므로, 람다 인스턴스의 참조값을 변수에 전달할 수 있다.

- 변수에 참조값을 전달할 수 있으므로 다음과 같이 사용할 수 있다.
    - 매개변수를 통해 메서드(함수)에 람다를 전달할 수 있다.(정확히는 람다 인스턴스의 참조값을 전달)
    - 메서드가 람다를 반환할 수 있다.(정확히는 람다 인스턴스의 참조값을 반환)

2) 람다를 메서드(함수)에 전달하기
람다는 변수에 전달할 수 있다. 같은 원리로 람다를 매개변수를 통해 메서드(함수)에 전달할 수 있다.

3) 람다를 반환하기
람다는 함수형 인터페이스 타입의 인스턴스이다. 따라서 메서드에 함수형 인스턴스를 반환값으로 정의하고
람다 자체(인스턴스)를 반환할 수 있다. 물론 인스턴스의 참조값이 반환된다.

<고차 함수>
람다는 함수형 인터페이스를 구현한 익명 클래스 인스턴스와 같은 개념으로 이해하면 된다.
즉, 람다를 변수에 대입한다는 것은 람다 인스턴스의 참조값을 대입하는 것이고, 람다를 메서드(함수)의
매개변수나 반환값으로 넘긴다는 것 역시 람다 인스턴스의 참조값을 전달, 반환하는 것이다.

== 고차 함수 ==
고차 함수는 함수를 값처럼 다루는 함수를 뜻한다.
일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
- 함수를 인자로 받는 함수(메서드)
- 함수를 반환하는 함수(메서드)

- 즉, 매개변수나 반환값에 함수(또는 람다)를 활용하는 함수가 고차 함수에 해당한다.
- 자바에서 람다(익명 함수)는 함수형 인터페이스를 통해서만 전달할 수 있다.
- 자바에서 함수를 주고받는다는 것은 함수형 인터페이스를 구현한 어떤 객체(람다든 익명 클래스든)를 주고받는것과
  동의어이다. (함수형 인터페이스는 인터페이스이므로 익명 클래스, 람다 둘다 대입할 수 있다. 하지만 실질적으로
  함수형 인터페이스에는 람다를 주로 사용한다.)

※용어 - 고차 함수
고차 함수(Higher-Order Function)라는 이름은 함수를 다루는 추상화 수준이 더 높다는 데에서 유래했다.
- 보통의 (일반적인) 함수는 데이터(값)를 입력으로 받고, 값을 반환한다.
- 이에 반해, 고차 함수는 함수를 인자로 받거나 함수를 반환한다.
- 쉽게 이야기하면 일반 함수는 값을 다루지만, 고차 함수는 함수 자체를 다룬다.

즉, 값을 다루는 것을 넘어 함수라는 개념 자체를 값처럼 다룬다는 점에서 추상화의 수준(계층, order)이 한 단계
높아진다고 해서 Higher-Order(더 높은 차원의) 함수라고 부른다.

※내 생각
람다식을 작성하는것은 함수(메서드)를 정의하는 것이다. 정의한 함수(람다, 익명함수)를 호출해줘야한다.
고차함수 중 매개변수로 람다를 받는 함수가 있을 때, 매개변수를 통해 람다식(정의한 함수)을 전달받고
전달받은 람다식을 고차함수 내부에서 호출하는 것이다.
고차함수 내부에서 함수를 호출할 때는 람다식에 정의된 매개변수(매개변수 정의 되었을 시) 함수형 인터페이스에
정의된 메서드 이름을 통해 람다식을 호출하면서 인자를 전달한다.
전달된 인자는 람다식의 매개변수에 전달되어 로직을 수행한다.

* 정리
1) 람다란
- 자바 8에서 도입된 익명 함수로, 이름 없이 간결하게 함수를 표현한다.
- 익명 클래스보다 보일러플레이트 코드를 줄여 생상성과 가독성을 높이는 문법 설탕 역할.

2) 함수형 인터페이스
- 람다를 사용할 수 있는 기반으로, 단일 추상 메서드(SAM)만 포함하는 인터페이스
- @FunctionalInterface로 보장하며, 하나의 메서드만 정의
- 여러 메서드가 있으면 람다 할당 불가(모호성 방지)

3) 람다 문법
- 기본 형태: (매개변수) -> {본문}
- 생략 가능
    - 단일 표현식(본문, 반환 생략): x -> x + 1
    - 타입 추론: (int x) -> x ----> (x) -> x
    - 매개변수 괄호(단일 매개변수일 때): x -> x
- 시그니처(매겨변수 수/타입/순서, 반환 타입)이 함수형 인터페이스와 일치해야 함

4) 람다 활용
- 변수 대입: 람다 인스턴스를 변수에 저장
- 메서드 전달: 메서드 인자에 람다(함수) 전달 가능
- 반환: 메서드에서 람다를 반환

5) 고차 함수
- 함수를 인자나 반환값으로 다루는 함수(ex. filter, map, reduce)
- 자바에서는 함수형 인터페이스와 람다로 구현하며, 코드의 유연성과 추상화 수준을 높임

6) 기타
- 람다는 익명 클래스를 간소화한 도구지만, 내부적으로 인스턴스가 생성됨
- 반복 연습으로 문법과 활용법을 익히는 것이 중요
