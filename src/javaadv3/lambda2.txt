[람다2]

<함수형 인터페이스와 제네릭>
함수형 인터페이스도 인터페이스이기 때문에 제네릭을 도입할 수 있다.

== 함수형 인터페이스에 제네릭이 필요한 이유 ==
매개변수나 반환 타입이 다를 때마다 계속 함수형 인터페이스를 만들어야하는 문제가 있다.

Object 타입을 매개변수로 받고 또 Object 타입을 반환하면 모든 타입을 입력받고,
또 모든 타입을 반환할 수 있다. 따라서 타입에 따라 각각 다른 함수형 인터페이스를 만들지 않아도 된다.
하지만 Object를 사용하기 때문에 복잡하고 안전하지 않은 캐스팅 과정이 필요하다.

* 정리
Object와 다형성을 활용하면 코드의 중복을 제거하고, 재사용성을 늘릴 수 있다.
하지만 Object를 사용하므로 다운 캐스팅을 해야 하고, 결과적으로 타입 안정성 문제가 발생한다.
이것은 코드 재사용과 타입 안정성이라는 2마리 토끼를 한번에 잡을 수 없다.

== 함수형 인터페이스에 제네릭 도입 ==
- 제네릭을 사용하면 동일한 구조의 함수형 인터페이스를 다양한 타입에 재사용할 수 있다.
- 실제 함수형 인터페이스를 사용할 때 구체적인 타입을 지정하면 된다.
- 제네릭을 활용하면 타입 안정성을 보장하면서도 유연한 코드를 작성할 수 있다.
- 제네릭을 사용하지 않았다면 각각의 경우에 대해 별도의 함수형 인터페이스를 만들어야 하고
  코드의 중복을 야기하고 유지보수성을 힘들게 한다.

<람다와 타겟 타입>
문제1. 모든 개발자들이 비슷한 함수형 인터페이스를 개발해야 한다.
문제2. 개발자A가 만든 함수형 인터페이스와 개발자B가 만든 함수형 인터페이스는 서로 호환되지 않는다.

== 람다와 타겟 타입 ==
람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, 타겟 타입(target type)이라고 불리는
맥락(대입되는 참조형)에 의해 타입이 결정된다.

FunctionA functionA = i -> "value = " + i;
위 코드에서 i -> "value = " + i; 라는 람다는 FunctionA 라는 타겟 타입을 만나서 비로소
FunctionA 타입으로 결정된다.

FunctionB functionB = i -> "value = " + i;
동일한 람다라도 이런 코드가 있었다면, 똑같은 람다가 이번에는 FunctionB 타입으로 타겟팅되어
유효하게 컴파일된다.

쉽게 말해 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, 대입되는 함수형 인터페이스(타겟 타입)에
의해 비로소 타입이 결정된다.

이렇게 타입이 결정되고 나면 이후에는 다른 타입에 대입하는 것이 불가능하다. 이후 함수형 인터페이스를 다른
함수형 인터페이스에 대입하는 것은 타입이 서로 다르기 때문에, 메서드의 시그니처가 같아도 대입이 되지 않는다.

FunctionB targetB = functionA;  // 컴파일 에러!

FunctionA와 FunctionB는 서로 타입이 다르다. 따라서 대입이 불가능하다.
이것은 마치 Integer에 String을 대입하는 것과 같다.

두 인터페이스가 시그니처가 같고 똑같은 모양의 함수형 인터페이스라도, 타입 자체는 별개이므로
상호 대입은 허용되지 않는다.

* 정리
- 람다는 익명 함수로서 특정 타입을 가지지 않고, 대입되는 참조 변수가 어떤 함수형 인터페이스를 가리키느냐에
  따라 타입이 결정된다.
- 시그니처가 똑같은 함수형 인터페이스라도, 타입이 다르면 상호 대입이 되지 않는 것이 자바의 타입 시스템 규칙이다.

<자바가 기본으로 제공하는 함수형 인터페이스>
자바는 위와 같은 문제들을 해결하기 위해 필요한 함수형 인터페이스 대부분을 기본으로 제공한다.
자바가 제공하는 함수형 인터페이스를 사용하면, 비슷한 함수형 인터페이스를 불필요하게 만드는 문제는 물론이고,
함수형 인터페이스의 호환성 문제까지 해결할 수 있다.

- 자바는 java.util.function 패키지에 다양한 기본 함수형 인터페이스들을 제공한다.
- 따라서 자바가 기본으로 제공하는 함수형 인터페이스를 사용하자

== 기본 함수형 인터페이스 ==
자바가 기본으로 제공하는 가장 대표적인 함수형 인터페이스

- Function: 입력o, 반환o
- Consumer: 입력o, 반환x
- Supplier: 입력x, 반환o
- Runnable: 입력x, 반환x

- 함수형 인터페이스들은 대부분 제네릭을 활용하므로 종류가 많을 필요는 없다.
- 함수형 인터페이스는 대부분 java.util.function 패키지에 위치한다.
- Runnable은 java.lang 패키지에 위치한다.

1. Function
- 하나의 매개변수를 받고, 결과를 반환하는 함수형 인터페이스이다.
- 입력값을 받아서 다른 타입의 출력값을 반환하는 연산을 표현할 때 사용한다.
  물론 같은 타입의 출력 값도 가능하다.
- 일반적인 함수(Function)의 개념에 가장 가깝다.
예: 문자열을 받아서 정수로 변환, 객체를 받아서 특정 필드 추출 등

2. Consumer
- 입력 값만 받고, 결과를 반환하지 않는(void) 연산을 수행하는 함수형 인터페이스이다.
- 입력값을 받아서 처리하지만 결과를 반환하지 않는 연산을 표현할 때 사용한다.
- 입력 받은 데이터를 기반으로 내부적으로 처리만 하는 경우에 유용하다.
  예: 컬렉션에 값 추가, 콘솔 출력, 로그 작성, DB 저장 등

3. Supplier
- 입력을 받지 않고 어떤 데이터를 공급(supply)해주는 함수형 인터페이스이다.
- 객체나 값 생성, 지연 초기화 등에 주로 사용된다.

4. Runnable
- 입력값도 없고 반환값도 없는 함수형 인터페이스이다. 자바에서는 원래부터 스레드 실행을 위한 인터페이스로
  쓰였지만, 자바 8 이후에는 람다식으로도 많이 표현된다. 자바 8로 업데이트 되면서 @FunctionalInterface
  애노테이션도 붙었다.
- java.lang 패키지에 있다. 자바의 경우 원래부터 있던 인터페이스는 하위 호환을 위해 그대로 유지한다.
- 주로 멀티스레딩에서 스레드의 작업을 정의할 때 사용한다.
- 입력값도 없고, 반환값도 없는 함수형 인터페이스가 필요할 때 사용한다.

<특화 함수형 인터페이스>
특화 함수형 인터페이스는 의도를 명확하게 만든 조금 특별한 함수형 인터페이스다.
'의도를 명시적으로 드러내기 위해 정의된 함수형 인터페이스'

- Predicate: 입력o, 반환 boolean
  조건 검사, 필터링 용도
- Operator(UnaryOperator, BinaryOperator): 입력o, 반환o
  동일한 타입의 연산 수행, 입력과 같은 타입을 반환하는 연산 용도

1. Predicate
- 입력값을 받아서 true 또는 false로 구분(판단)하는 함수형 인터페이스이다.
- 조건 검사, 필터링 등의 용도로 많이 사용된다.
  스트림 API 에서 필터 조건을 지정할 때 자주 등장한다.

Predicate는 입력이 있고 반환이 boolean 이기 때문에 결과적으로 Function<T, Boolean>으로 대체할
수 있다. 그럼에도 불구하고 Predicate를 별도로 만든 이유는 '의도를 명시적으로 드러내기 위함'이다.

목적(조건 검사)과 용도(필터링 등)에 대해 더 분명히 표현하고, 가독성과 유지보수를 위해 Predicate<T>라는
별도의 함수형 인터페이스가 마련되었다.

★의도가 가장 중요한 핵심

2. Operator
- Operator는 UnaryOperator, BinaryOperator 2가지 종류가 제공된다.
- 입력과 반환이 동일한 타입의 연산에 사용할 수 있다.

2-1. UnaryOperator(단항 연산)
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
    T apply(T t); // 실제 코드가 있지는 않음
}

- 입력과 결과가 동일한 타입인 연산을 수행할 때 사용한다.

2-2. BinaryOperator(이항 연산)
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T> {
    T apply(T t1, T t2); // 실제 코드가 있지는 않음
}

- 같은 타입의 두 입력을 받아, 같은 타입의 결과를 반환할 때 사용된다.
    Integer 두 개를 받아서 더한 값을 반환 등
- BiFunction<T,T,T>를 상속받는 방식으로 구현되어 있는데, 입력값 2개와 반환을 모두 같은 T로 고정한다.
  따라서 BinaryOperator는 모든 입력과 반환 타입이 반드시 같아야 한다.
- BiFunction은 입력 매개변수가 2개인 Function 이다.

UnaryOperator, BinaryOperator를 별도로 제공하는 이유도 Predicate와 같이
의도를 명확히 하기 위해서 이다.
이를 통해 개발자의 의도와 로직을 더 명확히 표현하고, 가독성을 높일 수 있는 장점이 있다.

<기타 함수형 인터페이스>
== 입력 값이 2개 ==
- 매개변수가 2개 이상 필요한 경우에는 BiXxx 시리즈를 사용하면 된다. Bi는 Binary(이항, 둘)의 줄임말이다.
- 예: BiFunction, BiConsumer, BiPredicate
      Supplier, Runnable은 매개변수가 없으므로 BiSupplier, BiRunnable은 존재하지 않는다.

== 입력값이 3개 ==
입력값이 3개라면 TriXxx가 있으면 좋겠지만, 이런 함수형 인터페이스는 기본으로 제공하지 않는다.
보통 함수형 인터페이스를 사용할 때 3개 이상의 매개변수는 잘 사용하지 않기 때문이다.
만약 입력값이 3개일 경우라면 직접 만들어서 사용하면 된다.

<기본형 지원 함수형 인터페이스>
- 기본형(primitive type)을 지원하는 함수형 인터페이스도 있다.

@FunctionalInterface
public interface IntFunction<R> {
    R apply(int value);
}

== 기본형 지원 함수형 인터페이스가 존재하는 이유 ==
- 오토박싱/언박싱 으로 인한 성능 비용을 줄이기 위해
- 자바 제네릭의 한계(제네릭은 primitive 타입을 직접 다룰 수 없음)를 극복하기 위해
  자바 제네릭은 기본형 타입을 직접 다룰 수 없어서, Function<int, R> 같은 식으로는 선언할 수 없다.


- 기본형 매개변수: 기본형 매개변수를 받아 지정 반환 타입으로 반환
  IntFunction<R>, LongFunction<R>, DoubleFunction<R>
- 기본형 반환: 지정 타입을 매개변수로 받아 기본형으로 반환
  ToIntFunction<T>, ToLongFunction<T>, ToDoubleFunction<T>
- 기본형 매개변수, 기본형 반환: 기본형 입력, 반환
  IntToLongFunction
- 기본형 단항 연산: 같은 기본형 입력, 반환
  IntUnaryOperator
- 기타
  IntConsumer, IntSupplier, IntPredicate

* 정리 - 함수형 인터페이스 종류
1. 기본 함수형 인터페이스
   Function<T, R>, Consumer<T>, Supplier<T>, Runnable
2. 특화 함수형 인터페이스
    Predicate<T>, UnaryOperator<T>, BinaryOperator<T>
3. 입력값 2개 인터페이스
   BiFunction, BiConsumer, BiPredicate
4. 기본형 인터페이스
   IntFunction<R>, LongFunction<R>, DoubleFunction<R>,
   ToIntFunction<T>, ToLongFunction<T>, ToDoubleFunction<T>,
   IntToLongFunction,
   IntUnaryOperator,
   IntConsumer, IntSupplier, IntPredicate

- 자바가 기본으로 지원하지 않는다면 직접 만들어서 사용하자. 예(매개변수가 3개 이상)
- 기본형(primitive type)을 지원해야 한다면 IntFunction 등을 사용하자.

람다와 함수형 인터페이스를 제대로 활용하면 코드가 간결해지고 가독성이 높아지며, 제네릭을 도입하면
재사용성과 타입 안정성까지 모두 확보할 수 있다. 또한 자바가 기본적으로 제공하는 다양한 함수형 인터페이스를
적극 활용하면, 불필요하게 유사한 인터페이스를 여러 개 만들 필요가 없고 호환성 문제도 해결된다.

무엇보다 '의도를 명확하게 드러내는' 함수형 인터페이스를 적절히 선택하는 것이 중요하다. 조건 검사는
Predicate, 입력과 반환 타입이 같은 단항 연산은 UnaryOperator, 매개변수가 2개이면서 입력과 반환 타입이
같은 연산은 BinaryOperator 처럼 상황에 맞는 인터페이스를 사용하면 코드의 목적이 분명해지고
유지보수성이 향상된다.

<명령형 vs 선언적 프로그래밍>
== 명령형 프로그래밍(Imperative Programming) ==
- 정의: 프로그램이 어떻게(How) 수행되어야 하는지, 즉 수행 절차를 명시하는 방식이다.
- 특징:
    1) 단계별 실행: 프로그램의 각 단계를 명확하게 지정하고 순서대로 실행한다.
    2) 상태 변화: 프로그램의 상태(변수 값 등)가 단계별로 어떻게 변화하는지 명시한다.
    3) 낮은 추상화: 내부 구현을 직접 제어해야 하므로 추상화 수준이 낮다.
    4) 예시: 전통적이 for 루프, while 루프 등을 명시적으로 사용하는 방식
    5) 장점: 시스템의 상태와 흐름을 세밀하게 제어할 수 있다.

== 선언적 프로그래밍(Declarative Programming) ==
- 정의: 프로그램이 무엇(What)을 수행해야 하는지, 즉 원하는 결과를 명시하는 방식이다.
- 특징:
    1) 문제 해결에 집중: 어떻게(how) 문제를 해결할지보다 무엇을 원하는지에 초점을 맞춘다.
    2) 코드 간결성: 간결하고 읽기 쉬운 코드를 작성할 수 있다.
    3) 높은 추상화: 내부 구현을 숨기고 원하는 결과에 집중할 수 있도록 추상화 수준을 높인다.
    4) 예시: filter, map 등 람다의 고차 함수를 활용, HTML, SQL 등
- 장점: 코드가 간결하고, 의도가 명확하며, 유지보수가 쉬운 경우가 많다.

* 정리
- 명령형 프로그래밍은 프로그램이 수행해야 할 각 단계와 처리 과정을 상세하게 기술하여, 어떻게 결과에 도달할지를
  명시한다.
- 선언적 프로그래밍은 원하는 결과나 상태를 기술하며, 그 결과를 얻기 위한 내부 처리 방식은 추상화되어 있어 개발자가
  무엇을 원하는지에 집중할 수 있게 한다.
- 특히, 람다와 같은 도구를 사용하면, 코드를 간결하게 작성하여 선언적 스타일로 문제를 해결할 수 있다.

<정적 팩토리 메서드 - static factory method>
정적 팩토리 메서드는 객체 생성을 담당하는 static 메서드로, 생성자(constructor) 대신 인스턴스를 생성하고
반환하는 역활을 한다. 즉, 일반적인 생성자(constructor) 대신에 클래스의 인스턴스를 생성하고 초기화하는 로직을
캡슐화하여 제공하는 정적(static) 메서드이다.

- 특징
1) 정적 메서드: 클래스 레벨에서 호출되며, 인스턴스 생성 없이 접근할 수 있다.
2) 객체 반환: 내부에서 생성한 객체(또는 이미 존재하는 객체)를 반환한다.
3) 생성자 대체: 생성자와 달리 메서드 이름을 명시할 수 있어, 생성 과정의 목적이나 특징을 명확하게 표현할 수 있다.
4) 유연한 구현: 객체 생성 과정에서 캐싱, 객체 재활용, 하위 타입 객체 반환 등 다양한 로직을 적용할 수 있다.

생성자는 이름을 부여할 수 없다. 반면에 정적 팩토리 메서드는 의미있는 이름을 부여할 수 있어, 가독성이 더 좋아지는
장접이 있다.
참고로 인자들을 받아 간단하게 객체를 생성할 때는 주로 of(...) 라는 이름을 사용한다.

※참고
정적 팩토리 메서드를 사용하면 생성자에 이름을 부여할 수 있기 때문에 보통 가독성이 더 좋아진다. 하지만 반대로
이야기하면 이름도 부여해야 하고, 준비해야 하는 코드도 더 많다. 객체의 생성이 단순한 경우에는 생성자를
직접 사용하는 것이 단순함의 관점에서 보면 더 나은 선택일 수 있다.


<람다 vs 익명 클래스>
자바에서 익명 클래스와 람다 표현식은 모두 간단하게 기능을 구현하거나, 일회성으로 사용할 객체를 만들 때 유용하지만,
그 사용 방식과 의도에는 차이가 있다.

1. 문법 차이
    1) 익명 클래스
    - 익명 클래스는 클래스를 선언하고 즉시 인스턴스를 생성하는 방식이다.
    - 반드시 new 인터페이스명() {} 형태로 작성해야 하며, 메서드를 오버라이드해서 구현한다.
    - 익명 클래스도 하나의 클래스이다.

    2) 람다 표현식
    - 람다 표현식은 함수를 간결하게 표현할 수 있는 방식이다.
    - 함수형 인터페이스(메서드가 하나인 인터페이스)를 간단히 구현할 때 주로 사용한다.
    - 람다는 -> 연산자를 사용하여 표현하며, 매개변수와 실행할 내용을 간결하게 작성할 수 있다.
    - 물론 람다도 인스턴스가 생성된다.

2. 코드의 간결함
- 익명 클래스는 문법적으로 더 복잡하고 장황하다. 코드의 양이 상대적으로 많다.
- 람다 표현식은 간결하며, 불필요한 코드를 최소화한다. 또한 많은 생략 기능을 지원해서 핵심 코드만 작성할 수 있다.

3. 상속 관계
- 익명 클래스는 일발적인 클래스처럼 다양한 인터페이스와 클래스를 구현하거나 상속할 수 있다.
  즉, 여러 메서드를 가진 인터페이스를 구현할 때도 사용할 수 있다.
- 람다 표현식은 메서드를 딱 하나만 가지는 함수형 인터페이스만을 구현할 수 있다.
    - 람다 표현식은 클래스를 상속할 수 없다. 오직 함수형 인터페이스만 구현할 수 있으며, 상태(필드, 멤버 변수)나
      추가적인 메서드 오버라이딩은 불가능하다.
    - 람다는 단순히 함수를 정의하는 것으로, 상태나 추가적인 상속 관계를 필요로 하지 않는 상황에서만 사용할 수 있다.

4. 호환성
- 익명 클래스는 자바의 오래된 버전에서도 사용할 수 있다.
- 람다 표현식은 자바 8부터 도입되었기 때문에 그 이전 버전에서는 사용할 수 없다.

5. this 키워드의 의미
- 익명 클래스 내부에서 this는 익명 클래스 자신을 가리킨다. 외부 클래스와 별도의 컨텍스트를 가진다.
- 람다 표현식에서 this는 람다를 선언한 클래스의 인스턴스를 가리킨다.
  즉, 람다 표현식은 별도의 컨텍스를 가지는 것이 아니라, 람다를 선언한 클래스의 컨텍스트를 유지한다.
  쉽게 말해, 람다 내부의 this는 람다가 선언된 외부 클래스의 this와 동일하다.

6. 캡처링(capturing)
- 익명 클래스: 익명 클래스는 외부 변수에 접근할 수 있지만, 지역 변수는 반드시 final 혹은 사실상 final인 변수만
             캡처할 수 있다.
- 람다 표현식: 람다도 익명 클래스와 같이 캡처링을 지원한다. 지역 변수는 반드시 final 혹은 사실상 final인 변수만
             캡처할 수 있다.

익명 클래스나 람다 안에서 외부의 지역 변수를 캡처해서 사용할 수 있다. 단 이때 final, 사실상 final 지역 변수만
접근할 수 있다.

7. 생성 방식
생성 방식은 자바 내부 동작 방식으로 크게 중요하지 않다. 이런게 있구나 하고 참고만 해두자.

    1) 익명 클래스
    - 익명 클래스는 새로운 클래스를 정의하여 객체를 생성하는 방식이다. 즉, 컴파일 시 새로운 내부 클래스로 변환된다.
    - 이 방식은 클래스가 메모리 상에서 별도로 관리되므로, 메모리 상에 약간의 추가 오버헤드가 발생한다.

    2) 람다
    - 람다는 내부적으로 invokeDynamic 이라는 메커니즘을 사용하여 컴파일 타임에 실제 클래스 파일을 생성하지 않고,
      런타임 시점에 동적으로 필요한 코드를 처리한다.
    - 따라서 람다는 익명 클래스보다 메모리 관리가 더 효율적이며, 생성된 클래스 파일이 없으므로 클래스 파일 관리의
      복잡성도 줄어든다.

생성 방식 쉽게 정리
- 익명 클래스
    - 컴파일 시 실제로 OuterClass$1.class 와 같은 클래스 파일이 생성된다.
    - 일반적인 클래스와 같은 방식으로 작동한다.
    - 해당 클래스 파일을 JVM에 불러서 사용하는 과정이 필요하다.
- 람다
    - 컴파일 시점에 별도의 클래스 파일이 생성되지 않는다.
    - 자바를 실행하는 실행  시점에 동적으로 필요한 코드를 처리한다.

이 부분은 자바 스펙에 명시된 것이 아니기 때문에 자바 버전과 자바 구현 방식에 따라 내용이 달라질 수 있다.
따라서 대략 이런 방식으로 작동하는구나라고 참고만 해두자.

이론적으로는 람다가 별도의 클래스 파일도 만들지 않고, 더 가볍기 때문에 약간의 메모리와 성능의 이점이 있지만
이런 부분은 아주 미미하기 때문에, 실무 관점에서 익명 클래스와 람다의 성능 차이는 거의 없다고 보면 된다.

8. 상태 관리
    1) 익명 클래스
    - 익명 클래스는 인스턴스 내부에 상태(필드, 멤버 변수)를 가질 수 있다. 예를 들어, 익명 클래스 내부에 멤버 변수를
      선언하고 해당 변수의 값을 변경하거나 상태를 관리할 수 있다.
    - 이처럼 상태를 필요로 하는 경우, 익명 클래스가 유리하다.

    2) 람다
    - 클래스는 그 내부에 상태(필드, 멤버 변수)와 기능(메서드)을 가진다. 반면에 함수는 그 내부에 상태(필드)를
      가지지 않고, 기능만 제공한다.
    - 함수인 람다는 기본적으로 필드(멤버 변수)가 없으므로 스스로 상태를 유지하지는 않는다.

9. 익명 클래스와 람다의 용도 구분
    1) 익명 클래스
    - 상태를 유지하거나 다중 메서드를 구현할 필요학 있는 경우
    - 기존 클래스 또는 인터페이스를 상속하거나 구현할 때
    - 복잡한 인터페이스 구현이 필요할 때

    2) 람다
    - 상태를 유지할 필요가 없고, 간결함이 중요한 경우
    - 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
    - 더 나은 성능(이 부분은 미미함)과 간결한 코드가 필요한 경우

* 정리, 요약
- 대부분의 경우 익명 클래스를 람다로 대체할 수 있다. 하지만 여러 메서드를 가진 인터페이스나 클래스의 경우에는
  여전히 익명 클래스가 필요할 수 있다.
- 자바 8 이후에는 익명 클래스, 람다 둘 다 선택할 수 있는 경우라면 익명 클래스 보다는 람다를 선택하는 것이 간결한
  코드, 가독성 관점에서 대부분 더 나은 선택이다.