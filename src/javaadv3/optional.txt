[Optional]

<옵셔널이 필요한 이유>
1) NullPointerException(NPE)문제
- 자바에서 null은 값이 없음을 표현하는 가장 기본적인 방법이다.
- 하지만 null을 잘못 사용하거나 null 참조에 대해 메서드를 호출하면 NullPointerException(NPE)이
  발생하여 프로그램이 예기치 않게 종료될 수 있다.
- 특히 여러 메서드가 연쇄적으로 호출되어 내부에서 null 체크가 누락되면, 추적하기 어렵고 디버깅 비용이
  증가한다.

2) 가독성 저하
- null을 반환하거나 사용하게 되면, 코드를 작성할 때마다 조건문으로 null 여부를 계속 확인해야 한다.

3) 의도가 드러나지 않음
- 메서드 시그니처(String findNameById(Long id))만 보고서는 이 메서드가 null을 반환할 수도 있다는
  사실을 명확히 알기 어렵다.
- 호출하는 입장에서는 반드시 값이 존재할 것 이라고 가정했다가, 런타임에 null이 나와서 문제가
  생길 수 있다.

- 이러한 문제를 히결하고자 자바 8부터 Optional 클래스를 도입했다.
- Optional은 값이 있을 수도 있고 없을 수도 있음을 명시적으로 표현해주어, 메서드의 계약(Contract)이나
  호출 의도를 좀 더 분명하게 드러낸다.
- Optional을 사용하면 빈 값을 표현할 때, 더 이상 null 자체를 넘겨주지 않고 Optional.empty()처럼
  의도를 드러내는 객체를 사용할 수 있다.
- 그 결과, Optional을 사용하면 null 체크 로직을 간결하게 만들고, 특정 경우에 NPE가 발생할 수 있는
  부분을 빌드 타임이나, IDE, 코드 리뷰에서 더 쉽게 파알할 수 있게 해준다.
- 이 방식은 값이 없을 수도 있다는 점을 호출하는 측에 명확히 전달하므로, 놓치기 쉬운 null 체크를 강제하고
  코드의 안정성을 높인다.

<Optional 소개>
package java.util;
public final class Optional<T> {
    private final T value;
    ...
}

== 정의 ==
- java.util.Optional<T>는 존재할 수도 있고 존재하지 않을 수도 있는 값을 감싸는 일종의 컨테이너 클래스이다.
- 내부적으로 null을 직접 다루는 대신, Optional 객체에 감싸서 Optional.empty() 또는 Optional.of(value)
  형태로 다룬다.

== 등장 배경 ==
- 값이 없을 수 있다는 상황을 프로그래머가 명시적으로 처리하도록 유도하고, 런타임 NullPointerException을
  사전에 예방하기 위해 도입되었다.
- 코드를 보는 사람이나 협업하는 팀원 모두가, 해당 메서드의 반환값이 비어있을 수도 있음을 알 수 있게 되어
  오류를 줄일 수 있다.

※참고
- Optional은 값이 없을 수도 있다는 상황을 반환할 때 주로 사용된다.
- 항상 값이 있어야 하는 상황에서는 Optional을 사용할 필요 없이 그냥 해당 타입을 바로 사용하거나
  예외를 던지는 방식이 더 좋을 수 있다.

<Optional의 생성과 값 획득>
== Optional을 생성하는 메서드 ==
- Optional.of(T value)
    내부 값이 확실히 null이 아닐 때 사용. null을 전달하면 NullPointerException 발생
- Optional.ofNullable(T value)
    값이 null일 수도 있고 아닐 수도 있을 때 사용. null 이면 Optional.empty()를 반환한다.
- Optional.empty()
    명시적으로 값이 없을을 표현할 때 사용

<Optional 값 획득>
Optional에 들어있는 값을 꺼내는 여러 가지 방법을 알아본다.

== Optional의 값을 확인하거나, 획득하는 메서드 ==
1. isPresent(), isEmpty()
    - 값이 있으면 true
    - 값이 없으면 false를 반환. 간단 확인용
    - isEmpty(): 자바 11 이상에서 사용 가능, 값이 비어있으면 true, 값이 있으면 false를 반환
2. get()
    - 값이 있는 경우 그 값을 반환
    - 값이 없으면 NoSuchElementException 발생
    - 직접 사용 시 주의해야 하며, 가급적이면 orElse, orElseXxx 계열 메서드를 사용하는 것이 안전
3. orElse(T other)
    - 값이 있으면 그 값을 반환
    - 값이 없으면 other를 반환
4. orElseGet(Supplier<? extends T> supplier)
    - 값이 있으면 그 값을 반환
    - 값이 없으면 supplier 호출하여 생성된 값을 반환
5. orElseThrow(...)
    - 값이 있으면 그 값을 반환
    - 값이 없으면 지정한 예외를 던짐
6. or(Supplier<? extends Optional<? extends T>> supplier)
    - 값이 있으면 해당 값의 Optional을 그대로 반환
    - 값이 없으면 supplier가 제공하는 다른 Optional 반환
    - 값 대신 Optional을 반환한다는 특징

<Optional 값 처리>
Optional 에서는 값이 존재할 때와 존재하지 않을 때를 처리하기 위한 다양한 메서드들을 제공한다.
이를 활용하면, null 체크 로직 없이도 안전하고 간결하게 값을 다룰 수 있다.

- ifPresent(Consumer<? super T> action)
    - 값이 존재하면 action 실행
    - 값이 없으면 아무것도 안 함
- ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)
    - 값이 존재하면 action 실행
    - 값이 없으면 emptyAction 실행
- map(Function<? super T, ? extends U> mapper)
    - 값이 있으면 mapper를 적용한 결과 Optional<U> 반환
    - 값이 없으면 Optional.empty() 반환
- flatMap(Function<? super T, ? extends Optional<? extends U>> mapper)
    - map과 유사하지만, Optional을 반환할 때 중첩되지 않고 평탄화(flat)해서 반환
- filter(Predicate<? super T> predicate)
    - 값이 있고 조건을 만족하면 그대로 반환
    - 조건 불만족이거나 비어있으면 Optional.empty() 반환
- stream()
    - 값이 있으면 단일 요소를 담은 Stream<T> 반환
    - 값이 없으면 빈 스트림 반환

<즉시 평가와 지연 평가>
- 즉시 평가(eager evaluation)
    값(혹은 객체)을 바로 생성하거나 계산해 버리는 것
- 지연 평가(lazy evaluation)
    값이 실제로 필요할 때(즉, 사용될 때)까지 계산을 미루는 것

여기서 평가라고 하는 것은 계산이라고 생각하면 된다.

== 연산을 정의하는 시점과, 연산을 실행하는 시점을 분리 ==
자바 언어에서 연산을 정의하는 시점과 해당 연산을 실행하는 시점을 분리하는 방법은 여러 가지가 있다.
- 익명 클래스를 만들고, 메서드를 나중에 호출
- 람다를 만들고, 해당 람다를 나중에 호출

람다를 사용하면 연산을 정의하는 시점과, 실행(평가)하는 시점을 분리할 수 있다.
따라서 값이 실제로 필요할 때 까지 계산을 미룰 수 있다.
람다를 활용한 지연 평가 덕분에 꼭 필요한 계산만 처리할 수 있다.

== orElse() vs orElseGet() ==
- orElse(): 보통 데이터를 받아서 인자가 즉시 평가된다.
- orElseGet(): 람다를 받아서 인자가 지연 평가된다.

<옵셔널 - 베스트 프랙티스>
- Optional이 좋아보여도 무분별하게 사용하면 오히려 코드 가독성과 유지보수에 도움이 되지 않을 수 있다.
- Optional은 주로 메서드의 반환값에 대해 값이 없을 수도 있음을 표현하기 위해 도입되었다.
  핵심은 메서드의 반환값에 Optional을 사용하라는 것이다.

1. 반환 타입으로만 사용하고, 필드에는 가급적 쓰지 말기
    - Optional은 주로 메서드의 반환값에 대해 값이 없을 수도 있음을 표현하기 위해 도입되었다.
    - 클래스의 필드(멤버 변수)에 Optional을 직접 두는 것은 권장하지 않는다.

2. 메서드 매개변수로 Optional을 사용하지 말기
    - 자바 공식 문서에 Optional은 메서드의 반환값으로 사용하기를 권장하며, 매개변수로 사용하지 말라고
      명시되어 있다.
    - 호출하는 측에서는 단순히 null 전달 대신 Optional.empty()를 전달해야 하는 부담이 생기며, 결국
      null을 사용하든 Optional.empty()를 사용하든 큰 차이가 없어 가독성만 떨어진다.

3. 컬렉션이나 배열 타입을 Optional로 감싸지 말기
    - List<T>, Set<T>, Map<K, V> 등 컬렉션 자체는 비어있는 상태를 표현할 수 있다.
    - 따라서 Optional<List<T>> 처럼 다시 감싸면 Optional.empty()와
      빈 리스트(Collections.emptyList())가 이중 표현이 되고, 혼란을 야기한다.
    - 빈 컬렉션을 반환하면, 호출 측에서는 단순히 list.isEmpty()로 처리하면 된다.

4. isPresent()와 get() 조합을 직접 사용하지 않기
    - Optional의 get() 메서드는 가급적 사용하지 않아야 한다.
    - if (opt.isPresent()) { ... opt.get() ... } else { ... }는 사실상 null 체크와
      다를 바 없으며, 깜빡하면 NoSuchElementException 같은 예외가 발생할 위험이 있다.
    - 대신 orElse, orElseGet, orElseThrow, ifPresentOrElse, map, filter 등의 메서드를
      활용하면 간결하고 안전하게 처리할 수 있다.
    - get() 메서드는 가급적 사용하지 말고, 예제 코드나, 간단한 테스트에서만 사용하는 것을 권장한다.
    - 그럼에도 불구하고 get() 메서드를 사용해야 하는 상황이라면, 이럴 때는 반드시 isPresent()와 함께
      사용하는 것을 권장한다.

5. orElseGet() vs orElse() 차이를 분명히 이해하기

6. 무조건 Optional이 좋은 것은 아니다
    - Optional은 분명히 평의성과 안정성을 높여주지만, 모든 곳에서 무조건 사용하는 것은 오히려 코드
      복잡성을 증가시킬 수 있다.
    - 다음과 같은 경우 Optional 사용이 오히려 불필요할 수 있다.
        1. 항상 값이 있는 상황
            비즈니스 로직상 null이 될 수 없는 경우, 그냥 일반 타입을 사용하거나, 방어적 코드로
            예외를 던지는 편이 낫다.
        2. 값이 없으면 예외를 던지는 것이 더 자연스러운 상황
        3. 흔히 비는 경우가 아니라 흔히 채워져 있는 겨우
            Optional을 쓰면 매번 get(), orElse(), orElseThrow() 등 처리가 강제되므로 오히려
            코드가 장황해질 수 있다.
        4. 성능이 극도로 중요한 로우레벨 코드
            Optional은 래퍼 객체를 생성하므로, 수많은 객체가 단기간에 생겨나는 영역(예: 루프 내부)에서는
            성능 영향을 줄 수 있다.









