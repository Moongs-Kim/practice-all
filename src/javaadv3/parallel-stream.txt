[병렬 스트림]

<Fork / Join 패턴>
분할(Fork), 처리(Execute), 모음(Join)
스레드는 한 번에 하나의 작업을 처리할 수 있다. 따라서 하나의 큰 작업을 여러 스레드가 처리할 수 있는
작은 단위의 작업으로 분할(Fork)해야 한다. 그리고 이렇게 분할한 작업을 각각의 스레드가 처리(Execute)하는
것이다. 각 스레드의 분할된 작업 처리가 끝나면 분할된 결과를 하나로 모아야(Join)한다.
이렇게 분할(Fork) -> 처리(Execute) -> 모음(Join) 의 단계로 이루어진 멀티스레딩 패턴을 Fork/Join 패턴 이라고 부른다.
이 패턴은 병렬 프로그래밍에서 매우 효율적인 방식으로, 복잡한 작업을 병렬적으로 처리할 수 있게 해준다.


== 분할(Fork) ==
큰 작업을 여러 작은 작업으로 쪼개어(Fork) 각각의 스레드나 작업 단위로 할당하는 것을 포크(Fork)라 한다.
참고로 포크라는 이름은 식당에서 사용하는 포크가 여러 갈래로 나뉘어 있는 모양을 떠올리면 된다.
이처럼 하나의 큰 작업을 여러 작업으로 분할하는 것을 포크라 한다.

== 처리(Execute) ==
분할된 각각의 작업을 처리하는 것

== 모음(Join) ==
분할된 작업들이 모두 끝나면, 각 스레드 혹은 작업 단위별 결과를 하나로 합쳐야한다.
Join은 이렇게 갈라진 작업들이 모두 끝난 뒤, 다시 합류하여 하나로 결과를 모으는 모습을 의미한다.

자바는 Fork/Join 프레임워크를 제공해서 개발자가 이러한 패턴을 더 쉽게 구현할 수 있도록 지원한다.

<Fork / Join 프레임워크>
자바의 Fork/Join 프레임워크는 자바 7부터 도입된 java.util.concurrent 패키지의 일부로,
멀티코어 프로세서를 효율적으로 활용하기 위한 병렬 처리 프레임워크이다.

== 분할 정복(Divide and Conquer) 전략 ==
- 큰 작업(task)을 작은 단위로 재귀적으로 분할(fork)
- 각 작은 작업의 결과를 합쳐(join) 최종 결과를 생성
- 멀티코어 환경에서 작업을 효율적으로 분산 처리

== 작업 훔치기(Work Stealing) 알고리즘 ==
- 각 스레드는 자신의 작업 큐를 가짐
- 작업이 없는 스레드는 다른 바쁜 스레드의 큐에서 작업을 훔쳐와서 대신 처리
- 부하 균형을 자동으로 조절하여 효율성 향상

== 주요 클래스 ==
Fork/Join 프레임워크를 이루는 주요 클래스
- ForkJoinPool
- ForkJoinTask
    - RecursiveTask
    - RecursiveAction

1) ForkJoinPool
- Fork/Join 작업을 실행하는 특수한 ExecutorService 스레드 풀
- 작업 스케줄링 및 스레드 관리를 담당
- 기본적으로 사용 가능한 프로세서 수 만큼 스레드 생성
  예) CPU 코어가 10 코어면 10개의 스레드 생성
- 분할 정복과 적업 훔치기에 특화된 스레드 풀이다.

// 기본 풀 생성 (프로세서 수에 맞춰 스레드 생성)
ForkJoinPool pool = new ForkJoinPool();

// 특정 병렬 수준으로 풀 생성
ForkJoinPool customPool = new ForkJoinPool(4);

2) ForkJoinTask
- ForkJoinTask는 Fork/Join 작업의 기본 추상 클래스다.
- Future를 구현했다.
- 개발자는 주로 다음 두 하위 클래스를 구현해서 사용한다.
    - RecursiveTask<V>: 결과를 반환하는 작업
    - RecursiveAction: 결과를 반환하지 않는 작업(void)

==  RecursiveTask / RecursiveAction의 구현 방법 ==
- compute() 메서드를 재정의해서 필요한 작업 로직을 작성한다.
- 일반적으로 일정 기준(임계값)을 두고, 작업 범위가 작으면 직접 처리하고, 크면 작업을 둘로 분할하여
  각각 병렬로 처리하도록 구현한다.

== fork() / join() 메서드 ==
- fork(): 현재 스레드에서 다른 스레드로 작업을 분할하여 보내는 동작(비동기 실행)
- join(): 분한된 작업이 끝날 때까지 기다린 후 결과를 가져오는 동작

※참고
Fork/Join 프레임워크를 실무에서 직접적으로 다루는 일은 드물다. 따라서 이런게 있다 정도만 알아두고
넘어가자. 개념 정도만 대략 알아두면 충분하다.

<Fork / Join 프레임워크 - 공용 풀>
자바 8에서는 공용 풀(Common Pool)이라는 개념이 도입되었는데, 이는 Fork/Join 작업을 위한 자바가
제공하는 기본 스레드 풀이다.

// 자바 8 이상에서는 공용 풀(common pool) 사용 가능
ForkJoinPool commonPool = ForkJoinPool.commonPool();

== Fork/Join 공용 풀의 특징 ==
- 시스템 전체에서 공유: 애플리케이션 내에서 단일 인스턴스로 공유되어 사용된다.
- 자동 생성: 별도로 생성하지 않아도 ForkJoinPool.commonPool()을 통해 접근할 수 있다.
- 편리한 사용: 별도의 풀을 만들지 않고도 RecursiveTask / RecursiveAction을 사용할 때 기본적으로
             이 공용 풀이 사용된다.
- 병렬 스트림 활용: 자바 8의 병렬 스트림은 내부적으로 이 공용 풀을 사용한다.
- 자원 효율성: 여러 곳에서 별도의 풀을 생성하는 대신 공용 풀을 사용함으로써 시스템 자원을 효율적으로
             관리할 수 있다.
- 병렬 수준 자동 설정: 기본적으로 시스템의 가용 프로세서 수에서 1을 뺀 값으로 병렬 수준(parallelism)이
                    설정된다.

Fork/Join 공용 풀은 쉽게 이야기해서, 개발자가 편리하게 Fork/Join 풀을 사용할 수 있도록 자바가 기본으로
제공하는 Fork/Join 풀의 단일 인스턴스이다.

* 정리
- 공용 풀은 JVM이 종료될 때까지 계속 유지되므로, 별도로 풀을 종료(shutdown())하지 않아도 된다.
- 이렇게 공용 풀(ForkJoinPool.commonPool)을 활용하면, 별도로 풀을 생성/관리하즌 코드를 작성하지
  않아도 간편하게 병렬 처리를 구현할 수 있다.

<자바 병렬 스트림>
병렬 스트림은 Fork/Join 공용 풀을 사용해서 병렬 연산을 수행한다.

스트림에서 parallel()를 선언하면 스트림은 공용 ForkJoinPool을 사용하고, 내부적으로 병렬 처리 가능한
스레드 숫자와 작업의 크기 등을 확인하면서, Spliterator를 통해 데이터를 자동으로 분할한다.
분할 방식은 데이터 소스의 특성에 따라 최적화되어 있다. 그리고 공용 풀을 통해 작업을 적절한 수준으로
분할(Fork), 처리(Execute)하고, 그 결과를 모은다(Join).

이 때 요청 스레드도 어차피 결과가 나올 때 까지 대기해야 하기 때문에, 작업에 참여해서 작업을 도운다.

개발자가 스트림을 병렬로 처리하고 싶다고 parallel()로 선언만 하면, 실제 어떻게 할지는 자바 스트림이
내부적으로 알아서 처리하는 것이다.
이것이 바로 람다 스트림을 활용한 선언적 프로그래밍 방식의 큰 장점이다.

== 병렬 스트림 사용시 주의점 ==
★주의사항 - Fork/Join 프레임워크는 CPU 바운드 작업에만 사용해라

I/O 작업처럼 블로킹 대기 시간이 긴 작업을 ForkJoinPool 에서 처리하면 다음과 같은 문제가 발생한다.
1. 스레드 블로킹에 따른 CPU 낭비
    - ForkJoinPool은 CPU 코어 수에 맞춰 제한된 개수의 스레드를 사용한다.(특히 공용 풀)
    - I/O 작업으로 스레드가 블로킹되면 CPU가 놀게 되어, 전체 병렬 처리 효율이 크게 떨어진다.
2. 컨텍스트 스위칭 오버헤드 증가
    - I/O 작업 때문에 스레드를 늘리면, 실제 연산보다 대기 시간이 길어지는 상황이 발생할 수 있다.
    - 스레드가 많아질수록 컨텍스트 스위칭(context switching) 비용도 증가하여 오히려 성능이 떨어질
      수 있다.
3. 작업 훔치기 기법 무력화
    - ForkJoinPool이 제공하는 작업 훔치기 알고리즘은, CPU 바운드 작업에서 빠르게 작업 단위를 계속 처리
      하도록 설계되었다. (작업을 훔쳐서 쉬는 스레드 없이 계속 작업)
    - I/O 대기 시간이 많은 작업은 스레드가 I/O로 인해 대기하고 있는 경우가 많아, 작업 훔치기가 빛을
      발휘하기 어렵고, 결과적으로 병렬 처리의 장점을 살리기 어렵다.
4. 분할-정복(작업 불할)이점 감소
    - Fork/Join 방식을 통해 작업을 잘게 나누어도, I/O 병목이 발생하면 CPU 병렬화 이점이 크게 줄어든다.
    - 오히려 분할된 작업들이 각기 I/O 대기를 반복하면서, fork(), join()에 따른 오버헤드만 증가할 수 있다.

* 정리
공용 풀(Common Pool)은 Fork/Join 프레임워크의 편리한 기능으로, 별도의 풀 생성 없이도 효율적인 병렬
처리를 가능하게 한다. 하지만 블로킹 작업이나 특수한 설정이 필요한 경우에는 커스텀 풀을 고려해야 한다.
- CPU 바운드 작업이라면 ForkJoinPool을 통해 병려려 계산을 극대화할 수 있지만, I/O 바운드 작업은
  별도의 전용 스레드 풀을 사용하는 편이 더 적합하다.
  예) Executors.newFixedThreadPool() 등등


★주의
- 실무에서 공용 풀은 절대 I/O 바운드 작업을 하면 안된다.
- 공용 풀은 반드시 CPU 바운드(계산 집약적인) 작업에만 사용해야 한다.

여러 작업을 병렬로 처리해야 하는데, I/O 바운드 작업이 많을 때, 스레드를 직접 사용하거나,
ExecutorService 등을 통해 별도의 스레드 풀을 사용해야 한다.




