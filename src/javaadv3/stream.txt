[스트림 API]

- 중간 연산(filter, map 등)은 데이터를 걸러내거나 형태를 변환한다.
- 최종 연산(toList(), forEach() 등)을 통해 최종 결과를 모으거나 실행할 수 있다.
- 스트림의 내부 반복을 통해, 어떻게 반복할지(for 루프, while 루프 등) 직접 신경 쓰기 보다는,
  결과가 어떻게 변환되어야 하는지에만 집중할 수 있다. 이런 특징을 선언형 프로그래밍 스타일이라 한다.
- 메서드 참조는 람다식을 더 간결하게 표현하며, 가독성을 높여준다.

핵심은 스트림에서 제공하는 다양한 중간 연산과 최종 연산을 통해 복잡한 데이터 처리 로직도 간단하고 선언적으로
구현할 수 있다는 점이다.

<스트림 API란>
== 정의 ==
- 스트림(Stream)은 자바 8부터 추가된 기능으로, 데이터의 흐름을 추상화해서 다루는 도구이다.
- 컬렉션(Collection) 또는 배열 등의 요소들을 연산 파이프라인을 통해 연속적인 형태로 처리할 수 있게 해준다.
  - 연산 파이프라인: 여러 연산(중간 연산, 최종 연산)을 체이닝해서 데이터를 변환, 필터링, 계산하는 구조

※용어 - 파이프라인
스트림이 여러 단계를 거쳐 변환되고 처리되는 모습이 마치 물이 여러 파이르(관)를 타고 이동하면서 정수 시설이나
필터를 거치는 과정과 유사하다. 각 파이프 구간마다(=중간 연산) 데이터를 가공하고, 마지막 종착지(=종료 연산)
까지 흐른다는 개념이 비슷하기 때문에 파이프라인 이라는 용어를 사용한다.

== 스트림의 특징 ==
1. 데이터 소스를 변경하지 않음(Immutable)
    - 스트림에서 제공하는 연산들은 원본 컬렉션을 변경하지 않고 결과만 새로 생성한다.
2. 일회성(1회 소비)
    - 한 번 사용(소비)된 스트림은 다시 사용할 수 없으며, 필요하다면 새로 스트림을 생성해야 한다.
3. 파이프라인(Pipeline) 구성
    - 중간 연산(map, filter 등)들이 이어지다가, 최종 연산(forEach, collect, reduce 등)을 만나면
      연산이 수행되고 종료된다.
4. 지연 연산(Lazy Operation)
    - 중간 연산은 필요할 때까지 실제로 동작하지 않고, 최종 연산이 실행될 때 한 번에 처리된다.
5. 병렬 처리(Parallel) 용이
    - 스트림으로부터 병렬 스트림(Parallel Stream)을 쉽게 만들 수 있어서, 멀티코어 환경에서 병렬 연산을
      비교적 단순한 코드로 작성할 수 있다.


<일괄 처리 vs 파이프라인>
== 일괄 처리(Batch Processing) 비유 ==
예시: 쿠키 공장
1. 반죽 공정: 반죽을 전부 만들어서 한쪽에 쌓아 둔다.
2. 굽기 공정: 쌓아 둔 반죽을 한꺼번에 오븐에 넣어 다 구워서 다시 쌓아 둔다.
3. 포장 공정: 구워진 쿠키들을 다시 한 번에 포장 기계로 몰아넣어 포장한다.

즉,
- 한 공정(반죽)을 모든 쿠키에 대해 다 끝내면,
- 그 다음 공정(굽기)도 모든 쿠키에 대해 일괄적으로 처리하고,
- 마지막에 포장 역시 모든 쿠키에 대해 한꺼번에 진행한다.

이것이 바로 일괄 처리 방식이다. 각 단계마다 결과물을 모아두고, 전체가 끝난 뒤에야 다음 단계로 넘긴다.
스트림 관점에서 비유하자면
- filter() (조건을 체크하는 작업)를 모든 데이터에 대해 적용(일괄 처리)하고,
- 그 결과를 한꺼번에 모아서, 그 다음에 map() (변환을 담당하는 작업)을 일괄 처리하는 모습이다.

== 파이프라인 처리(Pipeline Processing) 비유 ==
예시: 조립 라인이 있는 자동차 공장
1. 프레임 조립 담당: 차체 뼈대를 조립하면, 바로 다음 공정으로 넘긴다.
2. 엔진 장창 담당: 프레임이 오면 곧바로 엔진을 달아주고, 다음 공정으로 넘긴다.
3. 도색 담당: 엔진이 장착된 차체가 도착하면 즉시 도색을 하고, 다음 공정으로 보낸다.
4. ...(이후 공정들)
5. 출고: 모든 공정이 끝난 차는 즉시 공장에서 출하된다.

일괄 처리와 가장 큰 차이는, 일괄 처리는 모든 작업을 끝내고 다음 단계로 넘긴다면, 파이프라인 처리 방식은
하나의 작업이 처리되면 바로 다음 단계로 넘긴다는 점이다.

자바 스트림 관점에서 비유하자면
- filter() 공정을 통과하면, 해당 요소는 곧바로 map() 공정으로 이어지고,
- 최종 결과를 가져야 하는 시점(toList(), forEach(), findFirst() 등)이 되어서야 최종 출고를 한다.

* 정리
== 일괄 처리(Batch Processing) ==
- 공정(중간 연산)을 단계별로 쪼개서 데이터 전체를 한 번에 처리하고, 결과를 저장해두었다가 다음 공정을 또
  한 번에 수행한다.

== 파이프라인 처리(Pipeline Processing) ==
- 한 요소(제품)가 한 공정을 마치면, 즉시 다음 공정으로 넘어가는 구조이다.

두 결과 모두 결과는 같지만, 실제 실행 과정에서 차이가 있다.

핵심은 자바 스트림은 중간 단계에서 데이터를 모아서 한 방에 처리하지 않고, 한 요소가 중간 연산을 통과하면
곧 바로 다음 중간 연산으로 이어지는 파이프라인 형태를 가진다는 점이다.

<지연 연산>
자바 스트림은 toList()와 같은 최종 연산을 수행할 때만 작동한다.

자바 스트림은 최종 연산(toList(), forEach() 등)이 호출되지 않으면 아무 일도 하지 않는다.

중간 연산들은 '이런 일을 할 것이다'라는 파이프라인 설정을 해놓기만 하고, 정작 실제 연산은 최종 연산이
호출되기 전까지 전혀 진행되지 않는다.

스트림은 filter, map을 호출할 때 전달한 람다를 내부에 저장만 해두고 실행하지는 않는 것이다.
이후에 최종 연산(toList(), forEach() 등)이 호출되면 그때 각각의 항목을 꺼내서 저장해 둔 람다를
실행한다.

== 즉시 연산(Eager) ==
== 지연 연산(Lazy) ==
스트림 API는 매우 게으르다(Lazy). 정말 꼭 필요할 때만 연산을 수행하도록 최대한 미루고 미룬다.
그래서 연산을 반드시 수행해야 하는 최종 연산을 만나야 본인이 가지고 있던 중간 연산들을 수행한다.
이렇게 꼭 필요할 때 까지 연산을 최대한 미루는 것을 지연(Lazy) 연산이라 한다.

<지연 연산과 최적화>
자바의 스트림은 지연 연산, 파이프라인 방식 등 복잡하게 설계되어 있다. 왜 그럴까?
실제로 지연 연산과 파이프라인을 통해 어떤 최적화를 할 수 있는지 알아본다.

== 단축 평가(short-circuit) ==
- 지연 연산과 파이프라인 방식이 있기 때문에 가능한 최적화 중 하나이다.
- 필요할 때(또는 중간에 결과를 얻으면 종료해도 될 때)는 단축 평가를 통해 불필요한 연산을 건너 뛸 수 있다.


* 지연 연산 정리
스트림 API 에서 지연 연산(Lazy Operation, 게으른 연산)이란, filter, map 같은 중간 연산들은 toList와 같은
최종 연산(Terminal Operation)이 호출되기 전까지 실제로 실행되지 않는다는 의미이다.

- 즉, 중간 연산들은 결과를 바로 계산하지 않고, 무엇을 할지에 대한 설정만 저장해 둔다.
    쉽게 말해 람다 함수만 내부에 저장해두고, 해당 함수를 실행하지는 않는다.
- 그리고 최종 연산이 실행되는 순간, 그때서야 중간 연산이 순차적으로 한 번에 수행된다.(저장해둔 람다들을 실행한다.)

== 지연 연산의 장점 ==
1. 불필요한 연산의 생략(단축, Short-Circuiting)
    - 스트림이 실제로 데이터를 처리하기 직전에, 이후 연산 중에 어차피 건너뛰어도 되는 부분을 알아내 불필요한
      연산을 피할 수 있게 한다.
2. 메모리 사용 효율
    - 중간 연산 결과를 매 단계마다 별도의 자료구조에 저장하지 않고, 최종 연산 때까지 필요할 때만 가져와서 처리한다.
3. 파이프라인 최적화
    - 스트림은 요소를 하나씩 꺼내면서(=순차적으로) filter, map 등 연산을 묶어서 실행할 수 있다.

스트림 API의 핵심은 어떤 연산을 할지 파이프라인으로 정의해놓고, 최종 연산이 실행될 때 한 번에 처리한다
이를 통해 필요한 시점에만 데이터를 처리하고, 필요 이상으로 처리하지 않는다는 효율성을 얻을 수 있다.