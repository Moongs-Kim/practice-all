부모 클래스는 자식 클래스에 접근할 수 없다.

상속과 메모리 구조(중요)
설명을 위해 Car(부모 클래스) ElectricCar(자식 클래스) 있다고 가정
ElectricCar를 생성하면 상속 관계에 있는 Car까지 함께 포함해서 인스턴스를 생성한다.
참조값은 하나이지만 실제로 그 안에서는 부모, 자식 두 가지 클래스 정보가 공존한다.
외부에서 볼때는 하나의 인스턴스를 생성하는 것 같지만, 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.

[자식 인스턴스 + 자식타입 변수]
상속 관계에서는 자식 타입에 해당 기능이 없으면 부모 타입으로 올라가서 찾는다.
만약 부모에서도 해당 기능을 찾지 못하면 더 상위 부모에서 필요한 기능을 찾아본다.

상속과 메모리 구조는 반드시 이해해야 한다!
-상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
-상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
-현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.

상속 관계 덕분에 중복은 줄어들고, 새로운 자식 클래스를 편리하게 확장할 수 있다.

[상속과 메서드 오버라이딩]
부모의 메서드를 자식이 새로 재정의하는것

오버라이딩과 메모리 구조 (자식 인스턴스 + 자식타입 변수)
자식타입 변수로 오버라이딩한 메서드를 호출한다. 자식 타입에 해당 메서드가 있으므로 해당 메서드를 실행한다.
이미 메서드를 찾았으므로 부모 타입을 찾지 않는다.

메서드 오버라이딩 조건(7개)
-메서드 이름
-메서드 매개변수
-반환 타입
-접근제어자
-예외
-static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
-생성자는 오버라이딩 할 수 없다.

[상속시 생성자]
상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.
상속을 받으면 생성자의 첫줄에 super(...)를 사용해서 부모 클래스의 생성자를 호출해야 한다.
예외로 생성자 첫줄에 this(...)를 사용할 수 있다. 하지만 super(...)는 자식의 생성자 안에서 언젠가는 반드시 호출해야 한다.
부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우에는 super(...)를 생략할 수 있다.(자바가 자동 생성해줌)

생성자의 실행 순서가 결과적으로 최상위 부모부터 실행되어서 하나씩 아래로 내려오는 것이다. 즉 부모의 데이터를 먼저 초기화함

클래스에 final -> 상속 끝
final로 선언된 클래스는 확장될 수 없다. 다른 클래스가 final로 선언된 클래스를 상속받을 수 없다.
예 : public final class MyFinalClass{}

메서드에 final -> 오버라이딩 끝
final로 선언된 메서드는 오버라이드 될 수 없다. 상속받은 서브 클래스에서 이 메서드를 변경할 수 없다.
예 : public final void myFinalMethod() {}

