[예외 처리]

예외도 객체이다. 따라서 필요한 필드와 메서드를 가질 수 있다.

<finally>
자바는 어떤 경우라도 반드시 호출되는 finally 기능을 제공한다.

try, catch 안에서 잡을 수 없는 예외가 발생해도 finally 는 반드시 호출된다.

★finally 코드 블럭이 끝나고 나서 이후에 예외가 밖으로 던져진다.
 catch 에서 잡을 수 없는 예외가 발생해서, 예외를 밖으로 던지는 경우에도
 finally를 먼저 호출하고 나서 예외를 밖으로 던진다.

주로 try 에서 사용한 자원을 해제할 때 사용한다.

<try ~ finally>
catch 없이 try ~ finally 만 사용할 수도 있다.
예외를 직접 잡아서 처리할 일이 없다면 이렇게 사용하면 된다.
이렇게 하면 예외를 밖으로 던지는 경우에도 finally 호출이 보장된다.

* 정리
자바 예외 처리는 try ~ catch ~ finally 구조를 사용해서 처리할 수 있다.
- 정상 흐름과 예외 흐름을 분리해서, 코드를 읽기 쉽게 만든다.
- 사용한 자원을 항상 반환할 수 있도록 보장해 준다.

<예외 계층>
- 자바에서 예외는 객체이다. 따라서 부모 예외를 잡거나 던지면, 자식 예외도 함께 잡거나 던질 수 있다.
- 특정 예외를 잡아서 처리하고 싶으면 하위 예외를 잡아서 처리하면 된다.
- 예외 클래스를 각각의 예외 상황에 맞추어 만들면, 각 필요에 맞는 예외를 잡아서 처리할 수 있다.
  예외 클래스가 가지는 고유의 기능을 활용할 수 있다.
- 하지만 모든 예외를 하나하나 다 잡아서 처리하는 것은 상당히 번거롭다.
  예외의 중요도를 나눠 중요한건 별도로 잡아서 처리하고, 중요하지 않은것은 상위 클래스로 잡아 처리하면 좋다.

<여러 예외를 한번에 잡는 기능(문법)>
' | '를 사용해서 여러 예외를 한번에 잡을 수 있다.

try {
    ~~
    ~~
} catch (Exception1 | Exception2 e) {

}
위와 같은 문법은 예외들(Exception1, Exception2)의 공통 부모의 기능만 사용할 수 있다.
최상위 부모는 Exception 이기 때문에
따로 작성된 공통 부모가 없다면 Exception 클래스 기능만 공통 사용가능하겠다

* 정리
- 예외를 계층화하고 다양하게 만들면 더 세밀한 동작들을 깔끔하게 처리할 수 있다.
- 특정 분류의 공통 예외들은 한번에 catch로 잡아서 처리할 수 있다.

<실무 예외 처리 방안1>
- 시스템 오류 등과 같은 문제로 발생한 예외들은 대부분 예외를 잡아도 해결할 수 있는 것이 거의 없다.
  이런경우 오류 메세지를 보여주고, 오류에 대한 로그를 남겨두도록 한다.

== 체크 예외의 부담 ==
체크 예외는 개발자가 실수로 놓칠 수 있는 예외들을 컴파일러가 체크해주기 때문에 오래전부터 많이 사용되었다.
그런데 위에 작성한 것 처럼 처리할 수 없는 예외가 많아지고, 또 프로그램이 점점 복잡해지면서 체크 예외를 사용하는 것이
점점 더 부담스러워 졌다.

중간 모든 클래스에서 예외를 계속 던지는 지저분한 코드가 만들어진다.
개발자는 본인이 다룰 수 없는 수 많은 체크 예외 지옥에 빠지게 된다.

== throws Exception 의 문제 ==
Exception은 최상위 타입이므로 모든 체크 예외를 다 밖으로 던지는 문제가 발생한다.
- Exception을 던지게 되면 다른 체크 예외를 체크할 수 있는 기능이 무효화 되고
  중요한 체크 예외를 다 놓치게 된다. 중간에 중요한 체크 예외가 발생해도 컴파일러는 Exception을 던지기
  때문에 문법에 맞다고 판단해서 컴파일 오류가 발생하지 않는다.
  따라서 꼭 필요한 경우가 아니라면 Exception 자체를 밖으로 던지는 것은 좋지 않은 방법이다.

* 문제 정리
- 처리할 수 없는 예외: 예외를 잡아서 복구할 수 있는 예외보다 복구할 수 없는 예외가 더 많다.
- 체크 예외의 부담: 처리할 수 없는 예외는 밖으로 던져야 한다. 체크 예외이므로 throws에 던질 대상을
                  일일이 명시해야 한다.

본인이 해결할 수 있는 예외만 잡아서 처리하고, 본인이 해결할 수 없는 예외는 신경쓰지 않는 것이 더 나은 선택일 수 있다.

== 언체크(런타임) 예외 사용 ==
언체크 예외는 throws를 선언하지 않아도 된다. 선언이 없으면 자동으로 밖으로 던진다.
본인이 필요한 예외만 잡으면 되고, throws를 늘리지 않아도 된다.

== 예외 공통 처림★ ==
처리할 수 없는 예외들은 중간에 여러곳에서 나누어 처리하기 보다는
예외를 공통으로 처리할 수 있는 곳을 만들어서 한 곳에서 해결하면 된다.
해결할 수 없는 예외들이기 때문에 고객에게 메세지를 보내고, 개발자가 문제 상황을 빠르게 인지할 수 있도록
오류에 대한 로그를 남겨두면 된다.
이런 방식으로 해결할 수 없는 예외 보다는 본인 스스로의 코드에 더 집중할 수 있다.
따라서 코드가 깔끔해진다.

<실무 예외 처리 방안2>
- Exception을 잡아서 해결하지 못한 모든 예외를 공통으로 처리한다.
- 예외도 객체이므로 공통 처리 메서드를 만들어 예외 객체를 전달한다.
- 예외도 객체이므로 필요시 공통 처리 메서드에서 instanceof 등으로 예외 객체 타입을 확인해서
  해당 객체에 대한 별도의 추가 처리를 할 수 있다.

<try-with-resources>
try 에서 외부 자원을 사용하고, try 가 끝나면 외부 자원을 반납하는 패턴이 반복되면서
자바에서는 Try with resources 라는 편의 기능을 자바 7에서 도입했다.
이름 그대로 try 에서 자원을 함께 사용한다는 뜻이다.
여기서 자원은 try 가 끝나면 반드시 종료해서 반납해야 하는 외부 자원을 뜻한다.

- try-with-resources 기능을 사용하려면 먼저 AutoCloseable 인터페이스를 구현해야 한다.
- AutoCloseable 인터페이스를 구현하면 try-with-resources를 사용할 때
  ★'try가 끝나는 시점에 close()가 자동으로 호출'된다.
- close(): AutoCloseable 인터페이스가 제공하는 이 메서드는 'try가 끝나면 자동으로 호출'된다.
           종료 시점에 자원을 반납하는 방법을 이 메서드에 작성하면 된다.
- 당연히 예외가 발생해 try를 벗어난것도 마찬가지로 try를 빠져나간것이므로 close()가 자동으로 호출된다.


== try-with-resources 장점 ==
- 리소스 누수 방지: 모든 리소스가 제대로 닫히도록 보장한다. 실수로 finally 블록을 적지 않거나,
                 finally 블럭 안에서 자원 해제 코드를 누락하는 문제들을 예방할 수 있다.
- 코드 간결성 및 가독성 향상: 명시적인 close() 호출이 필요 없어 코드가 더 간결하고 읽기 쉬워진다.
- 스코프 범위 한정: 리소스로 사용되는 변수의 스코프가 try 블럭 안에서 한전되는 문제가 없다.
                 따라서 코드 유지보수가 더 쉬워진다.
- 조금 더 빠른 자원 해제: 기존에는 try -> catch -> finally로 catch 이후에 자원을 반납했다.
                      try-with-resources 구문은 try 블럭이 끝나면 즉시 close()를 호출한다.

※참고
try-with-resources 에서 catch 블럭은 없어도 된다.
catch 블럭 없이 try 블럭만 있어도 close()는 호출된다.

※참고 - 예외에관한 오버라이딩 규칙
오버라이딩한 메서드는 ★원래 선언된 예외보다 더 좁은 범위의 예외만 던질 수 있다.★

== Exception을 던지는 인터페이스 메서드를 구현할 때 ==
- Exception 보다 좁은 예외(예: IOException)로 줄일 수 있다.
- ★아예 예외를 던지지 않아도 된다.
- 부모가 던지지 않는 체크 예외를 자식이 선언해서는 안된다.(예:Runnable 인터페이스의 run() 메서드)

========================================================================
인터페이스 선언	                                구현체 메서드에서 가능 여부
void method() throws Exception;	                ✔ void method()
void method();	                                ❌ void method() throws Exception
void method() throws IOException;	            ✔ void method() throws FileNotFoundException
void method() throws Exception;	                ✔ void method() throws IOException
void method() throws Exception;                 ✔ void method() throws Exception


<마무리 예외 정리>
- 체크 예외는 잡을 건 잡고 던질 예외는 명확하게 던지도록 선언해야 한다.
- 런타임 예외도 필요하면 잡을 수 있기 때문에 필요한 경우에는 잡아서 처리하고
  그렇지 않으면 자연스럽게 던지도록 둔다.
- 처리할 수 없는 예외는 예외를 공통으로 처리하는 부분을 만들어서 해결하면 된다.
