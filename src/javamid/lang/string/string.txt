String은 클래스다

<String 클래스와 참조형>
String str1 = "hello";
str1 변수에는 String 인스턴스의 참조값만 들어갈 수 있다. 따라서 위 코드는 어색하다.

문자열은 매우 자주 사용된다. 따라서 편의상 쌍따옴표로 문자열을 감싸면
자바 언어에서 new String("hello")와 같이 변경해준다.
(이 경우 실제로는 성능 최적화를 위해 문자열 풀을 사용하는데, 이 부분은 뒤에서 설명한다.)

String은 기본형이 아니라 참조형이다. 참조형은 참조값이 들어있어 원칙적으로 + 같은 연산을 사용할 수 없다.
하지만 문자열은 너무 자주 다루어지기 때문에 자바 언어에서 편의상 특별히 + 연산을 제공한다.

<String 클래스 - 비교>
String 클래스는 비교할 때 == 비교가 아니라 항상 equals() 비교를 해야한다.
String 클래스는 내부 문자열 값을 비교하도록 equals() 메서드를 재정의 해두었다.
- 동일성(Identity) : == 연산자를 사용해서 두 객체의 참조가 '동일한 객체를 가리키고 있는지' 확인
- 동등성(Equality) : equals() 메서드를 사용하여 두 객체가 '논리적'으로 같은지 확인

문자열 풀
- String str = "hello" 와 같이 '문자열 리터럴'을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해
'문자열 풀'을 사용한다.
- 자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 String 인스턴스를 미리 만들어둔다.
  이때 같은 문자열이 있으면 만들지 않는다. (같은 문자열 리터럴 -> 문자열 풀에 만듦 + 중복해서 만들지 않음)
  EX) String str1 = "hello" 와 같이 문자열 리터럴을 사용하면 문자열 풀에서 "hello"라는 문자를 가진
      String 인스턴스를 찾는다. 그리고 찾은 인스턴스의 참조값(x001)을 반환한다.
      String str2 = "hello" 의 경우 "hello" 문자열 리터럴을 사용하므로 문자열 풀에서 str1과 같은
      x001 참조를 사용한다.
- 문자열 풀 덕분에 같은 문자를 사용하는 경우 메모리 사용을 줄이고 문자를 만드는 시간도 줄어들기 때문에
  성능도 최적화 할 수 있다.

  따라서 문자열 리터럴을 사용하는 경우 같은 참조값을 가지므로 == 비교에 성공한다.

<참고>
풀(pool)은 자원이 모여있는 곳을 의미한다. 문자열 풀은 힙 영역을 사용한다.
그리고 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른 속도로 원하는 String 인스턴스를
찾을 수 있따.

<String 클래스 - 불변 객체>
String은 불변 객체이다. 따라서 변경이 필요한 경우 기존 값을 변경하지 않고
대신에 새로운 결과를 만들어서 반환한다.

<String이 불변으로 설계된 이유>
String은 자바 내부에서 문자열 풀을 통해 최적화를 한다.
문자열 풀에 있는 String 인스턴스의 값이 중간에 변경되면 같은 문자열을 참고하는 다른 변수의 값도 함께 변경된다.
String 클래스는 불변으로 설계되어서 이런 사이드 이펙트 문제가 발생하지 않는다.

<참고>
CharSequence는 String, StringBuilder의 상위 타입이다.
문자열을 처리하는 다양한 객체를 받을 수 있다.

<StringBuilder - 가변 String>
- 불변인 String 클래스의 단점
  불변인 String의 내부 값은 변경할 수 없다. 따라서 변경된 값을 기반으로 새로운 String 객체를 생성한다.
  문자를 자주 더하거나 변경해야 하는 상황이라면 더 많은 String 객체를 만들고, GC해야 한다.
  결과적으로 컴퓨터의 CPU, 메모리 자원을 더 많이 사용하게 된다. 그리고 문자열의 크기가 클수록, 문자열을 더
  자주 변경할 수록 시스템의 자원을 더 많이 소모한다.
  * 실제로는 문자열을 다룰 때 자바가 내부에서 최적화를 적용하는데 이 부분은 뒤에서 다룬다.

이 문제를 해결하는 방법은 단순하다. 불변이 아닌 가변 String이 존재하면 된다.
이런 문제를 해결하기 위해 자바는 StringBuilder라는 가변 String을 제공한다.
물론 가변의 경우 사이드 이펙트에 주의해서 사용해야 한다.

StringBuilder는 내부에 final이 아닌 변경할 수 있는 byte[]을 가지고 있다.

<String 최적화>
자바의 String 최적화

- 문자열 리터럴 최적화
  컴파일 전 : String helloWorld = "Hello, " + "World!";
  컴파일 후 : String helloWorld = "Hello, World!";
  자바 컴파일러는 다음과 같이 문자열 리터럴을 더하는 부분을 자동으로 합쳐준다.
  따라서 런타임에 별도의 문자열 결합 연산을 수행하지 않기 때문에 성능이 향상된다.
- String 변수 최적화
  String result = str1 + str2;
  문자열 변수의 경우 그 안에 어떤 값이 들어있는지 컴파일 시점에는 알 수 없기 때문에 단순하게 합칠 수 없다.
  이런 경우 예를 들면 다음과 같이 최적화를 수행한다. (최적화 방식은 자바 버전에 따라 달라진다.)
  String result = new StringBuilder().append(str1).append(str2).toString();
  참고: 자바 9부터는 StringConcatFactory를 사용해서 최적화를 수행한다.

이렇듯 자바가 최적화를 처리해주기 때문에 지금처럼 간단한 경우에는
신에 문자열 더하기 연산(+)을 사용하면 충분하다.

<String 최적화가 어려운 경우>
- 반복문 안
  반복문 안에서 문자열을 더하는 경우에는 최적화가 이루어지지 않는다.
  -> 반복문 내의 문자열 연결은 런타임시 결정되어 컴파일러가 얼마나 반복이 일어날지 알 수 없어 최적화를 할 수 없다.
  이럴 때는 직접 StringBuilder를 사용하면 된다.

<정리>
문자열을 합칠 때 대부분의 경우 최적화가 되므로 + 연산을 사용하면 된다.

** StringBuilder를 직접 사용하는 것이 더 좋은 경우 **
- 반복문에서 반복해서 문자를 연결할 때
- 조건문을 통해 동적으로 문자열을 조합할 때
- 복잡한 문자열의 특정 부분을 변경해야 할 때
- 매우 긴 대용량 문자열을 다룰 때

<메서드 체이닝 - Method Chaining>
메서드 호출의 결과로 자기 자신의 참조값을 반환하면, 반환된 참조값을 사용해서 메서드 호출을 계속 이어갈 수 있다.
.을 찍고 메서드를 계속 연결해서 사용한다. 마치 메서드가 체인으로 연결된 것 처럼 보인다.
이러한 기법을 메서드 체이닝이라 한다.

메서드 체이닝 방식은 메서드가 끝나는 시점에 바로 .을 찍어서 변수명을 생략할 수 있다.
메서드 체이닝이 가능한 이유는 자기 자신의 참조값을 반환하기 때문이다. 이 참조값에 .을 찍어서 바로 자신의
메서드를 호출할 수 있다.

'메서드 체이닝 기법은 코드를 간결하고 읽기 쉽게 만들어준다.'

<StringBuilder와 메서드 체인>
StringBuilder는 메서드 체이닝 기법을 제공한다.
StringBuilder에서 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 자기 자신을 반환한다.
EX) str.append().append().append() ...
    x001.append().append().append()
    x001.append().append()
    x001.append()

<정리>
'만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다'
메서드 체이닝은 구현하는 입장에서는 번거롭지만 사용하는 개발자는 편리해진다.
참고로 자바의 라이브러리와 오픈 소스들은 체이닝 방식을 종종 사용한다.






