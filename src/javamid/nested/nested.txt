[중첩 클래스]

<중첩 클래스의 분류>
중첩 클래스는 클래스를 정의하는 위치에 따라 분류한다.

중첩 클래스는 총 4가지가 있고, 크게 2가지로 분류할 수 있다.

- non-static : 바깥 인스턴스 소속
    내부 클래스(inner class) : 인스턴스 변수와 같이 앞에 static이 붙지 않는다.
    지역 클래스(local class) : 지역 변수와 같이 코드 블럭 안에서 클래스를 정의한다.
    익명 클래스(anonymous class)

- static : 전혀 다른 인스턴스
    정적 중첩 클래스(static nested class) : 정적 변수와 같이 앞에 static이 붙는다.

중첩 클래스를 정의하는 위치는 변수의 선언 위치와 같다.
- 변수의 선언 위치 및 중첩 클래스의 선언 위치
    정적 변수(클래스 변수) -> 정적 중첩 클래스
    인스턴스 변수 -> 인스턴스 변수와 같은 위치
    지역 변수 -> 지역 변수와 같은 위치

== 중첩이라는 단어와 내부라는 단어의 차이 ==
중첩(Nested): 어떤 다른 것이 내부에 위치하거나 포함되는 구조적인 관계
내부(Inner): 나의 내부에 있는 나를 구성하는 요소

중첩(Nested)은 나의 안에 있지만 내것이 아닌 것을 말한다.
단순히 위치만 안에 있는 것이다.

내부(Inner)는 나의 내부에서 나를 구성하는 요소를 말한다.

ex) 큰 나무 상자안에 전혀 다른 작은 나무 상자를 넣은 것은 중첩(Nested)이라 한다.
    나의 심장은 나의 내부(Inner)에서 나를 구성하는 요소이다.

* 정리
정적 중첩 클래스는 바깥 클래스의 안에 있지만 바깥 클래스와 관계 없는 전혀 다른 클래스
내부 클래스는 바깥 클래스의 내부에 있으면서 바깥 클래스를 구성하는 요소

★핵심은 바로 바깥 클래스 입장에서 볼 때 안에 있는 클래스가 나의 인스턴스에
소속이 되는가 되지 않는가의 차이이다.
- 정적 중첩 클래스는 바깥 클래스와 전혀 다른 클래스이다. 따라서 바깥 클래스의 인스턴스에 소속되지 않는다.
- 내부 클래스는 바깥 클래스를 구성하는 요소이다. 따라서 바깥 클래스의 인스턴스에 소속된다.

한마디로 정리하면
내부 클래스들은 바깥 클래스의 인스턴스에 소속된다. 정적 중첩 클래스는 그렇지 않다.

== 내부 클래스의 종류 ==
- 내부 클래스(inner class) : 바깥 클래스의 인스턴스의 멤버에 접근
- 지역 클래스(local class) : 내부 클래스의 특징 + 지역 변수에 접근
- 익명 클래스(anonymous class) : 지역 클래스의 특징 + 클래스의 이름이 없는 특별한 클래스

* 용어 정리
- 중첩 클래스: 정적 중첩 클래스 + 내부 클래스 종류 모두 포함
- 정적 중첩 클래스: 정적 중첩 클래스를 말함
- 내부 클래스: 내부 클래스, 지역 클래스, 익명 클래스를 포함해서 말함

※참고: 실무에서는 중첩, 내부라는 단어를 명확히 구분하지 않고, 중첩 클래스 또는 내부 클래스라고 한다.

== 중첩 클래스는 언제 사용해야 하나★ ==
내부 클래스를 포함한 모든 중첩 클래스는 특정 클래스가 다른 하나의 클래스 안에서만 사용되거나,
둘이 아주 긴밀하게 연결되어 있는 특별한 경우에만 사용해야 한다.
외부의 여러 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다.

== 중첩 클래스를 사용하는 이유★ ==
- 논리적 그룹화: 특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우 해당 클래스 안에 포함하는 것이
               논리적으로 더 그룹화 된다. 패키지를 열었을 때 다른 곳에서 사용될 필요가 없는 중첩 클래스가
               외부에 노출되지 않는 장점도 있다.
- 캡슐화: 중첩 클래스는 바깥 클래스의 private 멤버에 접근할 수 있다. 이렇게 해서 둘을 긴말하게 연결하고
         불필요한 public 메서드를 제거할 수 있다.


== 정적 중첩 클래스 ==
- 자신의 멤버에는 당연히 접근할 수 있다.
- 바깥 클래스의 인스턴스 멤버에는 접근할 수 없다. 바깥 인스턴스의 참조가 없기 때문이다.(외부 클래스의 인스턴스를 참조하지 않는다)
- 바깥 클래스의 클래스 멤버에는 접근할 수 있다.

* 정적 중첩 클래스는 외부 클래스의 static 멤버만 접근 가능
* static 중첩 클래스는 외부 클래스의 인스턴스에 종속되지 않는 클래스

NestedOuter.outClassValue 를 outClassValue 와 같이 줄여서 사용해도 된다.
이 경우 바깥 클래스에 있는 필드를 찾아서 사용한다.

private 접근 제어자는 같은 클래스 안에 있을 때만 접근할 수 있다.
중첩 클래스도 바깥 클래스와 같은 클래스 안에 있다.
따라서 중첩클래스는 바깥 클래스의 private 접근 제어자에 접근할 수 있다.

- 정적 중첩 클래스는 'new 바깥클래스.중첩클래스()'로 생성할 수 있다.
- 중첩 클래스는 'NestedOuter.Nested'와 같이 '바깥클래스.중첩클래스' 로 접근할 수 있다
  참고로 new NestedOuter() 로 만든 바깥 클래스의 인스턴스와
  new NestedOuter.Nested()로 만든 정적 중첩 클래스의 인스턴스는 서로 아무 관계가 없는 인스턴스이다.
  단지 클래스 구조상 중첩해 두었을 뿐이다.
  둘이 아무런 관련이 없으므로 정적 중첩 클래스의 인스턴스만 따로 생성해도 된다.

  정적 중첩 클래스(static class)도 메서드 영역에 클래스 정의(설계도)는 올라가지만,
  인스턴스는 여전히 new 키워드로 만들어야 한다.

- 중첩 클래스의 이름은 'NestedOuter$Nested' 와 같이 '바깥클래스, $, 중첩 클래스'의 조합으로 만들어 진다.

* 정리
정적 중첩 클래스는 다른 클래스를 그냥 중첩해 둔 것일 뿐이다! 둘은 아무런 관계가 없다.
쉽게 말해 다음과 같이 정적 중첩 클래스를 만들지 않고, 그냥 클래스 2개를 따로 만든것과 같다.
class NestedOuter {
}

class Nested {
}

위 코드와 정적 중첩 클래스의 유일한 차이는 같은 클래스에 있으니
private 접근 제어자에 접근할 수 있다는 정도이다.

private static class로 만들면 외부에서 new 외부.내부() 로 접근할 수 없다.

★중첩 클래스(내부 클래스 포함)는 용도가 자신이 소속된 바깥 클래스 안에서 사용되는 것이다.
따라서 자신이 소속된 바깥 클래스가 아닌 외부에서 생성하고 사용하고 있다면, 이미 중첩 클래스의 용도에
맞지 않을 수 있다. 이때는 중첨 클래스를 밖으로 빼는 것이 더 나은 선택이다.

※ static
클래스 정보는 메서드 영역, 객체는 힙 영역
클래스가 static 이든 아니든 객체를 만들려면 new가 필요하다.
static 클래스는 내부 클래스에만 붙일 수 있다. (외부 클래스에는 불가)

static은 **"인스턴스에 종속되지 않는 것"**을 의미, 객체 생성 방식과는 무관
-> 클래스 변수, 클래스 메서드, 그리고 static 중첩 클래스가 이에 해당

static 내부 클래스는 외부 클래스 인스턴스 없이 바로 생성 가능
일반 내부 클래스는 외부 클래스 인스턴스가 있어야 생성 가능

- 오해
static 이면 객체도 자동으로 하나 만들어져서 공유된다.
-> static class는 클래스 로딩 시 메서드 영역에 클래스 정보가 올라가는 것이지, 객체가 거기에 만들어진다는 뜻이 아니다.
   클래스 정보만 메서드 영역에 올라간다. 객체는 여전히 new로 생성해야 한다.

static은 메모리 아끼려고 쓰는 것이다.
-> 메모리 절약보다는 '인스턴스와 무관한 속성'을 표현하는 것.
   (다만 일부 케이스에서 메모리 최적화 효과는 있음)

필드나 메서드에 static을 사용하면 클래스 정보만으로 접근할 수 있는 것처럼
static class는 외부 객체 생성 없이 내부 객체를 생성할 수 있다.

private static class는 외부 클래스 내부에서만 접근 가능 -> 외부 클래스 전용 도우미 클래스
외부 클래스가 속한 패키지의 다른 클래스나 외부에서는 접근할 수 없음

클래스 정보(static 필드, static 메서드, static 내부 클래스, static 블록)는 전부 메서드 영역

"클래스 로드 시"란, 무조건 프로그램 시작 시가 아니다.
그 클래스가 처음으로 필요해지는 순간 로드된다.
필요 없으면 아예 로드되지 않을 수도 있다.

★static 에서 예시 상황 가정
Outer라는 클래스 안에 static class Inner 라는 클래스가 있다

new Outer.Inner()를 사용하면 어떤 클래스가 로딩 되는가?
-> Outer가 로드되는 건가, Inner가 로드되는 건가?

- 결론
Outer.Inner 클래스 정보가 별도로 로드된다.
즉, Outer와 Outer.Inner는 각각 독립적으로 클래스 로드 대상이다.
왜냐하면 자바 컴파일러와 JVM은 중첩 클래스를 따로 다루기 때문이다.

Outer라는 클래스 안에 static class Inner 라는 클래스 상황에서
코드를 컴파일하면 두 개의 .class 파일이 생성된다.
Outer.class : 외부 클래스 정보
Outer$Inner.clas: static 중첩 클래스 정보
JVM 입장에서느 서로 다르 두 개의 클래스 이다.
각각 독립적인 클래스 로딩 대상이다.
하지만 static 여부와 관계없이, 중첩 클래스는 .class 파일이 별도로 생긴다.
static 여부는 메모리 구조/접근 방식/생성 방법의 차이지, .class 생성 여부와는 관계없다.
이 내용은 헷갈릴 수 있으나 정리하자면
- 내부 클래스는 static 여부와 상관없이 모두 별도의 .class 파일로 분리된다.
- static 여부는 메모리 구조/접근 방식/생성 방법의 차이
이 정도만 정리하고 넘어가자

static class Inner는 Outer 클래스의 **중첩된 "논리적 소속"**은 맞지만,
JVM 메모리나 클래스 로딩 관점에서는 별개의 독립 클래스이다.

Outer.Inner를 new 하는 순간 Outer$Inner.class가 로드된다.
반드시 그 전에 Outer.class가 로드될 필요는 없다.
단, 코드상 Outer에 먼저 접근했다면 Outer.class도 로드된다.
두 클래스는 JVM에서 별도의 .class 파일로 관리되고, 독립적으로 메서드 영역에 올라간다.

- static 필드/메서드 vs static class
static 필드/메서드 = "공용 변수/공용 기능"
static 클래스 = "공용 도우미 설계도"

둘 다 "클래스 단위"라는 공통점은 있지만,
하나는 데이터/기능, **다른 하나는 구조(클래스 자체)**를 위한 용도

static은 **"인스턴스에 의존하지 않는다"**는 공통 개념이지만,
static 필드/메서드는 공통 데이터와 기능을 의미하고,
static class는 독립적이고 정적인 내부 클래스 정의입니다.
따라서 둘은 용도와 역할이 다릅니다.

static class 내부에서 외부 클래스의 static 변수/메서드에 접근하면 외부 클래스도 로드된다.
★클래스에 관한 것을 사용할때 해당 클래스 정보가 로드된다. 이때 클래스 정보, static 변수/메서드 등 로드

- 나만의 정리★
static 중첩 클래스는 외부 클래스의 인스턴스 없이도 생성하고 사용할 수 있도록 static 키워드를 붙인 것이다.
(단, static 필드/메서드처럼 "클래스 정보에 바로 접근하는 것"과는 다르다 — 객체는 new로 직접 생성해야 한다.)
컴파일과 실행 시에는 외부 클래스와는 독립적인 클래스로 처리된다.

★핵심 : static class: 외부 객체 없이 생성가능(static 특성), 외부 인스턴스와 독립적 의미 제공
                      static class와 non-static class의 차이는 메모리 구조/접근 방식/생성 방법의 차이

== 내부 클래스 ==
정적 중첩 클래스는 바깥 클래스와 서로 관계가 없다. 하지만 내부 클래스는 바깥 클래스의 인스턴스를 이루는 요소가 된다.
쉽게 말해 내부 클래스는 바깥 클래스의 인스턴스에 소속된다.

- 자신의 멤버에는 당연히 접근할 수 있다.
- 바깥 클래스의 인스턴스 멤버에 접근할 수 있다.
- 바깥 클래스의 클래스 멤버에 접근할 수 있다.

private 접근 제어자
- private 접근 제어자는 같은 클래스 안에 있을 때만 접근할 수 있다.
- 내부 클래스도 바깥 클래스와 같은 클래스 안에 있다. 따라서 내부 클래스는 바깥 클래스의
  private 접근 제어자에 접근할 수 있다.

  생성
- 내부 클래스는 바깥 클래스의 인스턴스에 소속된다. 따라서 바깥 클래스의 인스턴스 정보를 알아야 생성할 수 있다.
- 내부 클래스는 '바깥클래스의 인스턴스 참조.new 내부클래스()'' 로 생성할 수 있다.
    바깥 클래스의 인스턴스 참조가 필요, outer.new Inner() 에서 outer 는 바깥 클래스의 인스턴스 참조를 가진다.
- outer.new Inner()로 생성한 내부 클래스는 개념상 바깥 클래스의 인스턴스 내부에 생성된다.
- 따라서 바깥 클래스의 인스턴스를 먼저 생성해야 내부 클래스의 인스턴스를 생성할 수 있다.
- 실제로 내부 인스턴스가 바깥 인스턴스 안에 생성되는 것은 아니다. 하지만 개념상 인스턴스 안에 생성된다고
  이해하면 충분하다.
- 실제로는 내부 인스턴스는 바깥 인스턴스의 참조를 보관한다. 이 참조를 통해 바깥 인스턴스의 멤버에 접근할 수 있다.
  (반대로 정적 중첩 클래스는 외부 클래스의 참조값이 없으므로 외부 인스턴스 멤버에 접근할 수 없다. 참조가 중요한거 같다.)

* 정리
중첩(Nested): 어떤 다른 것이 내부에 위치하거나 포함되는 구조적인 관계
내부(Inner): 나의 내부에 있는 나를 구성하는 요소

정적 중첩 클래스는 다른 클래스를 그냥 중첩해 둔 것일 뿐이다. 쉽게 말해 둘은 아무런 관계가 없다.
반면에 내부 클래스는 바깥 클래스의 인스턴스 내부에서 구성 요소로 사용된다.

장점
불필요한 클래스의 정보들이 외부에 노출되는 것을 막는다(캡슐화)

<같은 이름의 바깥 변수 접근>
바깥 클래스의 인스턴스 변수 이름과 내부 클래스의 인스턴스 변수 이름이 깥을때

프로그래밍에서 우선순위는 대부분 더 가깝거나, 더 구체적인 것이 우선권을 가진다.

다른 변수들을 가려서 보이지 않게 하는 것을 섀도잉(Shadowing)이라 한다.

다른 변수를 가리더라도 인스턴스의 참조를 사용하면 외부 변수에 접근할 수 있다.
this.value는 내부 클래스의 인스턴스에 접근
바깥클래스이름.this.value는 바깥 클래스의 인스턴스에 접근할 수 있다.

* 프로그래밍에서 가장 중요한 것은 명확성이다. 이렇게 이름이 같은 경우 처음부터 이름을 서로 다르게 지어서
  명확하게 구분하는 것이 더 나은 방법이다.


※참고
<내부 클래스에서 static 사용>
자바 버전 16 이전에는 내부 클래스에서 static 변수선언, static 메서드 선언이 불가능 했다.
그러나 16 이후부터는 가능하다
하지만 내부 클래스에 static 변수/메서드를 사용할때는 static class를 고려하자
* 중요하지는 않은거 같아서 참고만 하자

<바깥 클래스에서 내부(static, non-static) 클래스 사용시 제한>
- 바깥 클래스의 인스턴스 변수/메서드 에서 static class, non-static class 모두 생성가능
- 바깥 클래스의 클래스(static) 변수/메서드 에서 static class 생성 가능, non-static class 생성 불가
  이건 바깥 클래스의 static 변수/메서드에서 non-static class 직접 사용시 바깥 클래스 참조값
  부재여부 가능성 때문인걸로 추측됨. 즉, non-static class는 외부 클래스 없이 생성이 불가능 하기 때문(이때 외부 클래스 참조값 없음)

★ 가능 불가능 여부는 외부클래스, 내부클래스 참조값 및 메모리(힙영역, 메서드영역)에 생성 여부를 생성해보자

※참고 -> ★객체 없이 접근이 가장 중요
static -> 정적이라는 뜻
static 이라는 키워드를 붙이는 이유
-> 메모리 구조나 실행 흐름에서 "고정되어 있음", 즉 객체(instance)에 의존하지 않음을 의미

* Java 에서 static 키워드는 "클래스 수준의 멤버('객체 없이 접근' 가능한 멤버)"를 만들기 위해 사용

== static 변수/메서드/클래스 ==
- static 변수: 인스턴스 없이 접근 가능한 공용 공간
    모든 객체가 공유
    객체 생성 없이도 접근 가능
    즉, 고정되어 있는 저장 공간 -> 정적 변수
* ‘정적’이라는 말은 "어떤 객체와 무관하게 항상 같은 메모리 영역에 존재하는 상태"라는 뜻

- static 메서드: 객체 없이 호출 가능한 고정된 로직
    객체 생성 없이 호출
    내부에서 인스턴스 변수(this)를 참조할 수 없음
* 객체 상태와 무관한 동작(기능) = 정적인 기능

- static 클래스: 인스턴스 클래스 없이 독립적으로 정의 가능한 클래스
    외부 클래스의 인스턴스 없이도 생성 가능
* 외부 인스턴스에 고정되지 않은 독립적 클래스

== 왜 "static"이라는 용어를 썼을까? ==
다음과 같은 배경이 있어요:

🧬 역사적으로
static은 **C 언어 시절부터 "고정된 메모리 위치"**라는 의미로 쓰였어요.

예: C의 static int counter = 0; → 함수가 종료되어도 값 유지됨

Java는 이 의미를 확장해:

★'객체 없이 접근' 가능한 클래스-level 요소로 사용

동적(dynamic)이 아닌 고정(static) 상태

정리: static의 의미
대상	static 의미
변수	클래스가 생성될 때 딱 1개만 생성됨 (공유됨)
메서드	객체 없이 호출 가능, 인스턴스 상태에 의존 안함
클래스	외부 클래스 인스턴스 없이 독립적으로 존재 가능

== 그래서 왜 static 이라 부르나?★ ==
"정적(static)"이란, '객체 생성과 무관하게 항상 고정되어 존재하는 것'을 의미하기 때문에
Java도 이 용어를 그대로 사용한 거예요.

== 개인적 궁금증 ==
static class: "외부 인스턴스에 종속되지 않는다"
🔍 당신이 말한 내용 정리
static class도 new로 생성해야 하니까 결국 동적이지 않나?
그럼 static 변수/메서드처럼 "고정된" 건 아니지 않나?

🟢 맞아요.
static class는 인스턴스를 만들 수 있고, 그 인스턴스는 동적으로 생성됩니다.

하지만 중요한 건 이 '클래스 자체가 외부 클래스의 인스턴스와는 독립적'이라는 점이에요.


📌 static class의 핵심 의미
외부 클래스의 인스턴스 없이도 정의 및 사용 가능

외부 클래스의 인스턴스 멤버에 접근 불가

즉, "정적"이라는 뜻은 ★"외부 인스턴스에 고정되지 않고 독립적"★이라는 의미로 받아들이는 게 맞습니다

따라서 static class는 "정적으로 고정된 메모리 위치"가 아니라,
"정적으로 고정된 스코프 및 종속성"의 개념에 가까워요.

쉽게 static class는
★"외부 인스턴스에 고정되지 않고 독립적"★ 이런 의미로 static을 사용했다고 생각하자


※참고 - static 키워드를 붙일 수 있는 대상
변수 (field):   클래스 변수 (인스턴스 없이 공유됨)
메서드:	클래스 메서드 (인스턴스 없이 호출)
중첩 클래스 (nested class):	static 중첩 클래스, 외부 인스턴스와 무관하게 사용
블럭 (static initializer block):	  클래스가 로딩될 때 한 번만 실행되는 초기화 블록
import 문 (static import):	static 멤버를 클래스 이름 없이 직접 호출 가능
인터페이스의 멤버 (Java 8+):	static 메서드 정의 가능 (객체 없이 사용)

인터페이스:	(사실상 static)	중첩 인터페이스는 암묵적으로 static
enum:	(사실상 static)	enum도 자동으로 static 취급
record:	✅ (final + static 성격)	값 중심 불변 클래스
        -> Java 16부터 정식 채택된 불변(immutable) 데이터 전용 클래스


* 중첩 인터페이스는 기본적으로 static 으로 간주
class Outer {
    interface NestedInterface { // 자동으로 static
        void doSomething();
    }
}

* 모든 enum은 사실상 static
* enum은 클래스 내부에 선언되더라도 자동으로 static으로 간주되며, 외부 클래스의 인스턴스 없이 접근 가능
class Outer {
    enum Status { ON, OFF }
}