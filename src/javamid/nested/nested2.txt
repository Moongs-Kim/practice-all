[중첩 클래스2]

<지역 클래스>
- 지역 클래스(Local class)는 클래스의 특별한 종류의 하나이다. 따라서 내부 클래스의 특징을 그대로 가진다.
  예를 들어서 지역 클래스도 내부 클래스의므로 바깥 클래스의 인스턴스 멤버에 접근할 수 있다.
- 지역 클래스는 지역 변수와 같이 코드 블럭 안에서 정의된다.

== 지역 클래스의 특징 ==
- 지역 클래스는 지역 변수처럼 코드 블럭 안에 클래스를 선언한다.
- 지역 클래스는 지역 변수에 접근할 수 있다.

== 지역 클래스의 접근 범위 ==
- 자신의 인스턴스 변수에 접근할 수 있다.
- 자신이 속한 코드 블럭의 지역변수에 접근할 수 있다.
- 자신이 속한 코드 블럭의 매개변수에 접근할 수 있다. 참고로 매개변수도 지역 변수의 한 종류이다.
- 바깥 클래스의 인스턴스 멤버에 접근할 수 있다. (지역 클래스도 내부 클래스의 한 종류이다.)

* 지역 클래스는 지역 변수 처럼 접근 제어자를 사용할 수 없다.
* static class를 만들 수 없다.(ex. static LocalClass -> x)
* 내부 클래스를 포함한 중첩 클래스들도 일반 클래스처럼 인터페이스를 구현하거나, 부모 클래스를 상속할 수 있다.

<지역 변수 캡처★>
변수의 생명 주기
- 클래스 변수: 프로그램 종료 까지, 가장 길다(메서드 영역)
  자바가 클래스 정보를 읽어 들이는 순간부터 프로그램 종료까지 존재한다.
- 인스턴스 변수: 인스턴스의 생존 기간(힙 영역), 생존 주기가 긴 편이다.
- 지역 변수: 메서드 호출이 끝나면 사라짐(스택 영역), 생존 주기가 아주 짧다.

== 지역 클래스 인스턴스의 생존 범위 ==
지역 클래스로 만든 객체도 인스턴스이기 때문에 힙 영역에 존재한다. 따라서 GC 전까지 생존한다.

지역 변수의 생명주기는 짧고, 지역 클래스를 통해 생성한 인스턴스의 생명 주기는 길다.
지역 클래스를 통해 생성한 인스턴스가 지역 변수에 접근해야 하는데, '둘의 생명 주기가 다르기 때문'에
인스턴스는 살아 있지만, 지역 변수는 이미 제거된 상태일 수 있다.

== 지역 변수 캡처★ ==
자바는 위와같은 문제를 해결하기위해 지역 클래스의 인스턴스를 생성하는 시점에 필요한 지역 변수를 복사해서
생성한 인스턴스에 함께 넣어둔다. 이런 과정을 변수 캡처(Capture)라 한다.
즉, 인스턴스를 생성할 때 필요한 지역 변수를 복사해서 보관해 두는 것이다.
모든 지역 변수를 캡처하는 것이 아니라 접근이 필요한 지역 변수만 캡처한다.

- 과정
1. 지역 클래스 인스턴스 생성 시도 -> 지역 클래스가 접근하는 지역 변수를 확인
2. 사용하는 지역 변수 복사
3. 지역 변수 복사 완료: 복사한 지역 변수를 인스턴스에 포함
4. 인스턴스 생성 완료: 복사한 지역 변수를 포함해서 인스턴스 생성이 완료.
                    복사한 지역 변수를 인스턴스를 통해 접근할 수 있다.

* 캡처한 변수에 접근하는 것이므로 스택 영역에 있는 지역 변수에 접근하는 것이 아니다.
* 캡처한 변수의 생명주기는 인스턴스의 생명주기와 같다. 따라서 지역 변수의 생명주기와 무관하게 캡처 변수에 접근 가능하다.
* 참고로 이런 캡처 필드들은 자바가 내부에서 만들어 사용하는 필드들이다.

★지역 변수 캡처의 원인과 해결
- 원인: 변수의 생명주기가 다르다
- 해결: 지역 변수를 지역 클래스에 복사(캡처)한다.

* 정리
지역 클래스는 인스턴스를 생성할 때 필요한 지역 변수를 먼저 캡처해서 인스턴스에 보관한다.
그리고 지역 클래스의 인스턴스를 통해 지역 변수에 접근하면, 실제로는 지역 변수에 접근하는 것이 아니라
인스턴스에 있는 캡처한 캡처 변수에 접근한다.

== 사싱상 final ==
★지역 클래스가 접근하는 지역 변수는 절대로 중간에 값이 변하면 안된다.
따라서 final로 선언하거나 또는 사실상 final 이어야 한다. 이것은 자바 문법이고 규칙이다.

※사실상 final
영어로 effectively final 이라 한다. 사실상 final 지역 변수는 지역 변수에 final 키워드를 사용하지는 않았지만,
값을 변경하지 않는 지역 변수를 뜻한다. final 키워드를 넣지 않았을 뿐이지, 실제로는 final 키워드를 넣은 것 처럼
중간에 값을 변경하지 않은 지역 변수이다. 따라서 사실상 final 지역 변수는 final 키워드를 넣어도 동일하게
작동해야 한다.

== 지역 클래스가 접근하는 지역 변수가 final 또는 사실상 final 이어야 하는 이유★(값이 변하지 않아야함) ==
지역 클래스를 생성하는 시점에 지역 변수를 캡처한다.
그런데 이후에 캡처한 지역 변수의 값을 변경하면?

이렇게 되면 스택 영역에 존재하는 지역 변수의 값과 인스턴스에 캡처한 캡처 변수의 값이
서로 달리지는 문제가 발생한다. 이것을 동기화 문제라 한다.

★캡처 변수의 값을 변경하지 못하는 이유
- 지역 변수의 값을 변경하면 인스턴스에 캡처한 변수의 값도 변경해야 한다.
- 반대로 인스턴스에 있는 캡처 변수의 값을 변경하면 해당 지역 변수의 값도 다시 변경해야 한다.
- 개발자 입장에서 보면 예상하지 못한 곳에서 값이 변경될 수 있다. 이는 디버깅을 어렵게 한다.
- 지역 변수의 값과 인스턴스에 있는 캡처 변수의 값을 서로 동기화 해야 하는데, 멀티쓰레드 상황에서
  이런 동기화는 매우 어렵고, 성능에 나쁜 영향을 줄 수 있다.

위와같은 모든 문제는 캡처한 지역 변수의 값이 변하기 때문에 발생한다.
자바는 캡처한 지역 변수의 값을 변하지 못하게 막아서 이런 복잡한 문제들을 근본적으로 차단한다.

※참고
<지역 클래스에서 static 사용>
자바 버전 16 이전에는 지역 클래스에서 static 변수선언, static 메서드 선언이 불가능 했다.
그러나 16 이후부터는 가능하다
* 중요하지는 않은거 같아서 참고만 하자


<익명 클래스>
익명 클래스(anonymous class)는 지역 클래스의 특별한 종류의 하나이다.
익명 클래스는 지역 클래스인데, 클래스의 이름이 없다는 특징이 있다.

- 지역 클래스를 사용하기 위해서는 선언과 생성이라는 2가지 단계를 거친다.
- 익명 클래스 - 지역 클래스의 선언과 생성을 한번에 할 수 있다.

new Anonymous() {body}
익명 클래스는 클래스의 본문(body)을 정의하면서 동시에 생성한다.
new 다음에 바로 상속 받으면서 구현 할 부모 타입을 입력하면 된다.

== 익명 클래스 특징 ==
- 익명 클래스는 이름 없는 지역 클래스를 선언하면서 동시에 생성한다.
- 익명 클래스는 부모 클래스를 상속 받거나, 또는 인터페이스를 구현해야 한다.
  익명 클래스를 사용할 때는 상위 클래스나 인터페이스가 필요하다.
- 익명 클래스는 말 그대로 이름이 없다. 이름을 가지지 않으므로, 생성자를 가질 수 없다.(기본 생성자만 사용됨)
  부모 생성자의 매개 변수 입력은 가능(ex. new Parent(매개값1,...))
  위에 예에서 매개값은 부모의 생성자에 정의된 매개변수이다.
- 익명 클래스는 AnonymousOuter$1 과 같이 자바 내부에서 바깥 클래스 이름 + $ + 숫자로 정의된다.
  익명 클래스가 여러개면 $1, $2, $3 으로 숫자가 증가하면서 구분된다.
- 익명 클래스는 상속, 구현을 통해 만들어 지므로 다형성이 적용된다고 볼 수 있다.
  (부모 타입 변수에 자식 객체 대입)
  따라서 익명 객체에 선언한 멤버변수 및 메서드는 외부에서 사용할 수 없다(다형성 -> 부모타입변수에서 자식 변수 접근 불가)
  따라서 익명 객체에 있는 필드 및 메서드를 사용한다면 그 내부에서만 사용할 수 있다.
  단, 오버라이딩된 메서드는 외부에서 호출될 수 있다.

== 익명 클래스의 장점 ==
익명 클래스를 사용하면 클래스를 별도로 정의하지 않고도 인터페이스나 추상 클래스를
즉석에서 구현할 수 있어 코드가 더 간결해진다.
하지만, 복잡하거나 재사용이 필요한 경우에는 별도의 클래스를 정의하는 것이 좋다.

== 익명 클래스를 사용할 수 없을 때 ==
익명 클래스는 단 한 번만 인스턴스를 생성할 수 있다. 여러 번 생성이 필요하다면
익명 클래스를 사용할 수 없다. 대신에 지역 클래스를 선언하고 사용하면 된다.

※참고: 익명 클래스에서 지역 변수, 매개 변수 사용이 지역 클래스와 마찬가지로 지역 변수 캡처가 일어난다.
       따라서 해당 지역 변수는 final이거나 사실상 final 이여야 한다.

* 정리
- 익명 클래스는 이름이 없는 지역 클래스이다.
- 특정 부모 클래스(인터페이스)를 상속 받고 바로 생성하는 경우 사용한다.
- 지역 클래스가 일회성으로 사용되는 경우나 간단한 구현을 제공할 때 사용한다.


★프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 핵심은
변하는 부분과 변하지 않는 부분을 분리하는 것이다.
anonymous.ex 패키지에 있는 예제에서
- 변하는 부분과 변하지 않는 부분을 분리
- 변하는 부분을 외부에서 전달 받아 메서드의 재사용성을 높임
★핵심은 변하는 부분을 메서드 내부에서 가지고 있는 것이 아니라, 외부에서 전달 받는다는 점

★코드 조각 전달
단순히 문자열 같은 데이터를 전달 받는 것과 달리
코드 조각을 외부에서 전달 받는 방법

코드 조각은 보통 메서드에 정의한다. 따라서 코드 조각을 전달하기 위해서는 메서드가 필요하다.
하지만 지금까지 학습한 내용으로는 메서드를 전달할 수 있는 방법이 없다.
대신에 인스턴스를 전달하고, 인스턴스에 있는 메서드를 호출하면 된다.

다형적 참조와 메서드 오버라이딩을 사용해
외부에서 전달되는 인스턴스에 따라 각각 다른 코드 조각을 실행하면 된다.

* 정리
- 문자열 같은 데이터를 메서드에 전달할 때는 String, int 와 같은 각 데이터에 맞는 타입을 전달하면 된다.
- 코드 조각을 메서드에 전달할 때는 인스턴스를 전달하고 해당 인스턴스에 있는 메서드를 호출하면 된다.


※참고 - 람다(lambda)
자바8 이전까지 메서드에 인수로 전달할 수 있는 것은 크게 2가지
- int, double과 같은 기본형 타입
- String, ArrayList 와 같은 참조형 타입(인스턴스)
* 메서드에 인수로 전달할 수 있는 것은 간단한 데이터나, 인스턴스의 참조이다.

코드 조각을 전달하기 위해 클래스를 정의하고 메서드를 만들고 또 인스턴스를 꼭 생성해서 전달해야 할까?
클래스나 인스턴스와 관계 없이 '머서드만 전달'할 수 있다면 더 간단할 것이다.

자바8에 들어서면서 큰 변화가 있었는데 메서드(더 정확히는 함수)를 인수로 전달할 수 있게 되었다.
이것을 간단히 람다(Lambda)라 한다.

람다는 이후에 학습. 지금은 이런 것이 있구나 정도만 참고

<정리 마지막>
- 정적 중첩 클래스: 바깥 클래스와 밀접한 관련이 있지만, 인스턴스 간에 데이터 공유가 필요 없을 때 사용한다.
- 내부 클래스: 바깥 클래스의 인스턴스와 연결되어 있고, 바깥 클래스의 인스턴스 상태에 의존하거나
             강하게 연관된 작업을 수행할 때 사용한다.
- 지역 클래스: 내부 클래스의 특징을 가진다.
             지역 변수에 접근할 수 있다. 접근하는 지경 변수는 final 이거나 사실상 final 이어야 한다.
             주로 특정 메서드 내에서만 간단히 사용할 목적으로 사용한다.
- 익명 클래스: 지역 클래스인데, 이름이 없다.
             상위 타입을 상속 또는 구현하면서 바로 생성된다.
             주로 특정 상위 타입을 간단히 구현해서 일회성으로 사용할 때 유용하다.

※참고 - 중첩 인터페이스
중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다.
인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위함이다.

선언 방법
1. 인스턴스 멤버 인터페이스 non-static interface
   인스턴스 멤버 인터페이스는 바깥 클래스의 객체가 있어야 사용 가능
2. 정적 멤버 인터페이스 static interface
   바깥 클래스의 객체 없이 바깥 클래스만으로 바로 접근 가능
   주로 정적 멤버 인터페이스를 많이 사용




