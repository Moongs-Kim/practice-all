[ArrayList]

<배열의 특징1 - 배열과 인덱스>
배열과 같이 여러 데이터(자료)를 구조화해서 다루는 것을 자료 구조라 한다.
자바는 배열 뿐만 아니라, 컬렉션 프레임워크라는 이름으로 다양한 자료 구조를 제공한다.
우선 자료 구조의 가장 기본이 되는 배열의 특징을 알아본다.

== 배열의 특징 ==
- 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
- 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.

- 공식: 배열의 시작 참조 + (자료긔 크기 * 인덱스 위치)

배열의 경우 인덱스를 사용하면 한번의 계산으로 매우 효율적으로 자료의 위치를 찾을 수 있다.
인덱스를 통한 입력, 변경, 조회 모두 한번의 계산으로 필요한 위치를 찾아서 처리할 수 있다.
★배열에서 인덱스를 사용하는 경우 데이터가 아무리 많아도 '한 번의 연산으로 필요한 위치를 찾을 수 있다.'

★배열의 검색
배열에 들어있는 데이터를 찾는 것을 검색이라 한다.
배열에 들어있는 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 비교해야 한다.
이 과정은 인덱스를 사용해서 한번에 찾을 수 없다. 배열안에 들어있는 데이터를 하나하나 확인해야 한다.
따라서 평균적으로 볼때 배열의 크기가 클 수록 오랜 시간이 걸린다.

배열의 순차 검색은 배열에 들어있는 데이터의 크기 만큼 연산이 필요하다.
'배열의 크기가 n이면 연산도 n만큼 필요하다.'

* 배열 정리
- 배열의 인덱스 사용: O(1)
- 배열의 순차 검색: O(n)

배열에 데이터가 100,000건이 있다면 인덱스를 사용하면 1번의 연산으로 결과를 찾을 수 있지만,
순차 검색을 사용한다면 최악의 경우 100,000번의 연산이 필요한다.
배열에 들어있는 데이터의 크기가 증가할 수록 그 차이는 매우 커진다.
따라서 인덱스를 사용할 수 있다면 최대한 활용하는 것이 좋다.

<배열의 특징2 - 데이터 추가>
배열의 특정 위치에 데이터 추가
추가는 기존 데이터를 유지하면서 새로운 데이터를 입력하는 것을 뜻한다. 데이터를 중간에 추가하면 기존 데이터가
오른쪽으로 한 칸씩 이동해야 한다.
즉, 데이터를 추가하려면 새로운 데이터를 입력할 공간을 확보해야 한다.
따라서 기존 데이터를 오른쪽으로 한 칸씩 밀어야 한다.(기존 데이터의 인덱스를 하나씩 증가시켜야 한다.)

== 배열에 데이터를 추가할 때 위치에 따른 성능 변화 ==
1. 배열의 첫 번째 위치에 추가
    - 배열의 첫 번째 위치를 찾는데는 인덱스를 사용하므로 O(1)이 걸린다.
    - 모든 데이터를 배열의 크기만큼 한 칸씩 이동해야 한다. 따라서 o(n) 만큼의 연산이 걸린다.
    - o(1 + n) -> o(n)
2. 배열의 중간 위치에 추가
    - 배열의 위치를 찾는데는 O(1)이 걸린다.
    - index의 오른쪽에 있는 데이터를 모두 한 칸씩 이동해야 한다. 따라서 평균 연산은 o(n/2)이 된다.
    - o(1 + n/2) -> o(n)
3. 배열의 마지막 위치에 추가
    - 이 경우 배열이 이동하지 않고 배열의 길이를 사용하면 마지막 인덱스에 바로 접근할 수 있다.
    - 한 번의 계산으로 위치를 찾을 수 있고, 기존 배열을 이동하지 않으므로 O(1)이 된다.

== 배열의 한계 ==
- 배열은 가장 기본적이 자료 구조이고, 인덱스를 사용할 때 최고의 효율이 나온다.
- 배열의 큰 단점은 배열의 크기를 배열을 생성하는 시점에 미리 정해야 한다는 점이다.
  즉, 배열은 정적으로 길이가 정해져 있다.(단점)

<직접 구현하는 배열 리스트1>
배열 2가지 불편함
1. 배열의 길이를 동적으로 변경할 수 없다.
2. 데이터를 추가하기 불편한다.
   데이터를 추가하는 경우 직접 오른쪽으로 한 칸씩 데이터를 밀어야 한다.(이런 코드를 직접 작성해야 함)

== List 자료 구조 ==
- ★배열의 이런 불편함을 해소하고 동적으로 데이터를 추가할 수 있는 자료 구조를 List(리스트)라 한다.
- ★List 자료 구조는 순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다.

일반적으로 배열과 리스트는 구분해서 이야기한다.
리스트는 배열보다 유연한 자료 구조로, 크기가 동적으로 변할 수 있다.
- 배열: 순서가 있고 중복을 허용하지만 크기가 정적으로 고정된다.
- 리스트: 순서가 있고 중복을 허용하지만 크기가 동적으로 변할 수 있다.

※참고
배열을 새로 복사해서 만드는 연산은 배열을 새로 만들고 또 기존 데이터를 복사하는 시간이 걸리므로
가능한 줄이는 것이 좋다.
반면에 배열의 크기를 너무 크게 증가하면 사용되지 않고 낭비되는 메모리가 많아지는 단점이 발생할 수 있다.
보통 50% 정도 증가하는 방법을 사용한다.

== ArrayList ==
ArrayList는 리스트(List) 자료 구조를 사용하는데, 내부의 데이터는 배열(Array)에 보관하는 것이다.

배열 리스트의 빅오
1. 데이터 추가
    - 마지막에 추가: O(1)
    - 앞, 중간에 추가: O(n)
2. 데이터 삭제
    - 마지막에 삭제: O(1)
    - 앞, 중간에 삭제: O(n)
3. 인덱서 조회: O(1)
4. 데이터 검색: O(n)

배열 리스트는 마지막에 데이터를 추가하거나 마지막에 있는 데이터를 삭제할 때는 O(1)로 매우 빠르지만,
중간에 데이터를 추가하거나 삭제하는 경우에는 O(n)으로 느리다.
배열 리스트는 보통 데이터를 중간에 추가하고 삭제하는 변경 보다는, 데이터를 순서대로 입력하고(데이터를 마지막에 추가)
순서대로 출력하는 경우에 가장 효율적이다.

※참고
하나의 자료 구조에 숫자와 문자처럼 서로 관계없는 여러 데이터 타입을 섞어서 보관하는 일은 거의 없다.
일반적으로 같은 데이터 타입을 보관하고 관리한다.

제네릭을 도입하면 타입 안정성을 확보하면서 이런 문제를 한번에 해결할 수 있다.
제네릭은 자료를 보관하는 자료 구조에 가장 어울린다.

<직접 구현한 배열 리스트에 제네릭 적용>

== Object 배열을 사용한 이유 ==

Object[] elementData를 그대로 사용한 이유
- 제네릭은 런타임에 이레이저에 의해 타입 정보가 사라진다. 따라서 런타임에 타입 정보가 필요한 생성자에
  사용할 수없다. 따라서 제네릭을 기반으로 배열을 생성하는 코드는 작동하지 않고, 컴파일 오류가 발생한다.
  이것은 자바가 제공하는 제네릭의 한계이다.
  ex) new E[DEFAULT_CAPACITY]
- 대신 모든 데이터를 담을 수 있는 Object를 그대로 사용해야 한다.
  ex) new Object[DEFAULT_CAPACITY]
- Object는 모든 데이터를 담을 수 있기 때문에 데이터를 담는데는 아무런 문제가 없다.
  다만 데이터를 조회할 때 문제가 될 수 있는데, 이때는 Object 타입을 지정한 타입 매개변수로 다운캐스팅 해준다.
- 배열의 모든 데이터를 E 타입으로 보관하면, 배열에서 데이터를 꺼낼 때 (E)로 다운 캐스팅해도
  보관한 E 타입으로 다운 캐스팅하기 때문에 아무런 문제가 되지 않는다.
- 왜냐하면 Object 배열에 보관한 모든 데이터가 E 타입이라는 것이 확실하기 때문이다.

* 정리
생성자에는 제네릭의 타입 매개변수를 사용할 수 없는 한계가 있다. 따라서 배열을 생성할 때 대안으로
Object 배열을 사용해야 한다.
하지만 제네릭이 리스트의 데이터를 입력 받고 반환하는 곳의 타입을 고정해준다. 따라서 고정된 타입으로
Object 배열에 데이터를 보관하고, 또 데이터를 꺼낼 때도 같은 고정된 타입으로 안전하게 다운 캐스팅 할 수 있다.

== MyArrayList의 단점 ==
- 정환한 크기를 미리 알지 못하면 메모리가 낭비된다.
- 데이터를 중간에 추가하거나 삭제할 때 비효율적이다.
    이 경우 데이터를 한 칸씩 밀어야 한다. 이것은 O(n)으로 성능이 좋지 않다.

== ArrayList의 빅오 정리 ==
1. 데이터 추가
    - 마지막에 추가: O(1)
    - 앞, 중간에 추가: O(n)
2. 데이터 삭제
    - 마지막에 삭제: O(1)
    - 앞, 중간에 삭제: O(n)
3. 인덱스 조회: O(1)
4. 데이터 검색: O(n)

★배열 리스트는 순서대로 마지막에 데이터를 추가하거나 삭제할 때는 성능이 좋지만,
앞이나 중간에 데이터를 추가하거나 삭제할 때는 성능이 좋지 않다.
이런 단점을 해결한 자료 구조인 링크드 리스트(LinkedList)가 있다.


