[List]

<리스트 추상화1 - 인터페이스 도입>
다형성과 OCP 원칙을 가장 잘 활용할 수 있는 곳 중에 하나가 자료 구조이다.

== List 자료 구조 ==
순서가 있고, 중복을 허용하는 자료 구조를 리스트(List)라 한다.

지금까지 만든 MyArrayList, MyLinkedList는 내부 구현만 다를 뿐 같은 기능을 제공하는 리스트이다.
내부 구현이 다르기 때문에 상황에 따라 성능은 달라질 수 있지만 핵심은 사용자 입장에서 보면 같은 기능을
제공한다는 것이다.
이 둘의 공통 기능을 인터페이스로 뽑아서 추상화하면 다형성을 활용한 다양한 이득을 얻을 수 있다.

<리스트 추상화2 - 의존관계 주입>
★데이터를 앞에서 추가하거나 삭제하는 일이 많다면 MyArrayList 보다는 MyLinkedList를 사용
하는 것이 훨씬 효율적이다.

== 데이터를 앞에서 추가하거나 삭제할 때 빅오 비교 ==
- MyArrayList: O(n)
- MyLinkedList: O(1)

== 의존 관계 주입 ==
Dependency Injection, 줄여서 DI 라고 부른다. 의존성 주입이라고도 부른다.
의존관계가 외부에서 주입되는 것 같다고 해서 '의존관계 주입'이라 한다.

의존관계는 크게 컴파일 타임 의존관계와 런타임 의존관계로 나눌 수 있다.
- 컴파일 타임(compile time): 코드 컴파일 시점을 뜻한다.

  컴파일 타임 의존관계는 자바 컴파일러가 보는 의존관계이다. 클래스에 의존 관계가 다 나타난다.
  쉽게 말해 클래스에 바로 보이는(코드에 적혀있는) 의존관계이다. 그리고 실행하지 않은 소스 코드에
  정적으로 나타나는 의존관계이다.
  예로 BatchProcessor 클래스를 보면 MyList 인터페이스만 사용한다. 코드 어디에도 MyArrayList나
  MyLinkedList 같은 정보는 보이지 않는다. 따라서 BatchProcessor는 MyList 인터페이스에만 의존한다.

- 런타임(runtime): 프로그램 실행 시점을 뜻한다.

  런타임 의존관계는 실제 프로그램이 작동할 때 보이는 의존관계이다. 주로 생성된 인스턴스와
  그것을 참조하는 의존관계이다.
  쉽게 말해 프로그램이 실행될 때 인스턴스 간에 의존관계로 보면 된다.
  런타임 의존관계는 프로그램 실행 중에 계속 변할 수 있다.
  예) BatchProcessor 인스턴스의 MyList list 변수는 생성자를 통해 MyArrayList 인스턴스를 참조한다.
      BatchProcessor 인스턴스에 MyArrayList 의존관계를 주입한다.
      따라서 이후 logic()을 호출하면 MyArrayList 인스턴스를 사용하게 된다.

* 정리
- BatchProcessor 클래스는 구체적인 MyArrayList 나 MyLinkedList 에 의존하는 것이 아니라
  추상적인 MyList 에 의존한다. 따라서 런타임에 MyList의 구현체를 얼마든지 선택할 수 있다.
- BatchProcessor 에서 사용하는 리스트의 의존관계를 '클래스에서 미리 결정하는 것이 아니라',
  런타임에 객체를 생성하는 시점으로 미룬다. 따라서 런타임에 MyList의 구현체를 변경해도
  BatchProcessor의 코드는 전혀 변경하지 않아도 된다.
- 이렇게 생성자를 통해 런타임 의존관계를 주입하는 것을 '생성자 의존관계 주입' 또는 줄여서
  '생성자 주입'이라 한다.
- OCP 원칙 -> 클라이언트 코드의 변경 없이(수정없이), 구현 알고리즘인 MyList 인터페이스의 구현을
             자요륩게 확장할 수 있다(확장에 열여있음).
- ★클라이언트 클래스는 컴파일 타임에 추상적인 것에 의존하고, 런타임에 의존 관계 주입을 통해
  구현체를 주입받아 사용함으로써, 이런 이점을 얻을 수 있다.

== ★전략 패턴(Strategy Pattern) ==
디자인 패턴 중 가장 중요한 패턴을 하나 뽑으라고 하면 전략 패턴을 뽑을 수 있다.
전략 패턴은 '알고리즘을 클라이언트 코드의 변경없이 쉽게 교체'할 수 있다.
MyList 인터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 구현체인 MyArrayList,
MyLinkedList가 전략의 구체적인 구현이 된다. 그리고 전략을 클라이언트 코드(BatchProcessor)
의 변경 없이 손쉽게 교체할 수 있다.


<LinkedList, ArrayList 실제 시간 복잡도와 성능>
- 이론적으로 LinkedList의 평균 추가(중간 삽입) 연산은 ArrayList 보다 빠를 수 있다. 그러나
  실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에
  의해 영향을 받는다.
- ArrayList는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
- 반면, LinkedList는 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에
  CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느릴 수 있다.
- ArrayList의 경우 CAPACITY를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다.
  하지만 한번에 2배씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을
  주지느 않는다.

* 정리
이론적으로 LinkedList가 평균 추가(중간 삽입)에 있어 더 효율적일 수 있지만, 현대 컴퓨터 시스템의
메모리 접근 패턴, CPU 캐시 최적화 등을 고려할 때 ArrayList가 실제 사용 환경에서 더 나은 성능을
보여주는 경우가 많다.

== 배열 리스트 vs 연결 리스트 ==
대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자

<자바 리스트>
자바 컬렉션 프레임워크에서 리스트의 상속 구조
Collection(interface) <- List(interface) <- ArrayList, LinkedList

- Collection 인터페이스
  Collection 인터페이스는 java.util 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다. 이 인터페이스는
  자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의한다. Collection 인터페이스는 List, Set
  Queue와 같은 다양한 하위 인터페이스와 함께 사용되며, 이를 통해 데이터를 리스트, 세트, 큐 등의 형태로 관리할 수
  있다.

- List 인터페이스
  List 인터페이스는 java.util 패키지에 있는 컬렉션 프레임워크의 일부다. List는 객체들의 순서가 있는 컬렉션을
  나타내며, 같은 객체의 중복 저장을 허용한다. 이 리스트는 배열과 비슷하지만, 크기가 동적으로 변화하는 컬렉션을
  다룰 때 유연하게 사용할 수 있다.

  List 인터페이스는 ArrayList, LinkedList와 같은 여러 구현 클래스를 가지고 있으며, 각 클래스는 List 인터페이스의
  메서드를 구현한다.


