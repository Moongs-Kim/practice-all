[Hash]

보통의 set의 경우 데이터를 입력할때 중복 데이터가 있는지 확인하기 위해 모든 데이터를 체크해야한다.
이것은 O(n)으로 성능이 떨어진다.
결국 중복 데이터를 찾는 부분이 성능의 발목을 잡는다.
이런 부분을 개선할 수 있는것이 Hash 이다.

<해시 알고리즘1 - 시작>
해시(hash) 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 O(1)로 비약적으로 끌어올릴 수 있다.

== index 사용 ==
배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 O(1)로 매우 빠른 특징을 가지고 있다.
반면 데이터를 검색할 때는 배열에 들어있는 데이터 하나하나를 모두 비교해야 하므로 인덱스를 활용할 수 없다.
그런데 만약 데이터를 검색할 때도 인덱스를 활용해서 데이터를 한 번에 찾을 수 있다면?
가능하다면 O(n) -> O(1)로 바꾸어서 성능을 획기적으로 끌어올릴 수 있을 것이다.

물론 인덱스와 데이터의 값은 서로 다르기 때문에 이것은 불가능하다.

* 생각의 전환★
데이터의 값 자체를 배열의 인덱스와 맞추어 저장한다면?
즉,  데이터의 값 자체를 배열의 인덱스로 사용하는 것이다.

인덱스 1에는 데이터 1이 들어있고, 인덱스 8에는 데이터 8이 들어있다.
저장하는 데이터와 인덱스를 완전히 맞춘 것이다.
인덱스 번호가 데이터가 되고, 데이터가 인덱스 번호가 된다.

따라서 배열의 인덱스를 활용해서 단번에 필요한 데이터를 찾을 수 있다.
데이터의 값을 인덱스 번호로 사용하는 아주 간단한 아이디어 하나로 O(n)의 검색 연산을 O(1)의 검색 연산으로
바꿀 수 있다.

* 정리
데이터의 값 자체를 배열의 인덱스로 사용했다. 배열에서 인덱스로 데이터를 찾는 것은 매우 빠르다.
그 덕분에 O(n)의 검색 성능을 O(1)로 획기적으로 개션할 수 있다.

* 문제
입력 값의 범위 만큼 큰 배열을 사용해야 한다. 따라서 배열에 낭비되는 공간이 많이 발생한다.

<해시 알고리즘2 - 메모리 낭비>
입력 값의 범위가 0 ~ 99라면?

데이터의 값을 배열의 인덱스로 사용하기 위해선 인덱스도 0 ~ 99 까지 사용할 수 있어야 한다.
따라서 100의 배열이 필요하다.

* 한계
데이터의 값을 인덱스로 사용한 덕분에 O(1)의 매우 빠른 검색 속도를 얻을 수 있다. 그리고 이 코드는 정상적
으로 수행 된다. 하지만 낭비되는 메모리 공간이 너무 많다.

만약 입력 값의 범위를 0~99를 넘어 int 숫자의 모든 범위를 입력할 수 있도록 한다면?
약 42억 사이즈의 배열이 필요하다(+,- 포함)
이것은 '메모리의 낭비 + 배열 생성시 메모리 할당 시간도 오래 소모'

따라서 데이터의 값을 인덱스로 사용하는 방식은 입력 값의 범위가 넓다면 사용하기 어려워 보인다.
데이터의 값을 인덱스로 사용하는 방법은 매우 빠른 성능을 보장하지만, 입력 값의 범위가 조금만 커져도
메모리 낭비가 너무 심하다. 이 방법을 그대로 사용하기에는 문제가 있다.

<해시 알고리즘3 - 나머지 연산>
공간도 절약하면서, 넓은 범위의 값을 사용할 수 있는 방법이 있는데, 바로 '나머지 연산'을 사용하는 것이다.
저장할 수 있는 배열의 크기를 10이라고 가정하면 그 크기(10)에 맞추어 나머지 연산을 사용하면 된다.

나머지 연산의 결과는 절대로 배열의 크기를 넘지 않는다.
예를 들어 나머지 연산에 10을 사용하면 결과는 0~9 까지만 나온다.
따라서 안전하게 인덱스로 사용할 수 있다.

== 해시 인덱스 ==
★위 처럼 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(hashIndex)라 한다.

과정
1. 저장할 값에 나머지 연산자를 사용해 해시 인덱스를 구한다.
2. 해시 인덱스를 배열의 인덱스로 사용해서 데이터를 저장한다.
   인덱스만 해시 인덱스를 사용하고, 값은 원래 값을 저장한다.
* 배열의 인덱스를 사용하기 때문에 하나의 값을 저장하는데 O(1)로 빠른 성능을 제공한다.
   -> 해시 인덱스 생성 O(1) + 해시 인덱스를 사용해 배열에 값 저장 O(1) = O(1)


== 해시 인덱스와 데이터 조회 ==
1. 조회할 값에 나머지 연산자를 사용해서 해시 인덱스를 구한다.
2. 해시 인덱스를 배열의 인덱스로 사용해서 데이터를 조회한다.
   인덱스만 해시 인덱스를 사용하고, 값은 원래 값을 조회한다.
* 배열의 인덱스를 사용하기 때문에 하나의 값을 찾는데 O(1)로 빠른 성능을 제공한다.
   -> 해시 인덱스 생성 O(1) + 해시 인덱스를 사용해 배열에 값 조회 O(1) = O(1)

* 정리
- 입력 값의 범위가 넓어도 실제 모든 값이 들어오지는 않기 때문에 배열의 크기를 제한하고, 나머지 연산을 통해
  메모리가 낭비되는 문제도 해결 할 수 있다.
- 해시 인덱스를 사용해서 O(1)의 성능으로 데이터를 저장하고, O(1)의 성능으로 데이터를 조회할 수 있게 된다.
  덕분에 자료 구조의 조회 속도를 비약적으로 향상할 수 있게 되었다.

* 한계 - 해시 충돌
지금까지의 내용은 저장할 위치가 충돌할 수 있다는 한계가 있다.
ex) 1 % 10 = 1
    11 % 10 = 1
둘다 같은 해시 인덱스가 나와버린다.

<해시 알고리즘4 - 해시 충돌>
== 해시 충돌 ==
다른 값을 입력했지만 같은 해시 코드가 나오게 되는것을 해시 충돌이라 한다.

== 해시 충돌 해결 ==
해시 충돌을 인정하면 문제 해결의 실마리가 보인다.
해시 충돌은 낮은 활률로 일어날 수 있다고 가정하는 것이다.

★해결 방안은 바로 해시 충돌이 일어났을 때 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해
  버리는 것이다.

여러 데이터를 배열의 하나의 공간에 함께 저장할 수는 없다.
대신 '배열 안에 배열을 만들면 된다.' 물론 배열 안에 리스트 같은 다른 자료구조를 사용해도 된다.

== 해시 충돌과 조회 ==
해시 충돌이 난 경우 내부의 데이터를 하나씩 비교해보면 원하는 결과를 찾을 수 있다.

최악의 경우 O(n)의 성능을 보인다.

* 정리
해시 인덱스를 사용하는 방식은 최악의 경우 O(n)의 성능을 보인다. 하지만 확률적으로 보면 어느 정도
넓게 퍼지기 때문에 평균으로 보면 대부분 O(1)의 성능을 제공한다. 해시 충돌이 가끔 발생해도 내부에서
값을 몇 번만 비교하는 수준이기 때문에 대부분의 경우 매우 빠르게 값을 찾을 수 있다.

== 해시 인덱스 충돌 확률 ==
해시 충돌이 발생하면 데이터를 추가하거나 조회할 때, 연결 리스트 내부에서 O(n)의 추가 연산을 해야 하므로
성능이 떨어진다. 따라서 해시 충돌은 가급적 발생하지 않도록 해야 한다.

★해시 충돌이 발생할 확률은 입력하는 데이터의 수와 배열의 크기와 관련이 있다.
입력하는 데이터의 수에 비해 배열의 크기가 클 수록 충돌 확률은 낮아진다.

★통계적으로 입력한 데이터의 수가 배열의 크기를 75% 넘지 않으면 해시 인덱스는 자주 충돌하지 않는다.
반대로 75%를 넘으면 자주 충돌하기 시작한다.

배열의 크기를 크게 만들면 해시 충돌은 줄어서 성능은 좋아지지만, 많은 메모리가 낭비된다.
반대로 배열의 크기를 너무 작게 만들면 해시가 자주 충돌해서 성능이 나빠진다.
상황에 따라 다르지만 보통 75%를 적절한 크기로 보고 기준으로 잡는 것이 효과적이다.

* 정리
해시 인덱스를 사용하는 경우
- 데이터 저장
    평균: O(1)
    최악: O(n)
- 데이터 조회
    평균: O(1)
    최악: O(n)

해시 인덱스를 사용하는 방식은 사실 최악의 경우는 거의 발생하지 않는다.
배열의 크기만 적절하게 잡아주면 대부분 O(1)에 가까운 매우 빠른 성능을 보여준다.

* 문제
해시 인덱스를 사용하려면 데이터의 값을 배열의 인덱스로 사용해야 한다. 그런데 배열의 인덱스는 0,1,2 같은
숫자만 사용할 수 있다. A, B와 같은 문자는 배열의 인덱스로 사용할 수 없다.
문자열 데이터로 해시 인덱스를 사용하려면??

<문자열 해시 코드>
해시 인덱스는 배열의 인덱스로 사용해야 하므로 0,1,2 같은 숫자(양의 정수)만 사용할 수 있다.
따라서 문자를 사용할 수 없다.
문제 데이터를 기반으로 숫자 해시 인덱스를 구하려면 어떻게 해야 할까?

모든 문자는 본인만의 고유한 숫자로 표현할 수 있다. 예를 들어 A는 65, B는 66으로 표현된다.
가장 단순하게 char형을 int형으로 캐스팅하면 문자의 고유한 숫자를 확인할 수 있다.
그리고 AB와 같은 연속된 문자는 각각의 문자를 더하는 방식으로 숫자로 표현하면 된다.

※참고
컴퓨터는 문자를 직접 이해하지 못한다. 대신에 각 문자에 고유한 숫자를 할당해서 인식한다.
ASCII 같은 코드 표를 참고해  문자는 숫자로 / 숫자는 문자로 변환 한다.
문자는 인코딩, 디코딩 한다.

== 해시 코드와 해시 인덱스 ==
문자를 기반으로 고유한 숫자를 만들듯 어떤 규칙으로 문자 등을 숫자로 바꾸는 것을 해시 코드라 한다.
이렇게 만들어진 해시 코드는 숫자이기 때문에 배열의 인덱스로 사용할 수 있다.

★해시 인덱스를 배열의 인덱스로 사용해야 한다. 하지만 해시 인덱스는 숫자만 가능하다
따라서 숫자가 아닌것을 숫자로 바꾸면 그 숫자가 곧 해시 코드이다.
이 숫자(해시 코드)를 통해 해시 인덱스를 생성해 배열의 인덱스로 사용하면 된다.

- 과정 -
값 -> 해시 함수 -> 해시 코드 생성(숫자) -> 해시 인덱스 생성

ex) - hashCode() 메서드를 사용해서 문자열을 해시 코드로 변경한다. 그러면 고유한 정수 숫자 값이 나오는데,
      이것을 해시 코드라 한다.
    - 숫자 값인 해시 코드를 사용해서 해시 인덱스를 생성한다.
    - 이렇게 생성된 해시 인덱스를 배열의 인덱스로 사용하면 된다.

== 용어 정리 ==
1. 해시 함수(Hash Function)
    - 해시 함수는 임의의 길이의 데이터를 입력 받아, 고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
      여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다. 예를 들어 int 형 1,100은 둘다 4byte를
      차지하는 고정된 길이를 뜻한다.
    - 같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
    - 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.

2. 해시 코드(Hash Code)
해시 코드는 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.
예
- 데이터 A의 해시 코드는 65
- 데이터 B의 해시 코드는 66
- 데이터 AB의 해시 코드는 131

3. 해시 인덱스(Hash Index)
- 해시 인덱스는 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해서 만든다.
- 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.

요약하면
해시 코드는 데이터를 대표하는 값,
해시 함수는 이러한 해시 코드를 생성하는 함수,
해시 인덱스는 해시 코드를 사용해서 데이터의 저장 위치를 결정하는 값을 뜻한다.

※참고 - 해시 충돌 가능성
1. 해시 코드를 충돌하는 과정과: 서로 다른 값이 같은 해시 코드를 가짐
2. 해시 인덱스를 생성하는 과정: 값도 다르고 해시 코드도 다른데 해시 인덱싱 하는 과정에서 같은 인덱스 발생(충돌)

이 두가지 과정에서 모두 해시 충돌이 발생할 수 있다.

하지만 해시 테이블에서 중요한 건 '최종 인덱스가 겹치느냐' 이다.
그래서 보통 해시 충돌이라고 하면 '해시 인덱스가 충돌'했을 때를 말한다.

그리고 위 2가지 과정에서 발생하는 충돌은 '해시 충돌'이라는 하나의 개념으로 묶어서 부른다.

* 정리
문자 데이터를 사용할 때도, 해시 함수를 사용해서 정수 기반의 해시 코드로 변환한 덕분에, 해시 인덱스를
사용할 수 있게 되었다. 따라서 문자의 경우에도 해시 인덱스를 통해 빠르게 저장하고 조회할 수 있다.

여기서 핵심은 '해시 코드'이다.
세상의 어떤 객체든지 정수로 만든 해시 코드(숫자)만 정의할 수 있다면 해시 인덱스를 사용할 수 있다.

<자바의 hashCode()>
해시 인덱스를 사용하는 해시 자료 구조는 데이터 추가, 검색, 삭제의 성능이 O(1)로 매우 빠르다.
따라서 많은 곳에서 자주 사용된다. 그런데 해시 자료 구조를 사용하려면 정수로 된 숫자 값인 해시 코드가
필요하다.

모든 타입을 해시 자료 구조에 저장하려면 모든 객체가 숫자 해시 코드를 제공할 수 있어야 한다.

== Object.hashCode() ==
자바는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 기능을 제공한다.
바로 Object에 있는 hashCode() 메서드다.

- 위 hashCode()를 그대로 사용하기 보다는 보통 오버라이딩 해서 사용한다.
- 이 메서드의 기본 구현은 객체의 참조값을 기반으로 해시 코드를 생성한다.
- 즉, 객체의 인스턴스가 다르면 해시 코드도 다르다.(모든 인스턴스의 참조값은 다르므로)

Object가 기본으로 제공하는 hashCode()는 객체의 참조값을 해시 코드로 사용한다.
따라서 각각의 인스턴스마다 서로 다른 값을 반환한다.

== 자바의 기본 클래스 해시 코드 ==
- Integer, String 같은 자바의 기본 클래스들은 대부분 내부 값을 기반으로 해시 코드를 구할 수 있도록
  hashCode() 메서드를 재정의해 두었다.
- 따라서 데이터의 값이 같으면 같은 해시 코드를 반환한다.
- 해시 코드의 경우 정수를 반환하기 때문에 마이너스 값이 나올 수 있다.
- 하지만 해시 인덱스는 0 이상의 값이어야 하기 때문에, 이걸 보정해주는 처리는 필요하다
  이것은 자바에서 구현되어 있다.

※동일성과 동등성
자바는 두 객체가 같다는 표현을 2가지로 분리해서 사용한다.
- 동일성(Identity): == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
- 동등성(Equality): equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인

동일성은 물리적으로 같은 메모리에 있는 객체인지 참조값을 확인하는 것
동등성은 논리적으로 같은지 확인하는 것

동일성은 자바 머신 기준이고 메모리의 참조가 기준으로 물리적이다.
동등성은 보통 사람이 생각하는 논리적인 것에 기준을 맞춘다. 따라서 논리적이다.

※나의 생각 정리
- Object의 hashCode()는 객체의 참조값(메모리 위치)을 기반으로 해시 코드를 생성한다.
- 동등성을 위해 equals()를 사용하면(재정의한 경우) 인스턴스는 달라도 어떤 값을 기준으로 비교하여
  논리적으로 같은지 여부를 파악할 수 있다.
- hashCode()를 재정의하면 물리적인 인스턴스(메모리의 위치)는 달라도(동일성 다름)
  어떤 값을 기준으로 똑같은 값일 경우 같은 해시 코드를 생성한다.
  이 경우 논리적으로 같은 인스턴스로 파악할 수 있다.

* 정리
Member의 경우 회원 id가 같으면 논리적으로 같은 회원으로 표현할 수 있다. 따라서 회원 id를 기븐으로
동등성을 비교하도록 equals()를 재정의해야 한다.
여기에 hashCode()도 같은 원리가 적용된다. 회원의 id가 같으면 논리적으로 같은 회원으로 표현할 수 있다.
따라서 회원 id를 기반으로 해시 코드를 생성해야 한다.(그러면 같은 해시 코드가 생성)

- hashCode()를 재정의할 때 Objects.hash()에 해시 코드로 사용할 값을 지정해주면 쉽게 해시 코드를
  생성할 수 있다.
- hashCode()를 재정의하지 않으면 Object가 기본으로 제공하는 hashCode()를 사용하게 된다. 이것은
  객체의 참조값을 기반으로 해시 코드를 제공한다. 따라서 회원의 id가 같아도 인스턴스가 다르면
  다른 해시 코드를 반환하게 된다.
- hashCode()를 id를 기반으로 재정의한 덕분에 인스턴스가 달라도 id 값이 같으면 같은 해시 코드를 반환한다.
  따라서 인스턴스가 다른 member1, member2는 id가 같다면 둘다 같은 해시 코드를 반환한다.

- 자바가 기본으로 제공하는 클래스 대부분은 hashCode()를 재정의해 두었다.
- 객체를 직접 만들어야 하는 경우 hashCode()를 재정의하면 된다.
- hashCode()만 재정의하면 필요한 모든 종류의 객체를 해시 자료 구조에 보관할 수 있다.
  ★해시 자료 구조에 데이터를 저장하는 경우 hashCode()를 구현해야 한다.

※참고
자바의 해시 함수는 단순히 문자들을 더하기만 하는 것이 아니라 더 복잡한 연산을 사용해서
해시 코드를 구한다.

<equals, hashCode의 중요성1>
해시 자료 구조를 사용하려면 hashCode()도 중요하지만, 해시 인덱스가 충돌할 경우를 대비해서 equals()도
반드시 재정의해야 한다. 해시 인덱스가 충돌할 경우 같은 해시 인덱스에 있는 데이터들을 하나하나 비교해서
찾아야한다. 이때 equals()를 사용해서 비교한다.

※내 생각
hashCode()는 충돌할 수 있다. 따라서 equals() 까지 같이 비교를 해야한다.
즉, 2번 비교를 통해 동등성을 확인하는 것이다.
equals()만 구현한 경우 값의 동등성은 확인할 수 있지만, 해시 코드가 다르므로
해시 자료 구조를 사용시 이상현상이 발생한다.(해시 코드를 활용하는 곳에서 적용할 수 없다)

※참고
해시 인덱스가 같아도 실제 저장된 데이터는 다를 수 있다. 따라서 특정 인덱스에 데이터가 하나만 있어도
equals()로 찾는 데이터가 맞는지 검증해야 한다.

따라서 해시 자료 구조를 사용하려면 반드시 hashCode(), equals()를 구현해야 한다.

== 1. hashCode, equals를 모두 구현하지 않은 경우 ==
※Object의 기본 기능
- hashCode(): 객체의 참조값을 기반으로 해시 코드를 반환한다.
- equals(): == 동일성 비교를 한다. 따라서 객체의 참조값이 같아야 true를 반환한다.

클래스를 만들 때 hashCode(), equals()를 재정의하지 않으면, 해시 자료 구조에서 Object가 기본으로 제공하는
hashCode(), equals()를 사용하게 된다. 그런데 Object가 기본으로 제공하는 기능은 단순히 인스턴스의 참조를
기반으로 작동한다.
그리고 객체의 참조값은 실행할 때 마다 값이 달라질 수 있다.

1) 데이터 저장 문제
- 해시 코드가 서로 다르기 때문에 다른 위치에 각각 저장된다.
- 그리고 예를들어 회원 id가 같은 경우 데이터가 중복 저장된다.

2) 데이터 검색 문제
- 데이터를 검색할 때도 검색시 전달할 객체의 해시 코드 또한 같지 않다
  따라서 다른 위치에서 데이터를 찾게 되고 검색에 실패한다.
- 우연히 해시 인덱스가 같아 같은 위치에서 검색을 하여도 equals()를 구현하지 않았기 때문에
  동등성 비교를 하지 못해 검색에 실패한다.

== 2. hashCode는 구현했지만 equals를 구현하지 않은 경우 ==

1) 데이터 저장 문제
- hashCode()를 재정의했기 때문에 Member 객체의 같은 id를 사용하는 두 객체는 같은 해시 코드를 사용한다.
- 따라서 같은 해시 인덱스에 데이터가 저장된다.
- set 자료 구조에서는 중복 데이터를 저장하면 안된다.
  하지만 내부에서 데이터를 순차 비교할 때 equals()를 사용한다.
- equals()를 재정의하지 않으면 Object의 equals()를 사용한다.
  따라서 인스턴스의 참조값을 비교한다. 인스턴스가 서로 다른 두 객체는 비교에 실패한다.
- 그 결과 set 자료 구조에 중복 데이터가 없다고 판단하고 두 객체를 모두 저장한다.
- 결과적으로 같은 회원 id를 가진 중복 데이터가 저장된다.

2) 데이터 검색 문제
- 회원 id가 A인 객체를 검색하기 위해 회원 id가 A인 객체를 만든다.
  해시 코드가 구현되어 있어 저장되어 있는 해시 인덱스를 찾을 수 있다.
- 해시 인덱스에 있는 모든 데이터를 equals()를 통해 비교해서 같은 값을 찾아야 한다.
- equals()를 재정의하지 않으면 Object의 equals()를 사용한다.
  따라서 인스턴스의 참조값을 비교한다. 인스턴스가 모두 다르므로 비교에 실패한다.
- 결과적으로 데이터를 찾을 수 없다.

== 3. hashCode, equals를 모두 구현한 경우 ==

1) 데이터 저장 문제
- hashCode()를 재정의했기 때문에 Member 객체의 같은 id를 사용하는 두 객체는 같은 해시 코드를 사용한다.
- 처음 객체를 저장 후 두 번째 같은 회원 id를 사용하는 객체를 저장할 때 equals() 비교한다.
  같은 데이터가 이미 있으므로 두 번째 객체는 저장되지 않는다.
- 결과적으로 중복 데이터가 저장되지 않는다.

2) 데이터 검색 문제
- 회원 id가 A인 객체를 검색하기 위해 회원 id가 A인 객체를 만든다.
  해시 코드가 구현되어 있어 저장되어 있는 해시 인덱스를 찾을 수 있다.
- 해시 인덱스에 있는 모든 데이터를 equals()를 통해 비교해서 같은 값을 찾아야 한다.
- equals()가 재정의 되어 있으므로 데이터를 찾을 수 있다.

* 정리
hashCode()를 항상 재정의해야 하는 것은 아니다. 하지만 해시 자료 구조를 사용하는 경우
hashCode()와 equals()를 반드시 함께 재정의해야 한다.
물론 직접 재정의하는 것은 쉽지 않으므로 IDE의 도움을 받자.

※참고 - 해시 함수는 해시 코드가 최대한 충돌하지 않도록 설계
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.
  해시가 충돌하면 결과적으로 같은 해시 인덱스에 보관된다. 따라서 성능이 나빠진다.

- 자바의 해시 함수는 이런 문제를 해결하기 위해 문자의 숫자를 단순히 더하기만 하는 것이 아니라
  내부에서 복잡한 추가 연산을 수행한다.
  복잡한 추가 연산으로 다양한 범위의 해시 코드가 만들어지므로 해시가 충돌할 가능성이 낮아지고,
  결과적으로 해시 자료 구조를 사용할 때 성능이 개선된다.

- 해시 함수는 같은 입력에 대해서 항상 동일한 해시 코드를 반환해야 한다.
  좋은 해시 함수는 해시 코드가 한 곳에 뭉치지 않고 균일하게 분포하는 것이 좋다.
  그래야 해시 인덱스도 골고루 분포되어서 해시 자료 구조의 성능을 최적화할 수 있다.

- 자바가 제공하는 해시 함수를 사용해도 같은 해시 코드가 생성되어 해시 코드가 충돌하는 경우도 존재한다.
  이 경우 같은 해시 코드를 가지기 때문에 해시 인덱스도 같게 된다.
  하지만 equals()를 사용해서 다시 비교하기 때문에 해시 코드가 충돌하더라도 문제가 되지는 않는다.
  그리고 매우 낮은 확률로 충돌하기 때문에 성능에 대한 부분도 크게 걱정하지 않아도 된다.


