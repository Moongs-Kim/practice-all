[set]

<리스트(List) vs 세트(Set)>
- List
  정의: 리스트는 요소들의 순차적인 컬렉션이다. 요소들은 특정 순서를 가지며, 같은 요소가 여러 번
       나타날 수 있다.
  특징: - 순서 유지: 리스트에 추가된 요소는 특정한 순서를 유지한다. 이 순서는 요소가 추가된 순서를
                   반영할 수 있다.
       - 중복 허용: 리스트는 동일한 값이나 객체의 중복을 허용한다.
       - 인덱스 접근: 리스트의 각 요소는 인덱스를 통해 접근할 수 있다.
  용도: 순서가 중요하거나 중복된 요소를 허용해야 하는 경우에 주로 사용된다.

- Set
  정의: 세트(셋)는 유일한 요소들의 컬렉션이다.
  특징: - 유일성: 셋에는 중복된 요소가 존재하지 않는다. 셋에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.
       - 순서 미보장: 대부분의 셋 구현에서는 요소들의 순서를 보장하지 않는다. 즉, 요소를 출력할 때 입력 순서와
                    다를 수 있다.
       - 빠른 검색: 셋은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있다. 이는 데이터의 중복을 방지하고
                   빠른 조회를 가능하게 한다.
  용도: 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.

예 - List: 장바구니 목록, 순서가 중요한 일련의 이벤트 목록
   - Set: 회원 ID 집합, 고유한 항목의 집합




<자바가 제공하는 Set1 - HashSet, LinkedHashSet>
- Set(세트, 셋) 자료 구조: 셋은 중복을 허용하지 않고, 순서를 보장하지 않는 자료 구조이다.

Set은 수학적 집합 개념을 구현한 것으로, 순서를 보장하지 않으며, 특정 요소가 집합에 있는지 여부를
확인하는데 최적화되어 있다.

== 컬렉션 프레임워크 - Set ==
Collection(interface) <- Set(interface) <- HashSet, LinkedHashSet
                      <- Set(interface) <- TreeSet

Set 인터페이스는 HashSet, LinkedHashSet, TreeSet 등의 여러 구현 클래스를 가지고 있으며,
각 클래스는 Set 인터페이스를 구현하며 각각의 특성을 가지고 있다.


1. HashSet
- 구현: 해시 자료 구조를 사용해서 요소를 저장한다.
- 순서: 요수들은 특정한 순서 없이 저장된다. 즉, 요소를 추가한 순서를 보장하지 않는다.
- 시간 복잡도: HashSet의 주요 연선(추가,삭제,검색)은 평균적으로 O(1) 시간 복잡도를 가진다.
- 용도: 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합하다.

2. LinkedHashSet
- 구현: LinkedHashSet은 HashSet에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
- 순서: 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환된다.
- 시간 복잡도: LinkedHashSet도 HashSet과 마찬가지로 주요 연산에 대해 평균 O(1) 시간 복잡도를 가진다.
- 용도: 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.
- 참고: 연결 링크를 유지해야 하기 때문에 HashSet 보다는 조금 더 무겁다.

- LinkedHashSet은 HashSet에 연결 링크만 추가한 것이다.
- HashSet에 LinkedList를 합친 것으로 이해하면 된다.
- 연결 링크는 데이터를 입력한 순서대로 연결되게 한다.

<자바가 제공하는 Set2 - TreeSet>
3. TreeSet
- 구현: TreeSet은  이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
- 순서: 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(Comparator)로 변경할 수 있다.
- 시간 복잡도: 주요 연산들은 O(log n)의 시간 복잡도를 가진다. 따라서 HashSet 보다는 느리다.
- 용도: 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다.
       예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다.
       참고로 입력된 순서가 아니라 데이터 값의 순서이다.

== 트리 구조 ==
- 트리는 부모 노드와 자식 노드로 구성된다.
- 가장 높은 조상을 루트(root)라 한다.
- 자식이 2개까지 올 수 있는 트리를 이진 트리라 한다.
- 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것을 이진 탐색 트리라 한다.
- TreeSet은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용한다.

== 트리 구조의 구현 ==
- 트리 구조는 왼쪽, 오른쪽 노드를 알고 있으면 된다.

== 이진 탐색 트리 - 입력 예시 ==
이진 탐색 트리의 핵심은 데이터를 입력하는 시점에 정렬해서 보관한다는 점이다.
그리고 작은 값은 왼쪽에 큰 값은 오른쪽에 저장하면 된다.

이진 탐색 트리 계산의 핵심은 한번에 절반을 날린 다는 점이다.

이진 탐색 트리의 빅오 = O(log n)

데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 날려버리기 때문에, O(n)과 비교해서
데이터의 크기가 클 수록 효과적이다.

하지만 트리의 균형이 맞지 않으면 최악의 경우 O(n)의 성능이 나온다.

== 이진 탐색 트리 개선 ==
문제를 해결하기 위해 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞춘다.

AVL 트리, 레드-블랙 트리 같은 균형을 맞추는 다양한 알고리즘이 존재한다.
자바의 TreeSet은 레드-블랙 트리를 사용해서 균형을 지속해서 유지한다.
따라서 최악의 경우에도 O(log n)의 성능을 제공한다.

== 이진 탐색 트리 - 순회 ==
- 이진 탐색 트리의 핵심은 입력 순서가 아니라, 데이터의 값을 기준으로 정렬해서 보관한다는 점이다.
- 따라서 정렬된 순서로 데이터를 차례로 조회할 수 있다.(순회 할 수 있다.)
- 데이터를 차례로 순회하려면 중위 순회라는 방법을 사용하면 된다. 왼쪽 서브트리를 방문한 다음,
  현재 노드를 처리하고, 마지막으로 오른쪽 서브트리를 방문한다. 이 방식은 이진 탐색 트리의 특성상,
  노드를 오름차순으로 방문한다.

※중위 순회 방식
쉽게 말하면 자신의 왼쪽의 모든 노드를 처리하고, 자신의 노드를 처리하고, 자신의 오른쪽 모든 노드를 처리하는
방식이다.


※참고 - TreeSet의 정렬 기준
TreeSet을 사용할 때 데이터를 정렬하려면 크다, 작다라는 기준이 필요하다.
이런 기준을 제공하려면 Comparable, Comparator 인터페이스를 구현해야 한다.

<자바가 제공하는 Set3 - 최적화>
자바 HashSet과 최적화
- 해시 기반 자료 구조를 사용하는 경우 통계적으로 입력한 데이터의 수가 배열의 크기를 75% 정도 넘어가면
  해시 인덱스가 자주 충돌한다. 따라서 75% 가 넘어가면 성능이 떨어지기 시작한다.
- 데이터가 동적으로 계속 추가되기 때문에 적절한 배열의 크기를 정하는 것은 어렵다.
- 자바의 HashSet은 데이터의 양이 배열 크기의 75%를 넘어가면 배열의 크기를 2배로 늘리고 2배로 늘어난
  크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다.
  (해시 인덱스를 다시 적용하는 시간이 걸리지만, 결과적으로 해시 충돌이 줄어든다.)

- 데이터양이 75% 이상이면 배열의 크기를 2배로 증가하고, 모든 데이터의 해시 인덱스를 커진 배열에 맞추어
  다시 계산한다. 이 과정을 재해싱(rehashing)이라 한다.
- 인덱스 충돌 가능성이 줄어든다.
- 여기서 데이터가 다시 75% 이상 증가하면 다시 2배 증가와 재계산을 반복한다.

* 정리
실무에서는 Set이 필요한 경우 HashSet을 가장 많이 사용한다. 그리고 입력 순서, 유지, 값 정렬의 필요에
따라서 LinkedHashSet, TreeSet을 선택하면 된다.
