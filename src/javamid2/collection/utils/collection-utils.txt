[컬렉션 유틸]

컬렉션 유틸: 컬렉션을 편리하게 다룰 수 있게 해주는것

<Collections 정렬 관련 메서드>
- max: 정렬 기준으로 최대 값을 찾아서 반환한다.
- min: 정렬 기준으로 최소 값을 찾아서 반환한다.
- shuffle: 컬렉션을 랜덤하게 섞는다.
- sort: 정렬 기준으로 컬렉션을 정렬한다.
- reverse: 정렬 기준의 반대로 컬렉션을 정렬한다.(컬렉션에 들어있는 결과를 반대로 정렬한다.)

<편리한 컬렉션 생성>
- List.of(...)를 사용하면 컬렉션을 편리하게 생성할 수 있다.
  단 이 때는 가변이 아니라 불변 컬렉션이 생성된다.
  List, Set, Map 모두 of() 메서드를 지원한다.
- 불변 컬렉션은 변경할 수 없다. 변경 메서드를 호출하면 UnsupportedOperationException 예외가
  발생한다.

== 불변 컬렉션과 가변 컬렉션 전환 ==
- 불변 리스트를 가변 리스트로 전환하려면 new ArrayList<>(ImmutableCollection)를 사용하면 된다.
- 가변 리스트를 불변 리스트로 전환하려면 Collections.unmodifiableList()를 사용하면 된다.
  다양한 unmodifiableXxx()가 존재한다.

== 빈 리스트 생성 ==
- 빈 가변 리스트는 원하는 컬렉션의 구현체를 직접 생성하면 된다.
- 빈 불변 리스트는 2가지 생성 방법이 있다.
  1) Collections.emptyList(): 자바5부터 제공되는 기능이다.
  2) List.of(): 자바9부터 제공되는 최신 기능이다.
  * List.of()가 더 간결하고, List.of(1,2,3)도 불변이기 때문에 사용법에 일관성이 있다.
    자바 9 이상을 사용한다면 이 기능을 권장한다.

== Arrays.asList() ==
Arrays.asList() 메서드를 사용해도 리스트를 생성할 수 있다.
참고로 이 메서드는 자바 1.2부터 존재했다.
★자바 9를 사용한다면 List.of()를 권장한다.

List<Integer> list = Arrays.asList(1, 2, 3);
List<Integer> list = List.of(1, 2, 3);

- Arrays.asList()로 생성된 리스트는 '고정된 크기를 가지지만, 요소들은 변경할 수 있다'.
  즉, 리스트의 길이는 변경할 수 없지만, 기존 위치에 있는 요소들을 다른 요소로 교체할 수 있다.
  - set()을 통해 요소를 변경할 수 있다.
  - add(), remove() 같은 메서드를 호출하면 예외가 발생한다. 크기를 변경할 수 없다.
    (java.lang.UnsupportedOperationException 발생)
- 고정도 가변도 아닌 애매한 리스트이다.

* 정리
- 일반적으로 List.of()를 사용하는 것을 권장한다.

다음과 같은 경우 Arrays.asList()를 선택할 수 있다.
- 변경 가능한 요소: 리스트 내부의 요소를 변경해야 하는 경우(단, 리스트의 크기는 변경할 수 없음)
- 하위 호환성: Java 9 이전 버전에서 작업해야 하는 경우

<멀티스레드 동기화>
- Collections.synchronizedList를 사용하면 일반 리스트를 멀티스레드 상황에서 동기화 문제가 발생하지 않는
  안전한 리스트로 만들 수 있다.
- 동기화 작업으로 인해 일반 리스트보다 성능은 더 느리다.

<컬렉션 프레임워크 전체 정리>

자바 컬렉션 프레임워크는 데이터 그룹을 저장하고 처리하기 위한 통합 아키텍처를 제공한다.
이 프레임워크는 '인터페이스, 구현, 알고리즘'으로 구성되어 있으며, 다양한 타입의 컬렉션을 효율적으로
처리할 수 있게 해준다.
여기서 컬렉션이란 객체의 그룹이나 집합을 의미한다.

== Collection 인터페이스의 필요성 ==
Collection 인터페이스는 자바 컬렉션 프레임워크의 가장 기본적인 인터페이스로, 자바에서 데이터 그룹을 다루는데
필요한 가장 기본적인 메서드들을 정의한다. 그리고 다양한 컬렉션 타입들이 공통적으로 따라야 하는 기본 규약을 정의
한다. List, Set, Queue와 같은 더 구체적인 컬렉션 인터페이스들은 모두 Collection 인터페이스를 확장(extend)하여,
공통된 메서드들을 상속받고 추가적인 기능이나 특성을 제공한다. 이러한 설계는 자바 컬렉션 프레임워크의 일관성과
재사용성을 높여준다.

- 일관성: 모든 컬렉션 타입들이 Collection 인터페이스를 구현함으로써, 모든 컬렉션들이 기본적인 동작을 공유한다는 것을
         보장한다. 이는 개발자가 다양한 타입의 컬렉션을 다룰 때 일관된 방식으로 접근할 수 있게 해준다.
- 재사용성: Collection 인터페이스에 정의된 메서드들은 다양한 컬렉션 타입들에 공통으로 적용된다.
           이는 코드의 재사용성을 높이고, 유지 보수를 용이하게 한다.
- 확장성: 새로운 컬렌션 타입을 만들 때 Collection 인터페이스를 구현함으로써, 기존에 정의된 알고리즘과 도구를
         사용할 수 있게 된다. 이는 프레임워크의 확장성을 향상시킨다.
- 다형성: Collection 인터페이스를 사용함으로써, 다양한 컬렉션 타입들을 같은 타입으로 다룰 수 있다.
         이는 다형성을 활용해서 유연한 코드를 작성할 수 있게 해준다.

- Collection 인터페이스의 주요 메서드
  add, remove, size, isEmpty, contains, iterator, clear

Collection은 Map을 제외한 모든 컬렌션 타입의 부모이다. 따라서 모든 컬렉션을 받아서 유연하게 처리할 수 있다.
대표적으로 컬렉션 인터페이스는 iterator를 제공한다. 따라서 데이터를 단순히 순회할 목적이라면 Collection을 사용하면
모든 컬렉션 타입의 데이터를 순회할 수 있다.

컬렉션 프레임워크는 크게 '인터페이스, 구현, 알고리즘'을 제공한다.

== 인터페이스 ==
자바 컬렉션 프레임워크의 핵심 인터페이스
- Collection: 단일 루트 인터페이스로, 모든 컬렉션 클래스가 이 인터페이스를 상속받는다.
              List, Set, Queue 등의 인터페이스가 여기에 포함된다.
- List: 순서가 있는 컬렉션을 나타내며, 중복 요소를 허용한다. 인덱스를 통해 요소에 접근할 수 있다.
        ex) ArrayList, LinkedList
- Set: 중복 요소를 허용하지 않는 컬렉션을 나타낸다. 특정 위치가 없기 때문에 인덱스를 통해 요소에
       접근할 수 없다.
       ex) HashSet, LinkedHashset, TreeSet
- Queue: 요소가 처리되기 전에 보관되는 컬렉션을 나타낸다.
         ex) ArrayDeque, LinkedList, PriorityQueue
- Map: 키와 값 쌍으로 요소를 저장하는 객체이다. Map은 Collection 인터페이스를 상속받지 않는다.
       ex) HashMap, LinkedHashMap, TreeMap

== 구현 ==
자바는 각 인터페이스의 여러 구현을 제공한다.
- List: ArrayList는 내부적으로 배열을 사용하며, LinkedList는 연결 리스트를 사용한다.
- Set: HashSet은 해시 테이블을, LinkedHashSet은 해시 테이블과 연결 리스트를,
       TreeSet은 레드-블랙 트리를 사용한다.
- Map: HashMap은 해시 테이블을, LinkedHashMap은 해시 테이블과 연결 리스트를,
       TreeMap은 레드-블랙 트리를 사용한다.
- Queue: LinkedList는 연결 리스트를 사용한다. ArrayDeque는 배열 기반의 원형 큐를 사용한다.
         대부분의 경우 ArrayDeque가 빠르다.

== 알고리즘 ==
컬렉션 프레임워크는 데이터를 처리하고 조작하기 위한 다양한 알고리즘을 제공한다. 이러한 알고리즘은 각각의
자료 구조 자체적으로 기능을 제공하기도 하고 또 Collections와 Arrays 클래스에 정적 메소드 형태로도 구현
되어 있다. 이를 통해 정렬, 검색, 순환, 변환 등의 작업을 수행할 수 있다.

== 선택 가이드 ==
- 순서가 중요하고 중복이 허용되는 경우: List 인터페이스를 사용하자. ArrayList가 일반적인 선택이지만,
                        추가/삭제 작업이 앞쪽에서 빈번한 경우에는 LinkedList가 성능상 더 좋은 선택이다.
- 중복을 허용하지 않고 순서가 중요하지 않은 경우: HashSet을 사용하자. 순서를 유지해야 하면 LinkedHashSet을,
                        정렬된 순서가 필요하면 TreeSet을 사용하자
- 요소를 키-값 쌍으로 저장하려는 경우: Map 인터페이스를 사용하자. 순서가 중요하지 않다면 HashMap을, 순서를 유지해야
                        한다면 LinkedHashMap을, 정렬된 순서가 필요하면 TreeMap을 사용하자
- 요소를 처리하기 전에 보관해야 하는 경우: Queue, Deque 인터페이스를 사용하자. 스택, 큐 구조 모두 ArrayDeque를
                        사용하는 것이 가장 빠르다. 만약 우선순위에 따라 요소를 처리해야 한다면 PriorityQueue를 고려하자

※참고
PriorityQueue는 큐에 입력하는 요소에 우선순위를 부여할 수 있다.

== 실무 선택 가이드 ==
- List의 경우 대부분 ArrayList를 사용한다.
- Set의 경우 대부분 HashSet을 사용한다.
- Map의 경우 대부분 HashMap을 사용한다.
- Queue의 경우 대부분 ArrayDeque를 사용한다.





