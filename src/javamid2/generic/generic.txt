[제네릭]

<제네릭이 필요한 이유>
대부분의 최신 프로그래밍 언어는 제네릭(Generic) 개념을 제공한다.

Object 타입의 변수로 모든 클래스를 다 받을 수 있는 Box가 있을때 문제점
1. 반환 타입이 Object 이므로 내가 원하는 타입으로 반환 받을 때
   직접 다운 캐스팅을 해야한다.
2. ★잘못된 타입의 인수 전달 문제 -> 잘못된 타입의 값을 전달하면 값을 꺼낼 때 문제가 발생한다.
   모든 타입의 부모인 Object를 매개변수로 받기 때문에 모든 데이터를 입력 받을 수 있다.
   따라서 원하는 타입과 다른 타입을 입력해도 문제가 되지 않는다.

* 정리
- Object 타입을 사용하면 ObjectBox 하나로 모든 타입을 입력 받을 수 있어 코드의 중복이 제거되고
  기존 코드를 재사용할 수 있게 된다.
- 하지만 입력할 때 실수로 원하지 않는 타입이 들어갈 수 있는 '타입 안정성 문제'가 발생한다.
  -> 모든 타입을 받을 수 있기 때문
  -> 값을 반환 받을 때도 Object를 반환하기 때문에 원하는 타입을 정확하게 받을 수 없고
     항상 위험한 다운 캐스팅을 시도해야 한다.

결과적으로 이 방식은 '타입 안정성'이 떨어진다.

코드 재사용을 늘리기 위해 Object와 다형성을 사용하면 타입 안정성이 떨어지는 문제가 발생한다.
'코드 재사용'과 '타입 안정성'이라는 2마리 토끼를 한번에 잡을 수 없다.

<제네릭 적용>
제네릭을 사용하면 '코드 재사용'과 '타입 안정성'이라는 두 마리 토끼를 한 번에 잡을 수 있다.

GenericBox<T>

- 위와 같이 <>를 사용한 클래스를 제네릭 클래스라 한다. <> 기호는 보통 다이아몬드라 한다.
- 제네릭 클래스를 사용할 때는 Integer, String 같은 타입을 미리 결정하지 않는다.
- 대신에 클래스명 오른쪽에 <T> 와 같이 선언하면 제네릭 클래스가 된다.
  T 를 '타입 매개변수'라 한다. 이 타입 매개변수는 이후에 Integer, String 으로 변할 수 있다.
- 클래스 내부에 T 타입이 필요한 곳에 T value 와 같이 타입 매개변수를 적어두면 된다.

ex. T가 모두 Integer로 변했다면 Integer 타입을 입력하고 조회할 수 있다.
    set(Integer value) 이므로 Integer 숫자만 담을 수 있다.
    get()의 경우에도 Integer를 반환하기 때문에 '타입 캐스팅 없이' 숫자 타입으로 조회할 수 있다.


== 원하는 모든 타입 사용 가능 ==
제네릭 클래스를 사용하면 객체를 생성하는 시점에 원하는 타입을 마음껏 지정할 수 있다.

참고로 제네릭을 도입한다고 해서 GenericBox<String>, GenericBox<Integer>와 같은 코드가
실제 만들어지는 것은 아니다. 대신 자바 컴파일러가 입력한 타입 정보를 기반으로 이런 코드가 있다고
가정하고 컴파일 과정에 타입 정보를 반영한다. 이 과정에서 타입이 맞지 않으면 컴파일 오류가 발생한다.

== 타입 추론 ==
GenericBox<Integer> integerBox = new GenericBox<Integer>()
GenericBox<Integer> integerBox = new GenericBox<>()

위의 첫번째 줄의 코드를 보면 변수를 선언할 때와 객체를 생성할 때 <Integer>가 두 번 나온다.
자바는 왼쪽에 있는 변수를 선언할 때의 <Integer>를 보고 오른쪽에 있는 객체를 생성할 때 필요한
타입 정보를 얻을 수 있다. 따라서 두 번째줄의 오른쪽 코드 new GenericBox<>()와 같이 타입 정보를
생략할 수 있다.
이렇게 자바가 스스로 타입 정보를 추론해서 개발자가 타입 정보를 생략할 수 있는 것을 타입 추론이라 한다.
타입 추론이 그냥 되는 것은 아니고, 자바 컴파일러가 타입을 추론할 수 있는 상황에만 가능하다.
쉽게 말해 읽을 수 있는 타입 정보가 주변에 있어야 추론할 수 있다.

* 정리
제네릭을 사용한 덕분에 코드 재사용과 타입 안정성이라는 두 마리 토끼를 모두 잡을 수 있다.

<제네릭 용어와 관례>
제네릭의 핵심은 '사용할 타입을 미리 결정하지 않는다는 점'이다.
클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라
'실제 사용하는 생성 시점'에 타입을 결정하는 것이다.
이것을 비유하자면 메서드의 매개변수의 인자의 관계와 비슷하다.

== 메서드에 필요한 값을 메서드 정의 시점에 미리 결정 ==
void method() {
    println("hello");
}
- 메서드에 필요한 값을 위와 같이 메서드 정의 시점에 미리 결정하게 되면, 이 메서드는 오직
  "hello"라는 값만 출력할 수 있다. 따라서 재사용성이 떨어진다.

== 메서드에 필요한 값을 인자를 통해 매개변수로 전달해서 결정
void method(String param) {
    println(param);
}
- 메서드에 필요한 값을 메서드를 정의하는 시점에 미리 결정하는 것이 아니라, 메서드를 실제
  사용하는 시점으로 미룰 수 있다.
- 메서드에 매개변수 (String param)를 지정하고, 메서드를 사용할 때 원하는 값을 인자로
  전달하면 된다.
- 매개변수를 정의하고, 실행 시점에 인자를 통해 원하는 값을 매개변수에 전달하면
  이 메서드는 실행 시점에 얼마든지 다른 값을 받아서 처리할 수 있다.
  따라서 재사용성이 크게 늘어난다.

== 제네릭의 타입 매개변수와 타입 인자 ==
제네릭도 위에서 말한 메서드의 매개변수와 인자의 관계와 비슷하게 작동한다.
제네릭 클래스를 정의할 때 내부에서 사용할 타입을 미리 결정하는 것이 아니라, 해달 클래스를 실제 사용하는 생성 시점에
내부에서 사용할 타입을 결정하는 것이다.
차이가 있다면 '메서드의 매개변수는 사용할 값에 대한 결정을 나중으로 미루는 것'이고,
            '제네릭의 타입 매개변수는 사용할 타입에 대한 결정을 나중으로 미루는 것'이다.

== 용어 정리 ==
- 메서드는 '매개변수'에 '인자'를 전달해서 '사용할 값'을 결정한다.
- 제네릭 클래스는 '타입 매개변수'에 '타입 인자'를 전달해서 '사용할 타입'을 결정한다.

제네릭에서 사용하는 용어도 매개변수, 인자의 용어를 그대로 사용한다.
다만 값이 아니라 '타입을 결정'하는 것이기 때문에 앞에 타입을 붙인다.
- 타입 매개변수: GenericBox<T> 에서 T
- 타입 인자: GenericBox<Integer> 에서 Integer
            GenericBox<String> 에서 String

제네릭 타입의 타입 매개변수 <T>에 타입 인자를 전달해서 제네릭의 사용 타입을 결정한다.
GenericBox<T>
- Integer -> GenericBox<Integer>
- String -> GenericBox<String>

- 제네릭(Generic) 단어
  - 제네릭이라는 단어는 일반적인, 범용적인 이라는 영어 단어 뜻이다.
  - 풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.
- 제네릭 타입 (Generic Type)
  - 클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
  - 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
    (타입은 클래스, 인터페이스, 기본형(int등)을 모두 합쳐서 부르는 말이다.
    ex) class GenericBox<T> { pirvate T t; }
        여기에서 GenericBox<T>를 제네릭 타입이라 한다.
- 타입 매개변수(Type Parameter)
  - 제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.
    ex) GenericBox<T>
    여기에서 T를 타입 매개변수라 한다.
- 타입 인자 (Type Argument)
  - 제네릭 타입을 사용할 때 제공되는 실제 타입이다.
    ex) GenericBox<Integer>
    여기에서 Integer를 타입 인자라 한다.

== 제네릭 명명 관례 ==
타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.
하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.

주로 소용하는 키워드
- E - Element
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

== 제네릭 기타 ==
class Data<K, V> {}
위와 같이 한번에 여러 타입 매개변수를 선언할 수 있다.

타입 인자로 기본형은 사용할 수 없다.
제네릭 타입의 인자로 기본형(int, double ..) 은 사용할 수 없다.
대신에 래퍼 클래스(Integer, Double) 를 사용하면 된다.

== 로 타입 - raw type ==
제네릭 타입을 사용할 때는 항상 <>를 사용해서 사용시점에 원하는 타입을 지정해야 한다.
그런데 다음과 같이 <>을 지정하지 않을 수 있는데, 이런 것을 로 타입(raw type), 또는 원시 타입이라 한다.
GenericBox integerBox = new GenericBox();

원시 타입을 사용하면 내부의 타입 매개변수가 Object로 사용된다고 이해하면 된다.

- 로 타입을 지원하는 이유 -
제네릭 타입을 사용할 때는 항상 <>를 사용해서 사용시점에 원하는 타입을 지정해야 한다.
그런데 왜 위와같이 로 타입을 지원하는 것일까?

자바의 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에
제네릭이 없던 시절의 과거 코드와의 하위 호환이 필요했다. 그래서 어쩔 수 없이 로 타입을 지원한다.

정리하면 '로 타입을 사용하지 않아야 한다.'
만약 Object 타입을 사용해야 한다면 다음과 같이 인자로 Object를 지정해서 사용하면 된다.
GenericBox<Object> integerBox = new GenericBox<>();

== 상속관계에 있는 클래스들의 다형성 ==
Animal 클래스와 자식으로 Dog, Cat 클래스가 있을때
Box<T> 에서 T를 부모 타입인 Animal 으로 지정하면
자식인 Dog, Cat 또한 Box<T>에 담길 수 있다.
다형성 적용: Animal animal = new Dog();
           Animal animal = new Cat();

