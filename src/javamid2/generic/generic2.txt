[제네릭]

<타입 매개변수 제한★>
== 문제 인식 ==
- 제네릭 타입을 선언하면 자바 컴파일러 입장에서 T에 어떤 값이 들어올지 예측할 수 없다.
ex) Animal 타입의 자식이 들어오기를 기대하고 제네릭 클래스를 정의하지만
    코드 어디에도 Animal에 대한 정보는 없다.
    T에는 타입 인자로 Integer가 들어올 수도 있고, Dog가 들어올 수도 있다.
    물로 Object가 들어올 수도 있다.

- 자바 컴파일러는 어떤 타입이 들어올 지 알 수 없기 때문에 T를 어떤 타입이든 받을 수 있는
  모든 객체의 최종 부모인 Object 타입으로 가정한다. 따라서 Object가 제공하는 메서드만 호출할 수 있다.
ex) 원하는 기능을 사용하려면 Animal 타입이 제공하는 기능들이 필요한데, 이 기능을 모두 사용할 수 없다.
    또한, Integer, Object 같은 동물과 전혀 관계 없는 타입을 타입 인자로 전달 할 수 있다는 점도 문제다.
    최소한 Animal 이나 그 자식을 타입 인자로 제한하고 싶다.

* 문제
- 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다.
- 따라서 타입 매개변수를 어떤 타입이든 수용할 수 있는 Object로 가정하고,
  Object의 기능만 사용할 수 있다.

== 타입 매개변수를 특정 타입으로 제한★ ==
ex) AnimalHospitalV3<T extends Animal>
여기서 핵심은 <T extends Animal> 이다.
타입 매개변수 T를 Animal과 그 자식만 받을 수 있도록 제한
즉, T의 상한이 Animal이 되는 것이다.

위와 같이 제한을 하면
자바 컴파일러는 T에 입력될 수 있는 값의 범위를 예측할 수 있다.
타입 매개변수는 T에는 타입 인자로 Animal, Dog, Cat만 들어올 수 있다.
따라서 이를 모두 수용할 수 있는 Animal을 T의 타입으로 가정(자바 컴파일러가)해도 문제가 없다.
그래서 Animal이 제공하는 메서드를 사용할 수 있다.

== 정리 - 기존 문제와 해결 ==
타입 안정성X 문제
- 개 병원에 고양이를 전달하는 문제가 발생한다.
- Animal 타입을 반환하기 때문에 다운 캐스팅을 해야 한다.
- 실수로 고양이를 입력했는데, 개를 반환하는 상황이라면 캐스팅 예외가 발생한다.

제네릭 도입 문제
- 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다.
- 어떤 타입이든 수용할 수 있는 Object로 가정하고, Object의 기능만 사용할 수 있다.
  여기서는 Animal을 상한으로 두어서 Animal의 기능을 사용할 수 있다.

* 정리
제네릭에 '타입 매개변수 상한'을 사용해서 타입 안정성을 지키면서 상위 타입의 원하는 기능까지
사용할 수 있다.
이 덕분에 코드 재사용과 타입 안정성이라는 두 마리 토끼를 동시에 잡을 수 있다.

<제네릭 메서드>
특정 메서드에 제네릭을 적용하는 제네릭 메서드
★제네릭 타입과 제네릭 메서드는 둘다 제네릭을 사용하지만 서로 다른 기능을 제공한다.

- 제네릭 타입
  정의: GenericClass<T>
  타입 인자 전달: 객체를 생성하는 시점
    ex) new GenericClass<String>

- 제네릭 메서드
  정의: <T> T genericMethod(T t)
  타입 인자 전달: 메서드를 호출하는 시점
    ex) GenericMethod.<Integer>genericMethod(i)

  - 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
  - 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드(<>)를 사용해서
    <T>와 같이 타입 매개변수를 적어준다.
  - 제네릭 메서드는 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 <Integer>와 같이
    타입을 정하고 호출한다.
  - 제네릭 메서드는 인스턴스 메서드와 static 메서드에 모두 적용할 수 있다.

★핵심
제네릭 메서드의 핵심은 메서드를 호출하는 시점에 타입 인자를 전달해서 타입을 지정하는 것이다.
따라서 타입을 지정하면서 메서드를 호출한다.

※참고
★제네릭 타입은 static 메서드에 타입 매개변수를 사용할 수 없다.
제네릭 타입은 객체를 생성하는 시점에 타입이 정해진다. 그런데 static 메서드는
인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무관하다.
따라서 static 메서드에 제네릭을 도입하려면 제네릭 메서드를 사용해야 한다.

== 타입 매개변수 제한 ==
제네릭 메서드도 제네릭 타입과 마찬가지로 타입 매개변수를 제한할 수 있다.
ex) public <T extends Number> T numberMethod(T t) {}


== 제네릭 메서드 타입 추론 ==
제네릭 메서드를 호출할 때 <Integer>와 같이 타입 인자를 계속 전달하는 것은 매우 불편하다.
ex) Integer i = 10;
    GenericMethod.<Integer>genericMethod(i)

자바 컴파일러는 genericMethod()에 전달되는 인자 i의 타입이 Integer 라는 것을 알 수 있다.
또한 반환 타입이 Integer result 라는 것도 알 수 있다.
이런 정보를 통해 자바 컴파일러는 타입 인자를 추론할 수 있다.
ex) Integer i = 10;
    GenericMethod.genericMethod(i) -> i를 통해 타입 추론 가능

타입 추론 덕분에 타입 인자를 직접 전달하는 불편함이 줄어든다.
이 경우 타입을 추론해서 컴파일러가 대신 처리하기 때문에 타입을 전달하지 않는 것 처럼 보인다.
하지만 실제로는 타입 인자가 전달된다는 것을 기억하자.


== 제네릭 타입과 제네릭 메서드의 우선순위 ==
정적 메서드는 제네릭 메서드만 적용할 수 있지만,
인스턴스 메서드는 제네릭 타입도 제네릭 메서드도 둘다 적용할 수 있다.

제네릭 타입과 제네릭 메서드의 타입 매개변수를 같은 이름으로 사용한다면 된다면?

★제네릭 타입보다 제네릭 메서드가 높은 우선순위를 가진다.
★프로그래밍에서 모호한 것은 좋지않다.
  이름이 겹치면 둘 중 하나를 다른 이름으로 변경하는 것이 좋다.

<와일드카드>
제네릭 타입을 조금 더 편리하게 사용할 수 있는 와일드카드(wildcard)에 대해 알아본다.
참고로 와일드카드라는 뜻은 컴퓨터 프로그래밍에서 *,? 와 같이 하나 이상의 문자들을 상징하는
특수 문자를 뜻한다.
쉽게 말해 여러 타입이 들어올 수 있다는 뜻이다.

★참고
와일드카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다.
와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용한다.

== 비교 - 제네릭 메서드, 와일드카드 ==

1. 비제한 와일드 카드
  제네릭 메서드이다.
  Box<Dog> dogBox를 전달한다. 타입 추론에 의해 타입 T 가 Dog가 된다.

static <T> void printGenericV1(Box<T> box) {
        System.out.println("T = " + box.get());
    }
 -------------------------------
  일반적인 메서드. 제네릭 메서드가 아니다.
  Box<Dog> dogBox를 전달한다. 와일드카드 ?는 모든 타입을 받을 수 있다.

static void printWildcardV1(Box<?> box) {
    System.out.println("? = " + box.get());
}

- 두 메서드는 비슷한 기능을 하는 코드이다.
  하나는 제네릭 메서드를 사용, 하나는 일반적인 메서드에 와일드카드를 사용했다.
- ★와일드카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아니다.
  Box<Dog>, Box<Cat> 처럼 타입 인자가 정해진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
- 와일드카드인 ?는 모든 타입을 다 받을 수 있다는 뜻이다.
  해석하면 ? -> <? extends Object>
- ?만 사용해서 제한 없이 모든 타입을 다 받을 수 있는 와일드카드를 비제한 와일드카드라 한다.
  여기에는 Box<Dog>, Box<Cat>, Box<Object> 가 모두 입력될 수 있다.


== 제네릭 메서드 vs 와일드카드 ==
- 제네릭 메서드에는 타입 매개변수가 존재한다. 그리고 특정 시점에 타입 매개변수에 타입 인자를
  전달해서 타입을 결정해야 한다. 이런 과정은 매우 복잡하다.
- 와일드카드는 일반적인 메서드에 사용할 수 있고, 단순히 '매개변수로 제네릭 타입을 받을 수 있는 것' 뿐이다.
  제네릭 메서드처럼 타입을 결정하거나 복잡하게 작동하지 않는다.
  단순히 일반 메서드에 제네릭 타입을 받을 수 있는 매개변수가 하나 있는 것 뿐이다.
- 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면,
  더 단순한 와일드카드 사용을 권장한다.

※내 생각
제네릭 타입은 타입 추론을 거쳐야 하지만
와일드카드는 이미 타입이 확정된 객체를 매개변수로 받는거 같다.

2. 상한 와일드카드
- 제네릭 메서드와 마찬가지로 와일드카드에도 상한 제한을 둘 수 있다.
  ex) ? extends Animal
- Animal과 그 하위 타입만 입력 받는다. 다른 타입을 입력하면 컴파일 오류가 발생한다.
- box.get()을 통해서 꺼낼 수 있는 타입의 최대 부모는 Animal이 된다.
  따라서 Animal 타입으로 조회할 수 있다.
- 결과적으로 Animal 타입의 기능을 호출할 수 있다.

== 타입 매개변수가 꼭 필요한 경우 ==
와일드카드는 제네릭을 정의할 때 사용하는 것이 아니다.
Box<Dog>, Box<Cat> 처럼 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다.

- 제네릭 메서드 -
static <T extends Animal> T printAndReturnGeneric(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
    return t;
}

Dog dog = WildcardEx.printAndReturnGeneric(dogBox);

제네릭 메서드를 사용하면 전달한 타입(여기선 Dog)을 명확하게 반환할 수 있다.

- 와일드카드 -
static Animal printAndReturnWildcard(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
    return animal;
}

Animal animal = WildcardEx.printAndReturnWildcard(dogBox);

반면 와일드카드를 사용하면 전달한 타입(여기선 Dog)을 명확하게 반환할 수 없다.
여기선 Animal 타입 반환

★중요
- 메서드의 타입들을 특정 시점에 변경하려면 제네릭 타입이나, 제네릭 메서드를 사용해야 한다.
- 와일드카드는 이미 만들어진 제네릭 타입을 전달 받아서 활용할 때 사용한다.
  따라서 메서드의 타입들을 타입 인자를 통해 변경할 수 없다.
  쉽게 일반적인 메서드에 사용한다고 생각하면 된다.
- 정리하면 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 <T>를 사용하고,
  그렇지 않은 상황이면 와일드카드를 사용하는 것을 권장한다.

※내 생각
- 제네릭 타입은 타입이 정해져 있지 않다
  따라서 제네릭 타입은 인자로 타입을 전달하면 정확한 타입을 알 수 있다.
  비유: 메서드 매개변수를 정의하면 입력시점에 값을 정할 수 있듯
       제네릭 타입은 생성시점에 타입을 정한다

- 와일드카드는 타입이 정해져있다(최대 상한 제한까지)
  상한 제한까지 타입이 들어오는거 까진 알 수 있지만 그 하위 타입인지 아닌지는 명확히 알 수 없다.
  따라서 반환 타입이 상한제한 한것으로 정해진다.
  비유: 일반적인 메서드와 같이 타입을 미리 지정해 놓는다
       일반 메서드에서도 매개변수에 다형성을 지정하면 입력 값으로
       부모가 입력될지 자식이 입력될지 알 수 없듯이
       와일드카드로 매개변수를 지정하면 부모의 제네릭 타입이 들어올지
       자식의 제네릭 타입이 들어올지 알 수 없다.
       와일드카드는 그저 제네릭 타입의 값을 입력 받는다고 생각하자

3. 하한 와일드 카드
와일드카드는 상한 뿐만 아니라 하한도 지정할 수 있다.
제네릭 타입에서는 할 수 없다.

ex) Box<? super Animal> box
이 코드는 ?가 Animal 타입을 포함한 Animal 타입의 상위 타입만 입력 받을 수 있다는 뜻이다.

Box<Object> objBox = new Box<>(); -> 허용
Box<Animal> animalBox = new Box<>(); -> 허용
Box<Dog> dogBox = new Box<>(); -> 불가
Box<Cat> catBox = new Box<>(); -> 불가

하한을 Animal로 제한했기 때문에 Animal 타입의 타입인 Box<Dog>는 전달할 수 없다.

<타입 이레이저>
이레이저(eraser)는 지우개 등으로 지우다라는 뜻이ㅏㄷ.
★제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다.
제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
쉽게 말해 컴파일 전인 .java 에는 제네릭의 타입 매개변수가 존재하지만,
컴파일 이후인 자바 바이트코드 .class 에는 타입 매개변수가 존재하지 않는 것이다.

100% 정확한건 아니지만 대략 아래와 같은 방식으로 작동한다고 이해하면 된다.

1. 상한 제한 없이 선언된 타입 매개변
   T는 Object로 변환된다.
   값을 반환 받는 부분: 자바 컴파일러는 제네릭에서 타입 인자로 지정한 타입으로
                     캐스팅하는 코드를 추가해준다.
                     이렇게 추가된 코드는 자바 컴파일러가 이미 검증하고 추가했기 때문에
                     문제가 발생하지 않는다.

2. 타입 매개변수 제한
   T는 상한으로 지정한 타입으로 대체된다. 따라서 상한으로 지정한 타입의 메서드를 사용하는데 문제가 없다.
   값을 반환 받는 부분: 반환 받는 부분을 상한으로 지정한 타입으로 받으면 안되기 때문에
                     자바 컴파일러가 타입 인자로 지정한 타입으로 캐스팅하는 코드를 넣어준다.

* 자바의 제네릭은 단순하게 생각하면 개발자가 직접 캐스팅 하는 코드를 컴파일러가 대신 처리해주는 것이다.
  자바는 컴파일 시점에 제네릭을 사용한 코드에 문제가 없는지 완벽하게 검증하기 때문에 컴파일러가 추가하는
  다운 캐스팅에는 문제가 발생하지 않는다.

* 자바의 제네릭 타입은 컴파일 시점에만 존재하고, 런타임 시에는 제네릭 정보가 지워지는데,
  이것을 타입 이레이저라 한다.


== 타입 이레이저 방식의 한계 ==
컴파일 이후에는 제네릭의 타입 정보가 존재하지 않는다. .class로 자바를 실행하는 런타임에는
우리가 지정한 Box<Integer>, Box<String> 타입 정보가 모두 제거된다.

class EraserBox<T> 일 경우
컴파일 전
public boolean instanceCheck(Object param) {
    return param instanceof T; // 오류
}
컴파일 후
public boolean instanceCheck(Object param) {
    return param instanceof Object; // T -> Object로 변환
}

컴파일 전
public T create() {
    return new T(); // 오류
}
컴파일 후
public T create() {
    return new Object(); // T -> Object로 변환
}

- T는 런타임에 모두 Object가 되어버린다.
- instanceof는 항상 Object와 비교하게 된다. 이렇게 되면 항상 참이 반환되는 문제가 발생한다.
  자바는 이런 문제 때문에 타입 매개변수를 instanceof에 사용하는 것을 허용하지 않는다.
- new T는 항상 new Object가 되어버린다. 개발자가 의도한 것과는 다르다.
  따라서 자바는 타입 매개변수를 new에 사용하는 것을 허용하지 않는다.


<제네릭 마무리 정리>
- 실무에서 직접 제네릭을 사용해서 무언가를 설계하거나 만드는 일은 드물다.
- 대부분 이미 제네릭을 통해 만들어진 프레임워크나 라이브러리들을 가져다 사용하는 경우가 훨씬 많다.
- 이미 만들어진 코드의 제네릭을 읽고 이해하는 정도면 충분하다.
- 실무에서 직접 제네릭을 사용하더라도 어렵고 복잡하게 사용하기 보다는 보통 단순하게 사용한다.
- 즉 지금까지 학습한 정도면 실무에 필요한 제네릭은 충분히 이해했다고 볼 수 있다.

- 제네릭은 지금까지 설명한 내용보다 더 복잡하고 어려운 개념들도 있다.
- 특히 공변(covariant), 반공변(contravariant)과 같은 개념들이 그렇다.
- 이런 개념들을 이해하면 와일드카드가 존재하는 이유도 더 깊이있게 알 수 있다.
- 하지만 제네릭을 사용해서 매우 복잡한 라이브러리나 프레임워크를 직접 설계하지 않는 이상
  이런 개념들을 꼭 이해할 필요는 없다. 이런 부분은 실무에서 많은 경험을 쌓고 본인이 필요하다고
  느껴질 때 따로 공부하는 것을 권장한다.

- 제네릭은 컬렉션 프레임워크에서 가장 많이 사용된다. 따라서 컬렉션 프레임워크를 통해서 제네릭이
  어떻게 활용되는지 자연스럽게 학습할 수 있다.
